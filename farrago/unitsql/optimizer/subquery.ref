> !set verbose on
> !set force on
> 
> set schema 'sales';
> 
> alter system set "calcVirtualMachine" = 'CALCVM_JAVA';
> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
> 
> -- 1.1 uncorrelated IN:  the only subquery that actually works!
> explain plan without implementation for
> select name from emps where deptno in (select deptno from depts) order by name;
+----------------------------------------------------------------+
|                            column0                             |
+----------------------------------------------------------------+
| SortRel(sort0=[$0], dir0=[Ascending])                          |
|   ProjectRel(NAME=[$1])                                        |
|     FilterRel(condition=[IS TRUE(true)])                       |
|       FilterRel(condition=[=($2, $10)])                        |
|         JoinRel(condition=[true], joinType=[inner])            |
|           TableAccessRel(table=[[LOCALDB, SALES, EMPS]])       |
|           AggregateRel(groupCount=[1])                         |
|             ProjectRel(DEPTNO=[$0])                            |
|               TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+----------------------------------------------------------------+
> 
> explain plan for
> select name from emps where deptno in (select deptno from depts) order by name;
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                column0                                                                                 |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                              |
|   FennelSortRel(key=[[0]], discardDuplicates=[false])                                                                                                                  |
|     FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])  |
|       LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[LEFTSEMI])                                                                                                 |
|         FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])                                                  |
|         FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])                 |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
> 
> select name from emps where deptno in (select deptno from depts) order by name;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| Wilma  |
+--------+
> 
> -- 1.2 NOT IN
> -- parsing works now
> -- only in list (and not transformed into valueRel) has correct plan and result
> explain plan for
> select name from emps where deptno in (10, 20);
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                            column0                                                                            |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| IterCalcRel(expr#0..1=[{inputs}], expr#2=[10], expr#3=[=($t1, $t2)], expr#4=[20], expr#5=[=($t1, $t4)], expr#6=[OR($t3, $t5)], NAME=[$t0], $condition=[$t6])  |
|   FennelToIteratorConverter                                                                                                                                   |
|     FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])                                             |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
> 
> select name from emps where deptno in (10, 20) order by name;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| Wilma  |
+--------+
> 
> -- wrong translation
> -- This should be the same as 1.3. Solve them together.
> explain plan without implementation for
> select name from emps where deptno not in (select deptno from depts);
+--------------------------------------------------------------+
|                           column0                            |
+--------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                        |
|   FilterRel(condition=[IS TRUE(true)])                       |
|     FilterRel(condition=[NOT(=($2, $10))])                   |
|       JoinRel(condition=[true], joinType=[inner])            |
|         TableAccessRel(table=[[LOCALDB, SALES, EMPS]])       |
|         AggregateRel(groupCount=[1])                         |
|           ProjectRel(DEPTNO=[$0])                            |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+--------------------------------------------------------------+
> 
> -- 1.3 uncorrelated NOT(x IN (sq)):
> -- incorrect translation (should be anti-semijoin)
> -- should be the same as (deptno not in (select deptno from depts));
> -- this needs to handle NULL semantics as well
> -- initial thinking is to translate that into not exists and use antijoin 
> -- with the value generator (with special semantics for NULL keys, they do not 
> -- belong to either matched or unmatched set)
> explain plan without implementation for
> select name from emps where not (deptno in (select deptno from depts));
+--------------------------------------------------------------+
|                           column0                            |
+--------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                        |
|   FilterRel(condition=[NOT(IS TRUE(true))])                  |
|     FilterRel(condition=[=($2, $10)])                        |
|       JoinRel(condition=[true], joinType=[inner])            |
|         TableAccessRel(table=[[LOCALDB, SALES, EMPS]])       |
|         AggregateRel(groupCount=[1])                         |
|           ProjectRel(DEPTNO=[$0])                            |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+--------------------------------------------------------------+
> 
> explain plan for
> select name from emps where not (deptno in (select deptno from depts));
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                               column0                                                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                            |
|   FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])  |
|     LhxJoinRel(leftKeys=[[0]], rightKeys=[[1]], joinType=[INNER])                                                                                                    |
|       LhxAggRel(groupCount=[1])                                                                                                                                      |
|         FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])               |
|       IteratorToFennelConverter                                                                                                                                      |
|         IterCalcRel(expr#0..1=[{inputs}], expr#2=[false], proj#0..1=[{exprs}], $condition=[$t2])                                                                     |
|           FennelToIteratorConverter                                                                                                                                  |
|             FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])                                            |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------+
> 
> -- 1.3 (WRONG RESULTS:  should have one row for employee John)
> select name from emps where not (deptno in (select deptno from depts)) order by name;
+-------+
| NAME  |
+-------+
+-------+
> 
> -- 1.4 correlated IN:
> -- correct translation. needs decorrelation
> explain plan without implementation for
> select name from emps where
> deptno in (select deptno from depts where emps.empid*10=depts.deptno);
+-----------------------------------------------------------------------------------------+
|                                         column0                                         |
+-----------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                                                   |
|   FilterRel(condition=[IS TRUE(true)])                                                  |
|     FilterRel(condition=[=($2, $10)])                                                   |
|       CorrelatorRel(condition=[true], joinType=[inner], correlations=[[var0=offset5]])  |
|         TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                  |
|         AggregateRel(groupCount=[1])                                                    |
|           ProjectRel(DEPTNO=[$0])                                                       |
|             FilterRel(condition=[=(*($cor0.EMPID, 10), $0)])                            |
|               TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                           |
+-----------------------------------------------------------------------------------------+
> 
> -- 1.4 is a special case of correlated exists. Equivalent to:
> explain plan without implementation for
> select name from emps where
> exists (select deptno from depts 
>         where emps.empid*10=depts.deptno and depts.deptno = emps.deptno);
+----------------------------------------------------------------------------------------------------+
|                                              column0                                               |
+----------------------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                                                              |
|   FilterRel(condition=[IS TRUE($11)])                                                              |
|     CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset5, var1=offset2]])  |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                               |
|       ProjectRel(DEPTNO=[$0], $indicator=[true])                                                   |
|         ProjectRel(DEPTNO=[$0])                                                                    |
|           FilterRel(condition=[AND(=(*($cor0.EMPID, 10), $0), =($0, $cor1.DEPTNO))])               |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                                        |
+----------------------------------------------------------------------------------------------------+
> 
> -- 2.1 uncorrelated exists:  incorrect translation produces too many rows
> -- (need to limit to at most one on join RHS; Broadbase inserts count(*))
> -- LucidDB uses a special aggregate function that generates the value TRUE for each group
> explain plan without implementation for
> select name from emps where exists(select * from depts);
+--------------------------------------------------------------+
|                           column0                            |
+--------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                        |
|   FilterRel(condition=[IS TRUE($12)])                        |
|     JoinRel(condition=[true], joinType=[left])               |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])         |
|       ProjectRel(DEPTNO=[$0], NAME=[$1], $indicator=[true])  |
|         ProjectRel(DEPTNO=[$0], NAME=[$1])                   |
|           TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])    |
+--------------------------------------------------------------+
> 
> explain plan for
> select name from emps where exists(select * from depts);
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                                               column0                                                                                                                |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                                                                                            |
|   FennelReshapeRel(projection=[[0]], filterOp=[COMP_EQ], filterOrdinals=[[1]], filterTuple=[[true]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])  |
|     FennelCartesianProductRel(leftouterjoin=[true])                                                                                                                                                                                  |
|       FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])                                                                                                                     |
|       IteratorToFennelConverter                                                                                                                                                                                                      |
|         IterCalcRel(expr#0=[{inputs}], expr#1=[true], $indicator=[$t1])                                                                                                                                                              |
|           FennelToIteratorConverter                                                                                                                                                                                                  |
|             FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])                                                                           |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
> 
> -- (WRONG RESULTS:  shoud not be filter over cross product)
> select name from emps where exists(select * from depts) order by name;
+--------+
|  NAME  |
+--------+
| Eric   |
| Eric   |
| Eric   |
| Fred   |
| Fred   |
| Fred   |
| John   |
| John   |
| John   |
| Wilma  |
| Wilma  |
| Wilma  |
+--------+
> 
> -- 2.2 correlated exists:  passes translation; needs decorrelation;
> explain plan without implementation for
> select name from emps
> where exists(select * from depts where depts.deptno=emps.deptno);
+--------------------------------------------------------------------------------------+
|                                       column0                                        |
+--------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                                                |
|   FilterRel(condition=[IS TRUE($12)])                                                |
|     CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2]])  |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                 |
|       ProjectRel(DEPTNO=[$0], NAME=[$1], $indicator=[true])                          |
|         ProjectRel(DEPTNO=[$0], NAME=[$1])                                           |
|           FilterRel(condition=[=($0, $cor0.DEPTNO)])                                 |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                          |
+--------------------------------------------------------------------------------------+
> 
> -- 3.1 uncorrelated scalar subquery:  passes most of translation
> explain plan without implementation for
> select name, (select count(*) from depts) from emps;
+------------------------------------------------------------+
|                          column0                           |
+------------------------------------------------------------+
| ProjectRel(NAME=[$1], EXPR$1=[$10])                        |
|   JoinRel(condition=[true], joinType=[left])               |
|     TableAccessRel(table=[[LOCALDB, SALES, EMPS]])         |
|     ProjectRel(EXPR$0=[$0])                                |
|       AggregateRel(groupCount=[0], agg#0=[COUNT()])        |
|         ProjectRel($f0=[true])                             |
|           TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+------------------------------------------------------------+
> 
> -- and even passes optimization
> explain plan for
> select name, (select count(*) from depts) from emps;
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                              column0                                                                              |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                         |
|   FennelRenameRel(fieldNames=[[NAME, EXPR$1]])                                                                                                                    |
|     FennelCartesianProductRel(leftouterjoin=[true])                                                                                                               |
|       FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])                                                  |
|       FennelBufferRel(inMemory=[false], multiPass=[true])                                                                                                         |
|         FennelRenameRel(fieldNames=[[EXPR$0]])                                                                                                                    |
|           FennelAggRel(groupCount=[0], agg#0=[COUNT()])                                                                                                           |
|             IteratorToFennelConverter                                                                                                                             |
|               IterCalcRel(expr#0=[{inputs}], expr#1=[true], $f0=[$t1])                                                                                            |
|                 FennelToIteratorConverter                                                                                                                         |
|                   FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])  |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
> 
> -- produces correct result only when null or one value is produced from the subquery.
> -- need to add AggSingleRel for other cases
> select name, (select count(*) from depts) from emps order by name;
+--------+---------+
|  NAME  | EXPR$1  |
+--------+---------+
| Eric   | 3       |
| Fred   | 3       |
| John   | 3       |
| Wilma  | 3       |
+--------+---------+
> 
> -- correct
> -- need to implement SingleValueAgg
> explain plan without implementation for
> select name, (select deptno from depts where deptno > 100) from emps order by name;
+--------------------------------------------------------------+
|                           column0                            |
+--------------------------------------------------------------+
| SortRel(sort0=[$0], dir0=[Ascending])                        |
|   ProjectRel(NAME=[$1], EXPR$1=[$10])                        |
|     JoinRel(condition=[true], joinType=[left])               |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])         |
|       AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)])  |
|         ProjectRel(DEPTNO=[$0])                              |
|           FilterRel(condition=[>($0, 100)])                  |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+--------------------------------------------------------------+
> 
> -- this should fail in validation
> -- explain plan without implementation for
> -- select name, (select * from depts) from emps;
> 
> -- check that scalar subquery type inference is correct
> create table s (a int);
> select empno, (select min(a) from s) from emps order by empno;
+--------+---------+
| EMPNO  | EXPR$1  |
+--------+---------+
| 100    |         |
| 110    |         |
| 110    |         |
| 120    |         |
+--------+---------+
> select empno, (select count(a) from s) from emps order by empno;
+--------+---------+
| EMPNO  | EXPR$1  |
+--------+---------+
| 100    | 0       |
| 110    | 0       |
| 110    | 0       |
| 120    | 0       |
+--------+---------+
> drop table s;
> 
> create table s (a int not null);
> select empno, (select min(a) from s) from emps order by empno;
+--------+---------+
| EMPNO  | EXPR$1  |
+--------+---------+
| 100    |         |
| 110    |         |
| 110    |         |
| 120    |         |
+--------+---------+
> select empno, (select count(a) from s) from emps order by empno;
+--------+---------+
| EMPNO  | EXPR$1  |
+--------+---------+
| 100    | 0       |
| 110    | 0       |
| 110    | 0       |
| 120    | 0       |
+--------+---------+
> drop table s;
> 
> -- 3.2 correlated scalar subquery in select list:  
> -- passes translation; needs decorrelation
> -- also needs to add AggSingleRel()
> explain plan without implementation for
> select name, (select name from depts where depts.deptno=emps.deptno)
> from emps;
+------------------------------------------------------------------------------------+
|                                      column0                                       |
+------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1], EXPR$1=[$10])                                                |
|   CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2]])  |
|     TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                 |
|     AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)])                          |
|       ProjectRel(NAME=[$1])                                                        |
|         FilterRel(condition=[=($0, $cor0.DEPTNO)])                                 |
|           TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                          |
+------------------------------------------------------------------------------------+
> 
> -- 3.3 non correlated in where clause
> -- parses now, need to add AggSingleRel
> -- note can also use semi join
> explain plan for 
> select * from emps
> where deptno = (select min(deptno) from depts);
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                            column0                                                                            |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| IterCalcRel(expr#0..10=[{inputs}], expr#11=[=($t2, $t10)], proj#0..9=[{exprs}], $condition=[$t11])                                                            |
|   FennelToIteratorConverter                                                                                                                                   |
|     FennelCartesianProductRel(leftouterjoin=[true])                                                                                                           |
|       FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])              |
|       FennelBufferRel(inMemory=[false], multiPass=[true])                                                                                                     |
|         FennelRenameRel(fieldNames=[[EXPR$0]])                                                                                                                |
|           FennelAggRel(groupCount=[0], agg#0=[MIN(0)])                                                                                                        |
|             FennelRenameRel(fieldNames=[[$f0]])                                                                                                               |
|               FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])  |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
> 
> -- result is correct simply because subquery produces only one value
> select * from emps
> where deptno = (select min(deptno) from depts) order by emps.empno;
+--------+-------+---------+---------+-------+--------+------+-------------+----------+----------+
| EMPNO  | NAME  | DEPTNO  | GENDER  | CITY  | EMPID  | AGE  | PUBLIC_KEY  | SLACKER  | MANAGER  |
+--------+-------+---------+---------+-------+--------+------+-------------+----------+----------+
| 100    | Fred  | 10      |         |       | 30     | 25   | 41626320    | true     | false    |
+--------+-------+---------+---------+-------+--------+------+-------------+----------+----------+
> 
> -- incorrect result
> -- need to implement SingleValueAgg
> -- note can also use semi join
> explain plan without implementation for
> select * from emps
> where deptno = (select deptno from depts);
+--------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                  column0                                                                   |
+--------------------------------------------------------------------------------------------------------------------------------------------+
| ProjectRel(EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], PUBLIC_KEY=[$7], SLACKER=[$8], MANAGER=[$9])  |
|   FilterRel(condition=[=($2, $10)])                                                                                                        |
|     JoinRel(condition=[true], joinType=[left])                                                                                             |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                                                                       |
|       AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)])                                                                                |
|         ProjectRel(DEPTNO=[$0])                                                                                                            |
|           TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                                                                                  |
+--------------------------------------------------------------------------------------------------------------------------------------------+
> 
> -- 3.4 correlated scalar subquery in where clause:
> -- 
> explain plan without implementation for
> select name
> from emps
> where name=(select name from depts where depts.deptno=emps.deptno);
+--------------------------------------------------------------------------------------+
|                                       column0                                        |
+--------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                                                |
|   FilterRel(condition=[=($1, $10)])                                                  |
|     CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2]])  |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                 |
|       AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)])                          |
|         ProjectRel(NAME=[$1])                                                        |
|           FilterRel(condition=[=($0, $cor0.DEPTNO)])                                 |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                          |
+--------------------------------------------------------------------------------------+
> 
> explain plan without implementation for
> select name
> from emps
> where name=(select max(name) from depts where depts.deptno=emps.deptno);
+--------------------------------------------------------------------------------------+
|                                       column0                                        |
+--------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                                                |
|   FilterRel(condition=[=($1, $10)])                                                  |
|     CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2]])  |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                 |
|       ProjectRel(EXPR$0=[$0])                                                        |
|         AggregateRel(groupCount=[0], agg#0=[MAX(0)])                                 |
|           ProjectRel($f0=[$1])                                                       |
|             FilterRel(condition=[=($0, $cor0.DEPTNO)])                               |
|               TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                        |
+--------------------------------------------------------------------------------------+
> 
> -- 3.5 scalar subquery as operand for an aggregation
> -- needs to implement SingleValueAgg
> explain plan without implementation for
> select name, min((select name from depts where depts.deptno=emps.deptno))
> from emps
> group by name;
+----------------------------------------------------------------------------------------+
|                                        column0                                         |
+----------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$0], EXPR$1=[$1])                                                     |
|   AggregateRel(groupCount=[1], agg#0=[MIN(1)])                                         |
|     ProjectRel($f0=[$1], $f1=[$10])                                                    |
|       CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2]])  |
|         TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                 |
|         AggregateRel(groupCount=[0], agg#0=[SINGLE_VALUE(0)])                          |
|           ProjectRel(NAME=[$1])                                                        |
|             FilterRel(condition=[=($0, $cor0.DEPTNO)])                                 |
|               TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                          |
+----------------------------------------------------------------------------------------+
> 
> -- 3.6 HAVING clause scalar subquery currently produces incorrect plan
> --     if HAVING clause references aggs. This is because HAVING clause is processed
> --     before agg. So the subqueries get transformed into joins too early.
> --     (Currently having clause is processed before agg processing because the way aggs
> --      are gathered -- via expression conversion).
> --     Ideally, aggs shoudl be gathered first,
> --     then AggRels are generated, followed by processing of HAVING clause.
> --
> explain plan without implementation for
> select name
> from emps
> group by name
> having min(emps.name)=(select max(name) from depts);
+------------------------------------------------------------------+
|                             column0                              |
+------------------------------------------------------------------+
| ProjectRel(NAME=[$0])                                            |
|   FilterRel(condition=[=($1, $10)])                              |
|     AggregateRel(groupCount=[1], agg#0=[MIN(0)])                 |
|       ProjectRel($f0=[$1])                                       |
|         JoinRel(condition=[true], joinType=[left])               |
|           TableAccessRel(table=[[LOCALDB, SALES, EMPS]])         |
|           ProjectRel(EXPR$0=[$0])                                |
|             AggregateRel(groupCount=[0], agg#0=[MAX(0)])         |
|               ProjectRel($f0=[$1])                               |
|                 TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+------------------------------------------------------------------+
> 
> -- work around is to rewrite the above query into this
> explain plan without implementation for
> select name
> from
> (select name, min(emps.name) min_name
>  from emps
>  group by name) v
> where v.min_name=(select max(name) from depts);
+--------------------------------------------------------------+
|                           column0                            |
+--------------------------------------------------------------+
| ProjectRel(NAME=[$0])                                        |
|   FilterRel(condition=[=($1, $2)])                           |
|     JoinRel(condition=[true], joinType=[left])               |
|       ProjectRel(NAME=[$0], MIN_NAME=[$1])                   |
|         AggregateRel(groupCount=[1], agg#0=[MIN(0)])         |
|           ProjectRel($f0=[$1])                               |
|             TableAccessRel(table=[[LOCALDB, SALES, EMPS]])   |
|       ProjectRel(EXPR$0=[$0])                                |
|         AggregateRel(groupCount=[0], agg#0=[MAX(0)])         |
|           ProjectRel($f0=[$1])                               |
|             TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])  |
+--------------------------------------------------------------+
> 
> -- 3.7 These two will report error for scalar subquery if its select list
> -- contains more than one field.
> 
> -- explain plan without implementation for
> -- select empno, (select min(empno), min(deptno) from emps)
> -- from emps;
> 
> -- explain plan without implementation for
> -- select empno
> -- from emps
> -- where empno = (select min(empno), min(deptno) from emps);
> 
> -- 4.1 nested correlations
> --
> create table depts2 (deptno integer, name varchar(20));
> 
> -- depts2 thinks that the correlation on emps.deptno comes from depts.deptno
> -- currently the correlation lookup(by name) can only see correlation coming from the 
> -- immediate outer relation. If emps.deptno is changed to emps.empno, an assert will
> -- fail in createJoin()
> -- also needs decorrelation
> explain plan without implementation for 
> select name 
> from emps 
> where exists(select * 
>              from depts 
>              where depts.deptno > emps.deptno or 
>                    exists (select *
>                            from depts2
>                            where depts.deptno = depts2.deptno 
>                                  and depts2.deptno = emps.deptno));
+------------------------------------------------------------------------------------------------------------------+
|                                                     column0                                                      |
+------------------------------------------------------------------------------------------------------------------+
| ProjectRel(NAME=[$1])                                                                                            |
|   FilterRel(condition=[IS TRUE($12)])                                                                            |
|     CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2, var2=offset2, var1=offset2]])  |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                                             |
|       ProjectRel(DEPTNO=[$0], NAME=[$1], $indicator=[true])                                                      |
|         ProjectRel(DEPTNO=[$0], NAME=[$1])                                                                       |
|           FilterRel(condition=[OR(>($0, $cor2.DEPTNO), IS TRUE($4))])                                            |
|             CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset0, var1=offset0]])        |
|               TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                                                    |
|               ProjectRel(DEPTNO=[$0], NAME=[$1], $indicator=[true])                                              |
|                 ProjectRel(DEPTNO=[$0], NAME=[$1])                                                               |
|                   FilterRel(condition=[AND(=($cor0.DEPTNO, $0), =($0, $cor1.DEPTNO))])                           |
|                     TableAccessRel(table=[[LOCALDB, SALES, DEPTS2]])                                             |
+------------------------------------------------------------------------------------------------------------------+
> 
> 
> -- 4.2 correlation in more than one child
> -- also has the same problem as 4.1 during createJoin if the correlation is on 
> -- emps.empno for depts2.
> --
> -- depts2 sees the left neighbor for correlation while it should search for it on the
> -- outer relation emps.
> explain plan without implementation for 
> select * from emps
> where exists (select * from (select * from depts where depts.deptno = emps.deptno) t,
>                             (select * from depts2 where depts2.deptno = emps.deptno) v);
+--------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                  column0                                                                   |
+--------------------------------------------------------------------------------------------------------------------------------------------+
| ProjectRel(EMPNO=[$0], NAME=[$1], DEPTNO=[$2], GENDER=[$3], CITY=[$4], EMPID=[$5], AGE=[$6], PUBLIC_KEY=[$7], SLACKER=[$8], MANAGER=[$9])  |
|   FilterRel(condition=[IS TRUE($14)])                                                                                                      |
|     CorrelatorRel(condition=[true], joinType=[left], correlations=[[var0=offset2, var1=offset2]])                                          |
|       TableAccessRel(table=[[LOCALDB, SALES, EMPS]])                                                                                       |
|       ProjectRel(DEPTNO=[$0], NAME=[$1], DEPTNO0=[$2], NAME0=[$3], $indicator=[true])                                                      |
|         ProjectRel(DEPTNO=[$0], NAME=[$1], DEPTNO0=[$2], NAME0=[$3])                                                                       |
|           CorrelatorRel(condition=[true], joinType=[inner], correlations=[[var1=offset0]])                                                 |
|             ProjectRel(DEPTNO=[$0], NAME=[$1])                                                                                             |
|               FilterRel(condition=[=($0, $cor0.DEPTNO)])                                                                                   |
|                 TableAccessRel(table=[[LOCALDB, SALES, DEPTS]])                                                                            |
|             ProjectRel(DEPTNO=[$0], NAME=[$1])                                                                                             |
|               FilterRel(condition=[=($0, $cor1.DEPTNO)])                                                                                   |
|                 TableAccessRel(table=[[LOCALDB, SALES, DEPTS2]])                                                                           |
+--------------------------------------------------------------------------------------------------------------------------------------------+
> 
> --------------
> -- clean up --
> --------------
> drop table depts2;
> 
> !quit
