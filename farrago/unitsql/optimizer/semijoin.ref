0: jdbc:farrago:> -- $Id: //open/lu/dev_lcs/farrago/unitsql/optimizer/semijoin.sql#23 $
0: jdbc:farrago:> -- Tests semijoin transformations
0: jdbc:farrago:> 
0: jdbc:farrago:> create schema sj;
0: jdbc:farrago:> set schema 'sj';
0: jdbc:farrago:> 
0: jdbc:farrago:> -- set session personality to LucidDB so all tables
0: jdbc:farrago:> -- will be column-store by default
0: jdbc:farrago:> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table t(
. . . . . . . . >     a int, b char(20), c varchar(20) not null,
. . . . . . . . >     d varchar(128) not null);
0: jdbc:farrago:> create index it_d on t(d);
0: jdbc:farrago:> create index it_bd on t(b, d);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into t values(1, 'abcdef', 'no match', 'this is row 1');
0: jdbc:farrago:> insert into t values(2, 'abcdef', 'ghijkl', 'this is row 2');
0: jdbc:farrago:> insert into t values(3, 'abcdef', 'ghijkl', 'this is row 3');
0: jdbc:farrago:> insert into t values(4, null, 'ghijkl', 'this is row 4');
0: jdbc:farrago:> insert into t values(5, null, 'ghijkl', 'no match');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- although this table has the same number of rows as t, we will force this
0: jdbc:farrago:> -- to be the dimension table in the semijoin by putting a dummy filter on
0: jdbc:farrago:> -- the table
0: jdbc:farrago:> 
0: jdbc:farrago:> create table smalltable(
. . . . . . . . >     s1 varchar(128) not null, s2 int, s3 varchar(128) not null,
. . . . . . . . >         s4 varchar(128) not null);
0: jdbc:farrago:> insert into smalltable values('this is row 1', 1, 'abcdef', 'ghijkl');
0: jdbc:farrago:> insert into smalltable values('this is row 2', 2, 'abcdef', 'ghijkl');
0: jdbc:farrago:> insert into smalltable values('this is row 3', 3, 'abcdef', 'ghijkl');
0: jdbc:farrago:> insert into smalltable values('this is row 4', 4, 'abcdef', 'ghijkl');
0: jdbc:farrago:> insert into smalltable values('this is row 5', 5, 'abcdef', 'ghijkl');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Create fake statistics.  The stats do not match the actual data in the
0: jdbc:farrago:> -- tables and are meant to force the optimizer to choose semijoins
0: jdbc:farrago:> 
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'T', 10000);
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'SMALLTABLE', 10);
0: jdbc:farrago:> 
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'T', 'B', 10, 100, 10, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'T', 'D', 10, 100, 10, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'SMALLTABLE', 'S1', 10, 100, 10, 1,
. . . . . . . . >     'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'SMALLTABLE', 'S3', 10, 100, 10, 1,
. . . . . . . . >     'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- explain plan tests
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> ----------------------
0: jdbc:farrago:> -- single column joins
0: jdbc:farrago:> ----------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.b = s.s3 and s.s1 = 'this is row 1' 
. . . . . . . . >     order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..9=[{inputs}], proj#0..3=[{exprs}], S1=[$t5], S2=[$t6], S3=[$t7], S4=[$t8])'
'      LhxJoinRel(leftKeys=[[4]], rightKeys=[[4]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..4=[{exprs}])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, T]], index=[IT_BD], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'this is row 1'], expr#3=[=($t0, $t2)], expr#4=[CAST($t1):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], S3=[$t4], $condition=[$t3])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'this is row 1'], expr#5=[=($t0, $t4)], expr#6=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..3=[{exprs}], S3=[$t6], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.d = s.s1 where s.s2 > 0 order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'        LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'          LcsIndexSearchRel(table=[[LOCALDB, SJ, T]], index=[IT_D], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelSortRel(key=[[0]], discardDuplicates=[true])'
'              FennelCalcRel(expr#0..1=[{inputs}], expr#2=[0], expr#3=[>($t1, $t2)], S1=[$t0], $condition=[$t3])'
'                LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2]])'
'      FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -----------------
0: jdbc:farrago:> -- negative cases
0: jdbc:farrago:> -----------------
0: jdbc:farrago:> -- no index available to process join
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.c = s.s4 where s.s2 > 0;
'column0'
'IterCalcRel(expr#0..8=[{inputs}], proj#0..3=[{exprs}], S1=[$t5], S2=[$t6], S3=[$t7], S4=[$t8])'
'  FennelToIteratorConverter'
'    LhxJoinRel(leftKeys=[[4]], rightKeys=[[3]], joinType=[INNER])'
'      FennelCalcRel(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], proj#0..4=[{exprs}])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'      FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- filter not of the form cola = colb
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.d = upper(s.s1) where s.s2 > 0;
'column0'
'IterCalcRel(expr#0..8=[{inputs}], proj#0..7=[{exprs}])'
'  FennelToIteratorConverter'
'    LhxJoinRel(leftKeys=[[3]], rightKeys=[[4]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'      FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], expr#6=[UPPER($t0)], proj#0..3=[{exprs}], UPPER($0)=[$t6], $condition=[$t5])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no filter on dimension table, so not worthwhile to do a semijoin
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.d = s.s1;
'column0'
'FennelToIteratorConverter'
'  LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[INNER])'
'    LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'    LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join
0: jdbc:farrago:> -- FIXME: Cartesian product is picked because join types do not match; however
0: jdbc:farrago:> -- cartesian product + outer join is not feasible.
0: jdbc:farrago:> -- explain plan for
0: jdbc:farrago:> -- select *
0: jdbc:farrago:> -- from t left outer join smalltable s
0: jdbc:farrago:> -- on t.b = s.s3 and s.s1 = 'this is row 1' 
0: jdbc:farrago:> -- order by a;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- this outer join uses HashJoin since join types match
0: jdbc:farrago:> explain plan for
. . . . . . . . > select *
. . . . . . . . > from t full outer join smalltable s
. . . . . . . . > on t.d = s.s1 where s.s2 > 0
. . . . . . . . > order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..7=[{inputs}], expr#8=[0], expr#9=[>($t5, $t8)], proj#0..7=[{exprs}], $condition=[$t9])'
'      LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[FULL])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . > from t full outer join smalltable s
. . . . . . . . > on t.d = s.s1 where s.s2 > 0
. . . . . . . . > order by a;
'A','B','C','D','S1','S2','S3','S4'
'','','','','this is row 5','5','abcdef','ghijkl'
'1','abcdef              ','no match','this is row 1','this is row 1','1','abcdef','ghijkl'
'2','abcdef              ','ghijkl','this is row 2','this is row 2','2','abcdef','ghijkl'
'3','abcdef              ','ghijkl','this is row 3','this is row 3','3','abcdef','ghijkl'
'4','','ghijkl','this is row 4','this is row 4','4','abcdef','ghijkl'
0: jdbc:farrago:> 
0: jdbc:farrago:> ---------------------
0: jdbc:farrago:> -- multi-column joins
0: jdbc:farrago:> ---------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.d = s.s1 and t.b = s.s3 where s.s2 > 0 order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..9=[{inputs}], proj#0..3=[{exprs}], S1=[$t5], S2=[$t6], S3=[$t7], S4=[$t8])'
'      LhxJoinRel(leftKeys=[[3, 4]], rightKeys=[[0, 4]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..4=[{exprs}])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, T]], index=[IT_BD], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0, 1]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..2=[{inputs}], expr#3=[0], expr#4=[>($t1, $t3)], expr#5=[CAST($t2):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], S3=[$t5], S1=[$t0], $condition=[$t4])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[[0, 1, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], expr#6=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..3=[{exprs}], S3=[$t6], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- same as above except join columns are reversed
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.b = s.s3 and s.s1 = t.d where s.s2 > 0 order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..9=[{inputs}], proj#0..3=[{exprs}], S1=[$t5], S2=[$t6], S3=[$t7], S4=[$t8])'
'      LhxJoinRel(leftKeys=[[3, 4]], rightKeys=[[0, 4]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..4=[{exprs}])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, T]], index=[IT_BD], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0, 1]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..2=[{inputs}], expr#3=[0], expr#4=[>($t1, $t3)], expr#5=[CAST($t2):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], S3=[$t5], S1=[$t0], $condition=[$t4])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[[0, 1, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], expr#6=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..3=[{exprs}], S3=[$t6], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- join on 3 columns but index only on 2 columns
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on s.s1 = t.d and s.s3 = t.b and t.c = s.s4 where s.s2 > 0
. . . . . . . . >     order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..10=[{inputs}], proj#0..3=[{exprs}], S1=[$t6], S2=[$t7], S3=[$t8], S4=[$t9])'
'      LhxJoinRel(leftKeys=[[3, 4, 5]], rightKeys=[[0, 4, 3]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#5=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], proj#0..5=[{exprs}])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, T]], index=[IT_BD], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0, 1]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..2=[{inputs}], expr#3=[0], expr#4=[>($t1, $t3)], expr#5=[CAST($t2):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], S3=[$t5], S1=[$t0], $condition=[$t4])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[[0, 1, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], expr#6=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..3=[{exprs}], S3=[$t6], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- same query but filters juggled around
0: jdbc:farrago:> explain plan for select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on s.s4 = t.c and s.s1 = t.d and s.s3 = t.b where s.s2 > 0
. . . . . . . . >     order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..10=[{inputs}], proj#0..3=[{exprs}], S1=[$t6], S2=[$t7], S3=[$t8], S4=[$t9])'
'      LhxJoinRel(leftKeys=[[3, 4, 5]], rightKeys=[[0, 3, 4]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], expr#5=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..5=[{exprs}])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$T$A, SYS$CLUSTERED_INDEX$SJ$T$B, SYS$CLUSTERED_INDEX$SJ$T$C, SYS$CLUSTERED_INDEX$SJ$T$D]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, T]], index=[IT_BD], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0, 1]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..2=[{inputs}], expr#3=[0], expr#4=[>($t1, $t3)], expr#5=[CAST($t2):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], S3=[$t5], S1=[$t0], $condition=[$t4])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[[0, 1, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[>($t1, $t4)], expr#6=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], proj#0..3=[{exprs}], S3=[$t6], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S2, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SJ$SMALLTABLE$S4]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> ---------------------------------------
0: jdbc:farrago:> -- run queries above that use semijoins
0: jdbc:farrago:> ---------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.b = s.s3 and s.s1 = 'this is row 1' order by a;
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| A  |           B           |     C     |       D        |       S1       | S2  |   S3    |   S4    |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| 1  | abcdef                | no match  | this is row 1  | this is row 1  | 1   | abcdef  | ghijkl  |
| 2  | abcdef                | ghijkl    | this is row 2  | this is row 1  | 1   | abcdef  | ghijkl  |
| 3  | abcdef                | ghijkl    | this is row 3  | this is row 1  | 1   | abcdef  | ghijkl  |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.d = s.s1 where s.s2 > 0 order by a;
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| A  |           B           |     C     |       D        |       S1       | S2  |   S3    |   S4    |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| 1  | abcdef                | no match  | this is row 1  | this is row 1  | 1   | abcdef  | ghijkl  |
| 2  | abcdef                | ghijkl    | this is row 2  | this is row 2  | 2   | abcdef  | ghijkl  |
| 3  | abcdef                | ghijkl    | this is row 3  | this is row 3  | 3   | abcdef  | ghijkl  |
| 4  |                       | ghijkl    | this is row 4  | this is row 4  | 4   | abcdef  | ghijkl  |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.d = s.s1 and t.b = s.s3 where s.s2 > 0 order by a;
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| A  |           B           |     C     |       D        |       S1       | S2  |   S3    |   S4    |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| 1  | abcdef                | no match  | this is row 1  | this is row 1  | 1   | abcdef  | ghijkl  |
| 2  | abcdef                | ghijkl    | this is row 2  | this is row 2  | 2   | abcdef  | ghijkl  |
| 3  | abcdef                | ghijkl    | this is row 3  | this is row 3  | 3   | abcdef  | ghijkl  |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on t.b = s.s3 and s.s1 = t.d where s.s2 > 0 order by a;
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| A  |           B           |     C     |       D        |       S1       | S2  |   S3    |   S4    |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
| 1  | abcdef                | no match  | this is row 1  | this is row 1  | 1   | abcdef  | ghijkl  |
| 2  | abcdef                | ghijkl    | this is row 2  | this is row 2  | 2   | abcdef  | ghijkl  |
| 3  | abcdef                | ghijkl    | this is row 3  | this is row 3  | 3   | abcdef  | ghijkl  |
+----+-----------------------+-----------+----------------+----------------+-----+---------+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on s.s1 = t.d and s.s3 = t.b and t.c = s.s4 where s.s2 > 0
. . . . . . . . >     order by a;
+----+-----------------------+---------+----------------+----------------+-----+---------+---------+
| A  |           B           |    C    |       D        |       S1       | S2  |   S3    |   S4    |
+----+-----------------------+---------+----------------+----------------+-----+---------+---------+
| 2  | abcdef                | ghijkl  | this is row 2  | this is row 2  | 2   | abcdef  | ghijkl  |
| 3  | abcdef                | ghijkl  | this is row 3  | this is row 3  | 3   | abcdef  | ghijkl  |
+----+-----------------------+---------+----------------+----------------+-----+---------+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . >     from t inner join smalltable s
. . . . . . . . >     on s.s4 = t.c and s.s1 = t.d and s.s3 = t.b where s.s2 > 0
. . . . . . . . >     order by a;
+----+-----------------------+---------+----------------+----------------+-----+---------+---------+
| A  |           B           |    C    |       D        |       S1       | S2  |   S3    |   S4    |
+----+-----------------------+---------+----------------+----------------+-----+---------+---------+
| 2  | abcdef                | ghijkl  | this is row 2  | this is row 2  | 2   | abcdef  | ghijkl  |
| 3  | abcdef                | ghijkl  | this is row 3  | this is row 3  | 3   | abcdef  | ghijkl  |
+----+-----------------------+---------+----------------+----------------+-----+---------+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------
0: jdbc:farrago:> -- n-way semijoins
0: jdbc:farrago:> ------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> create table sales(
. . . . . . . . >     sid int, product_id int, salesperson int, customer int, quantity int);
0: jdbc:farrago:> create index i_sales_pid on sales(product_id);
0: jdbc:farrago:> create index i_sales_sp on sales(salesperson);
0: jdbc:farrago:> create index i_sales_cust on sales(customer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table product(id int, name char(20), color char(10), size char(1));
0: jdbc:farrago:> create table salesperson(id int, name char(20), age int);
0: jdbc:farrago:> create table customer(id int, company char(20), city char(20));
0: jdbc:farrago:> create table state(city char(20), state char(20));
0: jdbc:farrago:> 
0: jdbc:farrago:> create index i_customer_city on customer(city);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into product values(1, 'radio', 'black', 'S');
0: jdbc:farrago:> insert into product values(2, 'phone', 'white', 'M');
0: jdbc:farrago:> insert into salesperson values(1, 'XYZ', 30);
0: jdbc:farrago:> insert into salesperson values(2, 'UVW', 40);
0: jdbc:farrago:> insert into customer values(1, 'ABC', 'San Mateo');
0: jdbc:farrago:> insert into customer values(2, 'DEF', 'New York City');
0: jdbc:farrago:> insert into state values('San Mateo', 'CA');
0: jdbc:farrago:> insert into state values('New York City', 'New York');
0: jdbc:farrago:> insert into sales values(1, 1, 1, 1, 10);
0: jdbc:farrago:> insert into sales values(2, 1, 1, 2, 20);
0: jdbc:farrago:> insert into sales values(3, 1, 2, 1, 30);
0: jdbc:farrago:> insert into sales values(4, 1, 2, 2, 40);
0: jdbc:farrago:> insert into sales values(5, 2, 1, 1, 50);
0: jdbc:farrago:> insert into sales values(6, 2, 1, 2, 60);
0: jdbc:farrago:> insert into sales values(7, 2, 2, 1, 70);
0: jdbc:farrago:> insert into sales values(8, 2, 2, 2, 80);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- more faking of stats; note also that the predicates chosen in the
0: jdbc:farrago:> -- actual queries aren't necessarily selective in reality but the stats
0: jdbc:farrago:> -- make the optimizer think they are
0: jdbc:farrago:> 
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'SALES', 100000);
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'PRODUCT', 20);
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'SALESPERSON', 10);
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'CUSTOMER', 100);
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'SJ', 'STATE', 5);
0: jdbc:farrago:> 
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'SALES', 'PRODUCT_ID', 20, 100, 20, 0, '0123456789');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'SALES', 'SALESPERSON', 10, 100, 10, 0, '0123456789');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'SALES', 'CUSTOMER', 100, 100, 100, 0, '0123456789');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'PRODUCT', 'ID', 20, 100, 20, 0, '0123456789');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'SALESPERSON', 'ID', 10, 100, 10, 0, '0123456789');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'CUSTOMER', 'ID', 100, 100, 100, 0, '0123456789');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'CUSTOMER', 'CITY', 5, 100, 5, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
0: jdbc:farrago:> call sys_boot.mgmt.stat_set_column_histogram(
. . . . . . . . >     'LOCALDB', 'SJ', 'STATE', 'CITY', 5, 100, 5, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >         from sales s, product p
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and p.size = 'S'
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..6=[{inputs}], SID=[$t0], NAME=[$t4], COLOR=[$t5], SIZE=[$t6], QUANTITY=[$t2])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'          LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'            LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'              FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'S'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                  LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'S'], expr#5=[=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- push semijoin past filter
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >         from product p, sales s
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and p.size = 'S' and sid > 2
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..6=[{inputs}], SID=[$t0], NAME=[$t4], COLOR=[$t5], SIZE=[$t6], QUANTITY=[$t2])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        FennelCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[>($t0, $t3)], proj#0..2=[{exprs}], $condition=[$t4])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'S'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'S'], expr#5=[=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- push semijoin past joins
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, sp.name, s.quantity
. . . . . . . . >         from sales s, product p, salesperson sp
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and
. . . . . . . . >             s.salesperson = sp.id and
. . . . . . . . >             p.size >= 'M' and sp.age >= 30
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..7=[{inputs}], SID=[$t0], NAME=[$t3], COLOR=[$t4], SIZE=[$t5], NAME0=[$t7], QUANTITY=[$t2])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        FennelCalcRel(expr#0..7=[{inputs}], SID=[$t0], SALESPERSON=[$t2], QUANTITY=[$t3], NAME=[$t5], COLOR=[$t6], SIZE=[$t7])'
'          LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 2, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SALESPERSON, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'              LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[3])'
'                LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[5])'
'                  LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_SP], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                    FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                      FennelCalcRel(expr#0..1=[{inputs}], expr#2=[30], expr#3=[>=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                        LcsRowScanRel(table=[[LOCALDB, SJ, SALESPERSON]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALESPERSON$AGE, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$ID]])'
'                LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[4])'
'                  LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                    FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                      FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'M'], expr#3=[>=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                        LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'            FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'M'], expr#5=[>=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'              LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        FennelCalcRel(expr#0..2=[{inputs}], expr#3=[30], expr#4=[>=($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SALESPERSON]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALESPERSON$AGE, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$ID, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$NAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, sp.name, c.company
. . . . . . . . >         from customer c, salesperson sp, product p, sales s
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and
. . . . . . . . >             s.salesperson = sp.id and 
. . . . . . . . >             s.customer = c.id and
. . . . . . . . >             p.size >= 'M' and sp.age >= 30 and c.city >= 'N'
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..7=[{inputs}], SID=[$t6], NAME=[$t1], COLOR=[$t2], SIZE=[$t3], NAME0=[$t4], COMPANY=[$t5])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[3]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'M'], expr#5=[>=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        FennelCalcRel(expr#0..5=[{inputs}], NAME=[$t1], COMPANY=[$t2], SID=[$t3], PRODUCT_ID=[$t4])'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[3]], joinType=[INNER])'
'            FennelCalcRel(expr#0..2=[{inputs}], expr#3=[30], expr#4=[>=($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])'
'              LcsRowScanRel(table=[[LOCALDB, SJ, SALESPERSON]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALESPERSON$AGE, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$ID, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$NAME]])'
'            FennelCalcRel(expr#0..5=[{inputs}], COMPANY=[$t1], SID=[$t2], PRODUCT_ID=[$t3], SALESPERSON=[$t4])'
'              LhxJoinRel(leftKeys=[[0]], rightKeys=[[3]], joinType=[INNER])'
'                LcsRowScanRel(table=[[LOCALDB, SJ, CUSTOMER]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$CUSTOMER$COMPANY, SYS$CLUSTERED_INDEX$SJ$CUSTOMER$ID]])'
'                  LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'                    LcsIndexSearchRel(table=[[LOCALDB, SJ, CUSTOMER]], index=[I_CUSTOMER_CITY], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'                      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', _ISO-8859-1'N', _ISO-8859-1'+', null }]])'
'                LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 2, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$CUSTOMER, SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$SALESPERSON, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'                  LcsIndexIntersectRel(startRidParamId=[3], rowLimitParamId=[4])'
'                    LcsIndexMergeRel(consumerSridParamId=[3], segmentLimitParamId=[4], ridLimitParamId=[6])'
'                      LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_SP], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                        FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                          FennelCalcRel(expr#0..1=[{inputs}], expr#2=[30], expr#3=[>=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                            LcsRowScanRel(table=[[LOCALDB, SJ, SALESPERSON]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALESPERSON$AGE, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$ID]])'
'                    LcsIndexMergeRel(consumerSridParamId=[3], segmentLimitParamId=[4], ridLimitParamId=[5])'
'                      LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                        FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                          FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'M'], expr#3=[>=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                            LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'                    LcsIndexMergeRel(consumerSridParamId=[3], segmentLimitParamId=[4], ridLimitParamId=[7])'
'                      LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_CUST], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                        FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                          FennelCalcRel(expr#0=[{inputs}], expr#1=[IS NOT NULL($t0)], ID=[$t0], $condition=[$t1])'
'                            LcsRowScanRel(table=[[LOCALDB, SJ, CUSTOMER]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$CUSTOMER$ID]])'
'                              LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'                                LcsIndexSearchRel(table=[[LOCALDB, SJ, CUSTOMER]], index=[I_CUSTOMER_CITY], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'                                  FennelValuesRel(tuples=[[{ _ISO-8859-1'[', _ISO-8859-1'N', _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- push semijoin past filter and join
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, sp.name, s.quantity
. . . . . . . . >         from product p, sales s, salesperson sp
. . . . . . . . >         where
. . . . . . . . >             s.sid < 3 and
. . . . . . . . >             s.product_id = p.id and
. . . . . . . . >             s.salesperson = sp.id and
. . . . . . . . >             p.size >= 'M' and sp.age >= 30
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..7=[{inputs}], SID=[$t5], NAME=[$t2], COLOR=[$t3], SIZE=[$t4], NAME0=[$t1], QUANTITY=[$t7])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[4]], joinType=[INNER])'
'        FennelCalcRel(expr#0..2=[{inputs}], expr#3=[30], expr#4=[>=($t2, $t3)], proj#0..1=[{exprs}], $condition=[$t4])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, SALESPERSON]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALESPERSON$AGE, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$ID, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$NAME]])'
'        FennelCalcRel(expr#0..7=[{inputs}], NAME=[$t1], COLOR=[$t2], SIZE=[$t3], SID=[$t4], SALESPERSON=[$t6], QUANTITY=[$t7])'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[1]], joinType=[INNER])'
'            FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'M'], expr#5=[>=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'              LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'            FennelCalcRel(expr#0..3=[{inputs}], expr#4=[3], expr#5=[<($t0, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'              LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 2, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SALESPERSON, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'                LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[3])'
'                  LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[5])'
'                    LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_SP], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                      FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                        FennelCalcRel(expr#0..1=[{inputs}], expr#2=[30], expr#3=[>=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                          LcsRowScanRel(table=[[LOCALDB, SJ, SALESPERSON]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALESPERSON$AGE, SYS$CLUSTERED_INDEX$SJ$SALESPERSON$ID]])'
'                  LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[4])'
'                    LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                      FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                        FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'M'], expr#3=[>=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- chained join
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, c.company, c.city, st.state
. . . . . . . . >         from sales s, state st, customer c
. . . . . . . . >         where
. . . . . . . . >             s.customer = c.id and
. . . . . . . . >             c.city = st.city and st.state = 'New York'
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..5=[{inputs}], SID=[$t0], COMPANY=[$t3], CITY=[$t4], STATE=[$t5])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$CUSTOMER, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'          LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[2])'
'            LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_CUST], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'              FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                FennelCalcRel(expr#0=[{inputs}], expr#1=[IS NOT NULL($t0)], ID=[$t0], $condition=[$t1])'
'                  LcsRowScanRel(table=[[LOCALDB, SJ, CUSTOMER]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$CUSTOMER$ID]])'
'                    LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'                      LcsIndexSearchRel(table=[[LOCALDB, SJ, CUSTOMER]], index=[I_CUSTOMER_CITY], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                        FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                          FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'New York'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], CITY=[$t0], $condition=[$t5])'
'                            LcsRowScanRel(table=[[LOCALDB, SJ, STATE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$STATE$CITY, SYS$CLUSTERED_INDEX$SJ$STATE$STATE]])'
'        FennelCalcRel(expr#0..4=[{inputs}], proj#0..2=[{exprs}], STATE=[$t4])'
'          LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, SJ, CUSTOMER]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$CUSTOMER$CITY, SYS$CLUSTERED_INDEX$SJ$CUSTOMER$COMPANY, SYS$CLUSTERED_INDEX$SJ$CUSTOMER$ID]])'
'              LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'                LcsIndexSearchRel(table=[[LOCALDB, SJ, CUSTOMER]], index=[I_CUSTOMER_CITY], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                  FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'New York'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], CITY=[$t0], $condition=[$t5])'
'                      LcsRowScanRel(table=[[LOCALDB, SJ, STATE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$STATE$CITY, SYS$CLUSTERED_INDEX$SJ$STATE$STATE]])'
'            FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'New York'], expr#3=[=($t1, $t2)], proj#0..1=[{exprs}], $condition=[$t3])'
'              LcsRowScanRel(table=[[LOCALDB, SJ, STATE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$STATE$CITY, SYS$CLUSTERED_INDEX$SJ$STATE$STATE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index can be used for both semijoins and table filtering
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >         from sales s, product p
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and p.size = 'S' and
. . . . . . . . >             s.salesperson > 0
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..6=[{inputs}], SID=[$t0], NAME=[$t4], COLOR=[$t5], SIZE=[$t6], QUANTITY=[$t2])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'          LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[3])'
'            LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[5])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_SP], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 0, _ISO-8859-1'+', null }]])'
'            LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[4])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'S'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'S'], expr#5=[=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >         from sales s, product p
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and p.size = 'S' and
. . . . . . . . >             s.salesperson = 1
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..6=[{inputs}], SID=[$t4], NAME=[$t1], COLOR=[$t2], SIZE=[$t3], QUANTITY=[$t6])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[1]], joinType=[INNER])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'S'], expr#5=[=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'          LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'            LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_SP], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'              FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]])'
'            LcsIndexMergeRel(consumerSridParamId=[1], segmentLimitParamId=[2], ridLimitParamId=[3])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'S'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >         from sales s, product p
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and p.size = 'S' and
. . . . . . . . >             s.salesperson > 0 and s.customer > 0
. . . . . . . . >         order by sid;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..6=[{inputs}], SID=[$t0], NAME=[$t4], COLOR=[$t5], SIZE=[$t6], QUANTITY=[$t2])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[0, 1, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'          LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'            LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[3])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_SP], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 0, _ISO-8859-1'+', null }]])'
'            LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[4])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_CUST], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 0, _ISO-8859-1'+', null }]])'
'            LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[5])'
'              LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_PID], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0]], discardDuplicates=[true])'
'                  FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'S'], expr#3=[=($t1, $t2)], expr#4=[IS NOT NULL($t0)], expr#5=[AND($t3, $t4)], ID=[$t0], $condition=[$t5])'
'                    LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[_ISO-8859-1'S'], expr#5=[=($t3, $t4)], proj#0..3=[{exprs}], $condition=[$t5])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$COLOR, SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$NAME, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- semijoin used for IN clause; customer column has 100 distinct values so
0: jdbc:farrago:> -- the semijoin should be worthwhile
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select * from sales where customer in
. . . . . . . . >         (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
'column0'
'IterCalcRel(expr#0..4=[{inputs}], proj#0..4=[{exprs}])'
'  FennelToIteratorConverter'
'    LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[LEFTSEMI])'
'      LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$CUSTOMER, SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY, SYS$CLUSTERED_INDEX$SJ$SALES$SALESPERSON, SYS$CLUSTERED_INDEX$SJ$SALES$SID]])'
'        LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'          LcsIndexSearchRel(table=[[LOCALDB, SJ, SALES]], index=[I_SALES_CUST], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelSortRel(key=[[0]], discardDuplicates=[true])'
'              FennelCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):INTEGER], ROW_VALUE=[$t1])'
'                LhxAggRel(groupCount=[1])'
'                  FennelValuesRel(tuples=[[{ 1 }, { 2 }, { 3 }, { 4 }, { 5 }, { 6 }, { 7 }, { 8 }, { 9 }, { 10 }, { 1 }, { 2 }, { 3 }, { 4 }, { 5 }, { 6 }, { 7 }, { 8 }, { 9 }, { 10 }]])'
'      FennelValuesRel(tuples=[[{ 1 }, { 2 }, { 3 }, { 4 }, { 5 }, { 6 }, { 7 }, { 8 }, { 9 }, { 10 }, { 1 }, { 2 }, { 3 }, { 4 }, { 5 }, { 6 }, { 7 }, { 8 }, { 9 }, { 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- semijoin that needs to be removed
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . >     select s.product_id from
. . . . . . . . >         (select sum(quantity), product_id from sales group by product_id) s,
. . . . . . . . >         product p
. . . . . . . . >         where
. . . . . . . . >             s.product_id = p.id and p.size = 'S'
. . . . . . . . >         order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], PRODUCT_ID=[$t0])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'        FennelCalcRel(expr#0..1=[{inputs}], PRODUCT_ID=[$t0])'
'          LhxAggRel(groupCount=[1], agg#0=[SUM(1)])'
'            FennelRenameRel(fieldNames=[[$f0, $f1]])'
'              LcsRowScanRel(table=[[LOCALDB, SJ, SALES]], projection=[[1, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$SALES$PRODUCT_ID, SYS$CLUSTERED_INDEX$SJ$SALES$QUANTITY]])'
'        FennelCalcRel(expr#0..1=[{inputs}], expr#2=[_ISO-8859-1'S'], expr#3=[=($t1, $t2)], ID=[$t0], $condition=[$t3])'
'          LcsRowScanRel(table=[[LOCALDB, SJ, PRODUCT]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$SJ$PRODUCT$ID, SYS$CLUSTERED_INDEX$SJ$PRODUCT$SIZE]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------
0: jdbc:farrago:> -- run the queries
0: jdbc:farrago:> ------------------
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >     from sales s, product p
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and p.size = 'S'
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  | QUANTITY  |
+------+-----------------------+-------------+-------+-----------+
| 1    | radio                 | black       | S     | 10        |
| 2    | radio                 | black       | S     | 20        |
| 3    | radio                 | black       | S     | 30        |
| 4    | radio                 | black       | S     | 40        |
+------+-----------------------+-------------+-------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >     from product p, sales s
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and p.size = 'S' and sid > 2
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  | QUANTITY  |
+------+-----------------------+-------------+-------+-----------+
| 3    | radio                 | black       | S     | 30        |
| 4    | radio                 | black       | S     | 40        |
+------+-----------------------+-------------+-------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, sp.name, s.quantity
. . . . . . . . >     from sales s, product p, salesperson sp
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and
. . . . . . . . >         s.salesperson = sp.id and
. . . . . . . . >         p.size >= 'M' and sp.age >= 30
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------------------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  |         NAME          | QUANTITY  |
+------+-----------------------+-------------+-------+-----------------------+-----------+
| 1    | radio                 | black       | S     | XYZ                   | 10        |
| 2    | radio                 | black       | S     | XYZ                   | 20        |
| 3    | radio                 | black       | S     | UVW                   | 30        |
| 4    | radio                 | black       | S     | UVW                   | 40        |
| 5    | phone                 | white       | M     | XYZ                   | 50        |
| 6    | phone                 | white       | M     | XYZ                   | 60        |
| 7    | phone                 | white       | M     | UVW                   | 70        |
| 8    | phone                 | white       | M     | UVW                   | 80        |
+------+-----------------------+-------------+-------+-----------------------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, sp.name, c.company
. . . . . . . . >     from customer c, salesperson sp, product p, sales s
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and
. . . . . . . . >         s.salesperson = sp.id and 
. . . . . . . . >         s.customer = c.id and
. . . . . . . . >         p.size >= 'M' and sp.age >= 30 and c.city >= 'N'
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------------------+-----------------------+
| SID  |         NAME          |    COLOR    | SIZE  |         NAME          |        COMPANY        |
+------+-----------------------+-------------+-------+-----------------------+-----------------------+
| 1    | radio                 | black       | S     | XYZ                   | ABC                   |
| 2    | radio                 | black       | S     | XYZ                   | DEF                   |
| 3    | radio                 | black       | S     | UVW                   | ABC                   |
| 4    | radio                 | black       | S     | UVW                   | DEF                   |
| 5    | phone                 | white       | M     | XYZ                   | ABC                   |
| 6    | phone                 | white       | M     | XYZ                   | DEF                   |
| 7    | phone                 | white       | M     | UVW                   | ABC                   |
| 8    | phone                 | white       | M     | UVW                   | DEF                   |
+------+-----------------------+-------------+-------+-----------------------+-----------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, sp.name, s.quantity
. . . . . . . . >     from product p, sales s, salesperson sp
. . . . . . . . >     where
. . . . . . . . >         s.sid < 3 and
. . . . . . . . >         s.product_id = p.id and
. . . . . . . . >         s.salesperson = sp.id and
. . . . . . . . >         p.size >= 'M' and sp.age >= 30
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------------------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  |         NAME          | QUANTITY  |
+------+-----------------------+-------------+-------+-----------------------+-----------+
| 1    | radio                 | black       | S     | XYZ                   | 10        |
| 2    | radio                 | black       | S     | XYZ                   | 20        |
+------+-----------------------+-------------+-------+-----------------------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, c.company, c.city, st.state
. . . . . . . . >     from sales s, state st, customer c
. . . . . . . . >     where
. . . . . . . . >         s.customer = c.id and
. . . . . . . . >         c.city = st.city and st.state = 'New York'
. . . . . . . . >         order by sid;
+------+-----------------------+-----------------------+-----------------------+
| SID  |        COMPANY        |         CITY          |         STATE         |
+------+-----------------------+-----------------------+-----------------------+
| 2    | DEF                   | New York City         | New York              |
| 4    | DEF                   | New York City         | New York              |
| 6    | DEF                   | New York City         | New York              |
| 8    | DEF                   | New York City         | New York              |
+------+-----------------------+-----------------------+-----------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >     from sales s, product p
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and p.size = 'S' and
. . . . . . . . >         s.salesperson > 0
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  | QUANTITY  |
+------+-----------------------+-------------+-------+-----------+
| 1    | radio                 | black       | S     | 10        |
| 2    | radio                 | black       | S     | 20        |
| 3    | radio                 | black       | S     | 30        |
| 4    | radio                 | black       | S     | 40        |
+------+-----------------------+-------------+-------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >     from sales s, product p
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and p.size = 'S' and
. . . . . . . . >         s.salesperson = 1
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  | QUANTITY  |
+------+-----------------------+-------------+-------+-----------+
| 1    | radio                 | black       | S     | 10        |
| 2    | radio                 | black       | S     | 20        |
+------+-----------------------+-------------+-------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select sid, p.name, p.color, p.size, s.quantity
. . . . . . . . >     from sales s, product p
. . . . . . . . >     where
. . . . . . . . >         s.product_id = p.id and p.size = 'S' and
. . . . . . . . >         s.salesperson > 0 and s.customer > 0
. . . . . . . . >     order by sid;
+------+-----------------------+-------------+-------+-----------+
| SID  |         NAME          |    COLOR    | SIZE  | QUANTITY  |
+------+-----------------------+-------------+-------+-----------+
| 1    | radio                 | black       | S     | 10        |
| 2    | radio                 | black       | S     | 20        |
| 3    | radio                 | black       | S     | 30        |
| 4    | radio                 | black       | S     | 40        |
+------+-----------------------+-------------+-------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from sales where customer in
. . . . . . . . >     (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
. . . . . . . . >     order by sid;
+------+-------------+--------------+-----------+-----------+
| SID  | PRODUCT_ID  | SALESPERSON  | CUSTOMER  | QUANTITY  |
+------+-------------+--------------+-----------+-----------+
| 1    | 1           | 1            | 1         | 10        |
| 2    | 1           | 1            | 2         | 20        |
| 3    | 1           | 2            | 1         | 30        |
| 4    | 1           | 2            | 2         | 40        |
| 5    | 2           | 1            | 1         | 50        |
| 6    | 2           | 1            | 2         | 60        |
| 7    | 2           | 2            | 1         | 70        |
| 8    | 2           | 2            | 2         | 80        |
+------+-------------+--------------+-----------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> !quit
