0: jdbc:farrago:> -----------------------------------
0: jdbc:farrago:> -- LucidDB Column Store SQL test --
0: jdbc:farrago:> -----------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> create schema lcs;
0: jdbc:farrago:> set schema 'lcs';
0: jdbc:farrago:> set path 'lcs';
0: jdbc:farrago:> 
0: jdbc:farrago:> -- set session personality to LucidDB so all tables
0: jdbc:farrago:> -- will be column-store by default
0: jdbc:farrago:> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> ---------------------------------
0: jdbc:farrago:> -- Part 1. Single Cluster test --
0: jdbc:farrago:> ---------------------------------
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 1.1 One cluster of a single column.
0: jdbc:farrago:> --
0: jdbc:farrago:> -- Without specifying the clustered index clause in create table, a default 
0: jdbc:farrago:> -- index will be created for each column.
0: jdbc:farrago:> -- Also, LCS tables do not require primary keys.
0: jdbc:farrago:> create table lcsemps(empno int);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify creation of system-defined clustered index
0: jdbc:farrago:> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+----------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |               INDEX_NAME               | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+----------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                        | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCS$LCSEMPS         | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$LCSEMPS$EMPNO  | 1     | 1                 | EMPNO        | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+----------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> -- verify that explain plan works
0: jdbc:farrago:> explain plan for insert into lcsemps values(10);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[10], expr#2=[CAST($t1):INTEGER], $f0=[$t2])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > insert into lcsemps select empno from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):INTEGER], $f0=[$t1])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert values works
0: jdbc:farrago:> insert into lcsemps values(10);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert select works
0: jdbc:farrago:> insert into lcsemps select empno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps order by empno;
+--------+
| EMPNO  |
+--------+
| 10     |
| 100    |
| 110    |
| 110    |
| 120    |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify truncate works
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps;
+--------+
| EMPNO  |
+--------+
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that cached insert plans work (Jira Issue LDB-4)
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lcsemps values(20);
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> insert into lcsemps values(20);
0: jdbc:farrago:> select * from lcsemps order by empno;
+--------+
| EMPNO  |
+--------+
| 20     |
+--------+
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- drop lcsemps
0: jdbc:farrago:> drop table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 1.2 One cluster of three columns.
0: jdbc:farrago:> --
0: jdbc:farrago:> -- Without specifying the clustered index clause in create table, a default 
0: jdbc:farrago:> -- index will be created for each column.
0: jdbc:farrago:> -- Also, LCS tables do not require primary keys.
0: jdbc:farrago:> create table lcsemps(empno int, name varchar(128), empid int) 
. . . . . . . . > create clustered index explicit_lcsemps_all on lcsemps(empno, name, empid);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify creation of system-defined clustered indices
0: jdbc:farrago:> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+---------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |           INDEX_NAME            | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+---------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                 | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCS$LCSEMPS  | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | EXPLICIT_LCSEMPS_ALL            | 1     | 1                 | EMPNO        | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | EXPLICIT_LCSEMPS_ALL            | 1     | 2                 | NAME         | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | EXPLICIT_LCSEMPS_ALL            | 1     | 3                 | EMPID        | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+---------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that explain plan works
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for insert into lcsemps values(10, 'Selma', 10000);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[10], expr#2=[_ISO-8859-1'Selma'], expr#3=[10000], expr#4=[CAST($t1):INTEGER], expr#5=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#6=[CAST($t3):INTEGER], $f0=[$t4], $f1=[$t5], $f2=[$t6])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > insert into lcsemps select empno, name, empid from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#5=[CAST($t2):INTEGER], $f0=[$t3], $f1=[$t4], $f2=[$t5])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1, 5]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert values works
0: jdbc:farrago:> insert into lcsemps values(10, 'Selma', 10000);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert select works
0: jdbc:farrago:> insert into lcsemps select empno, name, empid from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps order by empno, name;
+--------+--------+--------+
| EMPNO  |  NAME  | EMPID  |
+--------+--------+--------+
| 10     | Selma  | 10000  |
| 100    | Fred   | 30     |
| 110    | Eric   | 3      |
| 110    | John   | 2      |
| 120    | Wilma  | 1      |
+--------+--------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- test some projections
0: jdbc:farrago:> select empno, name, empid from lcsemps order by empno;
+--------+--------+--------+
| EMPNO  |  NAME  | EMPID  |
+--------+--------+--------+
| 10     | Selma  | 10000  |
| 100    | Fred   | 30     |
| 110    | Eric   | 3      |
| 110    | John   | 2      |
| 120    | Wilma  | 1      |
+--------+--------+--------+
0: jdbc:farrago:> select name from lcsemps order by name;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| John   |
| Selma  |
| Wilma  |
+--------+
0: jdbc:farrago:> select name, name from lcsemps order by name;
+--------+--------+
|  NAME  |  NAME  |
+--------+--------+
| Eric   | Eric   |
| Fred   | Fred   |
| John   | John   |
| Selma  | Selma  |
| Wilma  | Wilma  |
+--------+--------+
0: jdbc:farrago:> select empid, empno from lcsemps order by empno;
+--------+--------+
| EMPID  | EMPNO  |
+--------+--------+
| 10000  | 10     |
| 30     | 100    |
| 3      | 110    |
| 2      | 110    |
| 1      | 120    |
+--------+--------+
0: jdbc:farrago:> select name, empno, empid from lcsemps order by empno;
+--------+--------+--------+
|  NAME  | EMPNO  | EMPID  |
+--------+--------+--------+
| Selma  | 10     | 10000  |
| Fred   | 100    | 30     |
| Eric   | 110    | 3      |
| John   | 110    | 2      |
| Wilma  | 120    | 1      |
+--------+--------+--------+
0: jdbc:farrago:> select empno + empid as empno_plus_empid from lcsemps order by empno_plus_empid;
+-------------------+
| EMPNO_PLUS_EMPID  |
+-------------------+
| 112               |
| 113               |
| 121               |
| 130               |
| 10010             |
+-------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify truncate works
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps;
+--------+-------+--------+
| EMPNO  | NAME  | EMPID  |
+--------+-------+--------+
+--------+-------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- drop lcsemps
0: jdbc:farrago:> drop table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 1.3 One cluster of a single column.
0: jdbc:farrago:> --     Testing inserting NULLs and empty strings.
0: jdbc:farrago:> --
0: jdbc:farrago:> -- Without specifying the clustered index clause in create table, a default 
0: jdbc:farrago:> -- index will be created for each column.
0: jdbc:farrago:> -- Also, LCS tables do not require primary keys.
0: jdbc:farrago:> create table lcsemps(city varchar(20));
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify creation of system-defined clustered index
0: jdbc:farrago:> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+---------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |              INDEX_NAME               | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+---------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                       | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCS$LCSEMPS        | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$LCSEMPS$CITY  | 1     | 1                 | CITY         | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+---------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that explain plan works
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for insert into lcsemps values(NULL);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[null], expr#2=[CAST($t1):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t2])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> explain plan for insert into lcsemps values('');
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[_ISO-8859-1''], expr#2=[CAST($t1):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t2])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> explain plan for insert into lcsemps values('Pescadero');
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[_ISO-8859-1'Pescadero'], expr#2=[CAST($t1):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t2])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Plans with NULL in the populating stream
0: jdbc:farrago:> explain plan for 
. . . . . . . . > insert into lcsemps select city from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t1])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[4]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > insert into lcsemps select city from sales.emps where empno = 100;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[100], expr#3=[=($t0, $t2)], expr#4=[CAST($t1):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t4], $condition=[$t3])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 4]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Locate a NULL value from the source table.
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> select city from sales.emps where empno = 100;
+-------+
| CITY  |
+-------+
|       |
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert values works
0: jdbc:farrago:> insert into lcsemps values(NULL);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that executing the same exec stream also works
0: jdbc:farrago:> insert into lcsemps values(NULL);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert values works
0: jdbc:farrago:> insert into lcsemps values('');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert values works
0: jdbc:farrago:> insert into lcsemps values('Pescadero');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert select works
0: jdbc:farrago:> insert into lcsemps select city from sales.emps where empno = 100;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert select works
0: jdbc:farrago:> insert into lcsemps select city from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that executing the same exec stream also works
0: jdbc:farrago:> insert into lcsemps select city from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
|                |
|                |
|                |
|                |
| Pescadero      |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify truncate works
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps;
+-------+
| CITY  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- drop lcsemps
0: jdbc:farrago:> drop table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 1.4 Bug case
0: jdbc:farrago:> --
0: jdbc:farrago:> create table lcsemps(city varchar(20));
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lcsemps select city from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lcsemps select city from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- NOTE: 2005-12-06(rchen) this used to fail with:
0: jdbc:farrago:> -- java: SXMutex.cpp:144: bool fennel::SXMutex::tryUpgrade(): Assertion `!nExclusive' failed.
0: jdbc:farrago:> -- It's now fixed by allocating a brand new LcsClusterNodeWriter for every 
0: jdbc:farrago:> -- LcsClusterAppendExecStream::open()
0: jdbc:farrago:> insert into lcsemps values(NULL);
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
|                |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- issue the select again to make sure state is correctly reset when the
0: jdbc:farrago:> -- stream is re-executed
0: jdbc:farrago:> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
|                |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify truncate works
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps;
+-------+
| CITY  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 1.5 Bugcase
0: jdbc:farrago:> --
0: jdbc:farrago:> create table lcsemps(city varchar(20));
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lcsemps select city from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lcsemps select city from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify truncate works
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps;
+-------+
| CITY  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- NOTE: 2005-12-06(rchen) this used to fail with:
0: jdbc:farrago:> -- java: ../../fennel/cache/CacheMethodsImpl.h:299: void fennel::CacheImpl<PageT, VictimPolicyT>::discardPage:Assertion `page->nReferences == 1' failed.
0: jdbc:farrago:> -- It's now fixed by allocating a brand new LcsClusterNodeWriter for every LcsClusterAppendExecStream::open()
0: jdbc:farrago:> drop table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> --------------------------------
0: jdbc:farrago:> -- Part 2. Multi-cluster test --
0: jdbc:farrago:> --------------------------------
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 2.1 Two clusters of a single column each.
0: jdbc:farrago:> --
0: jdbc:farrago:> -- Without specifying the clustered index clause in create table, a default 
0: jdbc:farrago:> -- index will be created for each column.
0: jdbc:farrago:> -- Also, LCS tables do not require primary keys.
0: jdbc:farrago:> create table lcsemps(empno int, name varchar(128));
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify creation of system-defined clustered indices
0: jdbc:farrago:> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+----------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |               INDEX_NAME               | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+----------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                        | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCS$LCSEMPS         | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$LCSEMPS$EMPNO  | 1     | 1                 | EMPNO        | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$LCSEMPS$NAME   | 1     | 1                 | NAME         | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+----------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that explain plan works
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for insert into lcsemps values(10, 'Selma');
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[10], expr#2=[_ISO-8859-1'Selma'], expr#3=[CAST($t1):INTEGER], expr#4=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t3], $f1=[$t4])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > insert into lcsemps select empno, name from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t0):INTEGER], expr#3=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t2], $f1=[$t3])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert values works
0: jdbc:farrago:> insert into lcsemps values(10, 'Selma');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that insert select works
0: jdbc:farrago:> insert into lcsemps select empno, name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps order by empno, name;
+--------+--------+
| EMPNO  |  NAME  |
+--------+--------+
| 10     | Selma  |
| 100    | Fred   |
| 110    | Eric   |
| 110    | John   |
| 120    | Wilma  |
+--------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify truncate works
0: jdbc:farrago:> truncate table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lcsemps;
+--------+-------+
| EMPNO  | NAME  |
+--------+-------+
+--------+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- drop lcsemps
0: jdbc:farrago:> drop table lcsemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 2.2 Four clusters.
0: jdbc:farrago:> --
0: jdbc:farrago:> create table multicluster(
. . . . . . . . >     c0 int, c1 varchar(128), c2 int, c3 int, c4 int, c5 int, c6 varchar(128),
. . . . . . . . >     c7 int)
. . . . . . . . > create clustered index i_c0 on multicluster(c0)
. . . . . . . . > create clustered index i_c1_c2 on multicluster(c1, c2)
. . . . . . . . > create clustered index i_c3_c4_c5 on multicluster(c3, c4)
. . . . . . . . > create clustered index i_c6_c7_c8_c9 on multicluster(c5, c6, c7);
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for
. . . . . . . . > insert into multicluster values(1, 'am', 100, 50, -10, 1000, NULL, 0);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, MULTICLUSTER]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[1], expr#2=[_ISO-8859-1'am'], expr#3=[100], expr#4=[50], expr#5=[-10], expr#6=[1000], expr#7=[null], expr#8=[CAST($t7):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#9=[0], expr#10=[CAST($t1):INTEGER], expr#11=[CAST($t2):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#12=[CAST($t3):INTEGER], expr#13=[CAST($t4):INTEGER], expr#14=[CAST($t5):INTEGER], expr#15=[CAST($t6):INTEGER], expr#16=[CAST($t9):INTEGER], $f0=[$t10], $f1=[$t11], $f2=[$t12], $f3=[$t13], $f4=[$t14], $f5=[$t15], $f6=[$t8], $f7=[$t16])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from multicluster order by c0, c1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, MULTICLUSTER]], projection=[*], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into multicluster values(1, 'am', 100, 50, -10, 1000, NULL, 0);
0: jdbc:farrago:> insert into multicluster values(1, 'am', 100, 50, -10, 1000, NULL, 0);
0: jdbc:farrago:> insert into multicluster values(1, NULL, 101, 51, -11, 1001, NULL, 1);
0: jdbc:farrago:> insert into multicluster values(2, '',   102, 52, -12, 1002, NULL, 2);
0: jdbc:farrago:> 
0: jdbc:farrago:> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+-----+------+-----+
| C7  | C1  |  C4  | C0  |
+-----+-----+------+-----+
| 1   |     | -11  | 1   |
| 0   | am  | -10  | 1   |
| 0   | am  | -10  | 1   |
| 2   |     | -12  | 2   |
+-----+-----+------+-----+
0: jdbc:farrago:> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+-----+------+-----+
| C7  | C1  |  C4  | C0  |
+-----+-----+------+-----+
| 1   |     | -11  | 1   |
| 0   | am  | -10  | 1   |
| 0   | am  | -10  | 1   |
| 2   |     | -12  | 2   |
+-----+-----+------+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> select c3, c1, c1, c4, c7 from multicluster order by c1, c3;
+-----+-----+-----+------+-----+
| C3  | C1  | C1  |  C4  | C7  |
+-----+-----+-----+------+-----+
| 51  |     |     | -11  | 1   |
| 52  |     |     | -12  | 2   |
| 50  | am  | am  | -10  | 0   |
| 50  | am  | am  | -10  | 0   |
+-----+-----+-----+------+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from multicluster order by c0, c1;
+-----+-----+------+-----+------+-------+-----+-----+
| C0  | C1  |  C2  | C3  |  C4  |  C5   | C6  | C7  |
+-----+-----+------+-----+------+-------+-----+-----+
| 1   |     | 101  | 51  | -11  | 1001  |     | 1   |
| 1   | am  | 100  | 50  | -10  | 1000  |     | 0   |
| 1   | am  | 100  | 50  | -10  | 1000  |     | 0   |
| 2   |     | 102  | 52  | -12  | 1002  |     | 2   |
+-----+-----+------+-----+------+-------+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- A parser bug
0: jdbc:farrago:> -- This sometimes does not work:
0: jdbc:farrago:> -- !set outputformat csv
0: jdbc:farrago:> -- explain plan with implementation for
0: jdbc:farrago:> -- insert into multicluster select empno, name, 0, 10, 100, 1000, city, deptno from sales.emps;
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for insert into multicluster select empno, name, 0, 10, 100, 1000, city, deptno from sales.emps; 
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, MULTICLUSTER]])'
'    FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[10], expr#6=[100], expr#7=[1000], expr#8=[CAST($t0):INTEGER], expr#9=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#10=[CAST($t4):INTEGER], expr#11=[CAST($t5):INTEGER], expr#12=[CAST($t6):INTEGER], expr#13=[CAST($t7):INTEGER], expr#14=[CAST($t2):INTEGER], $f0=[$t8], $f1=[$t9], $f2=[$t10], $f3=[$t11], $f4=[$t12], $f5=[$t13], $f6=[$t3], $f7=[$t14])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1, 2, 4]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from multicluster order by c0, c1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, MULTICLUSTER]], projection=[*], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into multicluster select empno, name, 0, 10, 100, 1000, city, deptno from sales.emps; 
0: jdbc:farrago:> 
0: jdbc:farrago:> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+--------+------+------+
| C7  |   C1   |  C4  |  C0  |
+-----+--------+------+------+
| 1   |        | -11  | 1    |
| 0   | am     | -10  | 1    |
| 0   | am     | -10  | 1    |
| 2   |        | -12  | 2    |
| 10  | Fred   | 100  | 100  |
| 20  | Eric   | 100  | 110  |
| 40  | John   | 100  | 110  |
| 20  | Wilma  | 100  | 120  |
+-----+--------+------+------+
0: jdbc:farrago:> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+--------+------+------+
| C7  |   C1   |  C4  |  C0  |
+-----+--------+------+------+
| 1   |        | -11  | 1    |
| 0   | am     | -10  | 1    |
| 0   | am     | -10  | 1    |
| 2   |        | -12  | 2    |
| 10  | Fred   | 100  | 100  |
| 20  | Eric   | 100  | 110  |
| 40  | John   | 100  | 110  |
| 20  | Wilma  | 100  | 120  |
+-----+--------+------+------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select c3, c1, c1, c4, c7 from multicluster order by c1, c3;
+-----+--------+--------+------+-----+
| C3  |   C1   |   C1   |  C4  | C7  |
+-----+--------+--------+------+-----+
| 51  |        |        | -11  | 1   |
| 52  |        |        | -12  | 2   |
| 10  | Eric   | Eric   | 100  | 20  |
| 10  | Fred   | Fred   | 100  | 10  |
| 10  | John   | John   | 100  | 40  |
| 10  | Wilma  | Wilma  | 100  | 20  |
| 50  | am     | am     | -10  | 0   |
| 50  | am     | am     | -10  | 0   |
+-----+--------+--------+------+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from multicluster order by c0, c1;
+------+--------+------+-----+------+-------+----------------+-----+
|  C0  |   C1   |  C2  | C3  |  C4  |  C5   |       C6       | C7  |
+------+--------+------+-----+------+-------+----------------+-----+
| 1    |        | 101  | 51  | -11  | 1001  |                | 1   |
| 1    | am     | 100  | 50  | -10  | 1000  |                | 0   |
| 1    | am     | 100  | 50  | -10  | 1000  |                | 0   |
| 2    |        | 102  | 52  | -12  | 1002  |                | 2   |
| 100  | Fred   | 0    | 10  | 100  | 1000  |                | 10  |
| 110  | Eric   | 0    | 10  | 100  | 1000  | San Francisco  | 20  |
| 110  | John   | 0    | 10  | 100  | 1000  | Vancouver      | 40  |
| 120  | Wilma  | 0    | 10  | 100  | 1000  |                | 20  |
+------+--------+------+-----+------+-------+----------------+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> truncate table multicluster;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from multicluster;
+-----+-----+-----+-----+-----+-----+-----+-----+
| C0  | C1  | C2  | C3  | C4  | C5  | C6  | C7  |
+-----+-----+-----+-----+-----+-----+-----+-----+
+-----+-----+-----+-----+-----+-----+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table multicluster;
0: jdbc:farrago:> 
0: jdbc:farrago:> --
0: jdbc:farrago:> -- 2.3 Try a different source
0: jdbc:farrago:> --
0: jdbc:farrago:> create table threeclusters(c0 int, c1 varchar(128), c2 char(2));
0: jdbc:farrago:> 
0: jdbc:farrago:> create server flatfile_server
. . . . . . . . > foreign data wrapper sys_file_wrapper
. . . . . . . . > options (
. . . . . . . . >     with_header 'yes', 
. . . . . . . . >     file_extension '',
. . . . . . . . >     log_directory 'testlog');
0: jdbc:farrago:> 
0: jdbc:farrago:> create foreign table flatfile_table(
. . . . . . . . >     id int not null,
. . . . . . . . >     name varchar(50) not null,
. . . . . . . . >     extra_field char(1) not null)
. . . . . . . . > server flatfile_server
. . . . . . . . > options (filename 'unitsql/med/example.csv');
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for
. . . . . . . . > insert into threeclusters select * from flatfile_table;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, THREECLUSTERS]])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#5=[CAST($t2):CHAR(2) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t3], $f1=[$t4], $f2=[$t5])'
'        IterCalcRel(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER NOT NULL], expr#4=[CAST($t1):VARCHAR(50) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], expr#5=[CAST($t2):CHAR(1) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], ID=[$t3], NAME=[$t4], EXTRA_FIELD=[$t5])'
'          FennelToIteratorConverter'
'            FlatFileFennelRel(table=[[LOCALDB, LCS, FLATFILE_TABLE]])'
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into threeclusters select * from flatfile_table;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into threeclusters select * from flatfile_table;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from threeclusters order by c0, c1;
+------+------------------------------------------+-----+
|  C0  |                    C1                    | C2  |
+------+------------------------------------------+-----+
| 123  | "S,"                                     | F   |
| 123  | "S,"                                     | F   |
| 123  | Jonathan Ackerman                        | A   |
| 123  | Jonathan Ackerman                        | A   |
| 234  | Grady O'Neil                             | B   |
| 234  | Grady O'Neil                             | B   |
| 234  | Peter "peg leg", Jimmy & Samantha "Sam"  | G   |
| 234  | Peter "peg leg", Jimmy & Samantha "Sam"  | G   |
| 456  | Susan, Peter and Dave                    | C   |
| 456  | Susan, Peter and Dave                    | C   |
| 789  | Amelia "meals" Maurice                   | E   |
| 789  | Amelia "meals" Maurice                   | E   |
+------+------------------------------------------+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> truncate table threeclusters;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from threeclusters;
+-----+-----+-----+
| C0  | C1  | C2  |
+-----+-----+-----+
+-----+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table threeclusters;
0: jdbc:farrago:> drop table flatfile_table;
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------
0: jdbc:farrago:> -- Part 3. Cluster Projection test --
0: jdbc:farrago:> -------------------------------------
0: jdbc:farrago:> create table tencols(c0 int, c1 int, c2 int, c3 int, c4 int, c5 int, c6 int,
. . . . . . . . >                         c7 int, c8 int, c9 int)
. . . . . . . . > create clustered index i_c0 on tencols(c0)
. . . . . . . . > create clustered index i_c1_c2 on tencols(c1, c2)
. . . . . . . . > create clustered index i_c3_c4_c5 on tencols(c3, c4, c5)
. . . . . . . . > create clustered index i_c6_c7_c8_c9 on tencols(c6, c7, c8, c9);
0: jdbc:farrago:> create index i_c9 on tencols(c9);
0: jdbc:farrago:> insert into tencols values(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
0: jdbc:farrago:> insert into tencols values(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> -- should select all clusters
0: jdbc:farrago:> explain plan for select * from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[*], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> explain plan for select c4, c1, c8, c0 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[4, 1, 8, 0]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- should select only one cluster
0: jdbc:farrago:> explain plan for select c7, c9 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[7, 9]], clustered indexes=[[I_C6_C7_C8_C9]])'
0: jdbc:farrago:> explain plan for select c5, c4, c3 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[5, 4, 3]], clustered indexes=[[I_C3_C4_C5]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- should select two clusters
0: jdbc:farrago:> explain plan for select c0, c4, c5 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 4, 5]], clustered indexes=[[I_C0, I_C3_C4_C5]])'
0: jdbc:farrago:> explain plan for select c2, c6, c1, c9 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[2, 6, 1, 9]], clustered indexes=[[I_C1_C2, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- should select three clusters
0: jdbc:farrago:> explain plan for select c8, c7, c3, c6, c2 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[8, 7, 3, 6, 2]], clustered indexes=[[I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> explain plan for select c0, c1, c4, c5, c9 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1, 4, 5, 9]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- projection with filtering
0: jdbc:farrago:> explain plan for select c2, c4, c8, c0 from tencols
. . . . . . . . >     where c0 = 0 and c2 = 2 and c4 = 4 and c8 = 8;
'column0'
'IterCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[=($t0, $t4)], expr#6=[2], expr#7=[=($t1, $t6)], expr#8=[AND($t5, $t7)], expr#9=[4], expr#10=[=($t2, $t9)], expr#11=[AND($t8, $t10)], expr#12=[8], expr#13=[=($t3, $t12)], expr#14=[AND($t11, $t13)], C2=[$t1], C4=[$t2], C8=[$t3], C0=[$t0], $condition=[$t14])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 2, 4, 8]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> explain plan for select c7, c0, c5, c1 from tencols
. . . . . . . . >     where c1 + c5 = 6;
'column0'
'IterCalcRel(expr#0..3=[{inputs}], expr#4=[+($t1, $t2)], expr#5=[6], expr#6=[=($t4, $t5)], C7=[$t3], C0=[$t0], C5=[$t2], C1=[$t1], $condition=[$t6])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1, 5, 7]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> explain plan for select c0, c5, c7, c1 from tencols
. . . . . . . . >     where c0 + c2 = 2;
'column0'
'IterCalcRel(expr#0..4=[{inputs}], expr#5=[+($t0, $t2)], expr#6=[2], expr#7=[=($t5, $t6)], C0=[$t0], C5=[$t3], C7=[$t4], C1=[$t1], $condition=[$t7])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1, 2, 5, 7]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
0: jdbc:farrago:> explain plan for select c0 + c1 from tencols where c0 = 0;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[0], expr#3=[=($t0, $t2)], expr#4=[+($t0, $t1)], EXPR$0=[$t4], $condition=[$t3])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1]], clustered indexes=[[I_C0, I_C1_C2]])'
0: jdbc:farrago:> -- column referenced in filter is processed by the index scan so it should
0: jdbc:farrago:> -- not be projected
0: jdbc:farrago:> explain plan for select c0 from tencols where c9 = 9;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0]], clustered indexes=[[I_C0]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LCS, TENCOLS]], index=[I_C9], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 9, _ISO-8859-1']', 9 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> select c2, c8, c4, c0 from tencols
. . . . . . . . >     where c0 = 0 and c2 = 2 and c4 = 4 and c8 = 8;
+-----+-----+-----+-----+
| C2  | C8  | C4  | C0  |
+-----+-----+-----+-----+
| 2   | 8   | 4   | 0   |
+-----+-----+-----+-----+
0: jdbc:farrago:> select c7, c0, c5, c1 from tencols
. . . . . . . . >     where c1 + c5 = c6;
+-----+-----+-----+-----+
| C7  | C0  | C5  | C1  |
+-----+-----+-----+-----+
| 7   | 0   | 5   | 1   |
+-----+-----+-----+-----+
0: jdbc:farrago:> select c7, c0, c5, c1 from tencols
. . . . . . . . >     where c0 + c2 = 2;
+-----+-----+-----+-----+
| C7  | C0  | C5  | C1  |
+-----+-----+-----+-----+
| 7   | 0   | 5   | 1   |
+-----+-----+-----+-----+
0: jdbc:farrago:> select c0 + c1 from tencols where c0 = 0;
+---------+
| EXPR$0  |
+---------+
| 1       |
+---------+
0: jdbc:farrago:> select c0 from tencols where c9 = 9;
+-----+
| C0  |
+-----+
| 0   |
+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> truncate table tencols;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from tencols;
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| C0  | C1  | C2  | C3  | C4  | C5  | C6  | C7  | C8  | C9  |
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table tencols;
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------
0: jdbc:farrago:> -- Part 4. UDT test --
0: jdbc:farrago:> -------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> create type rectangle as (
. . . . . . . . >     width double default 2.0,
. . . . . . . . >     height double default 4.0
. . . . . . . . > ) final;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table rectangles(name varchar(128), r rectangle, id int not null);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify that three indexes are created (not four)
0: jdbc:farrago:> !indexes RECTANGLES
+------------+--------------+-------------+-------------+------------------+------------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |                INDEX_NAME                | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+------------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | RECTANGLES  | false       |                  |                                          | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | false       | LOCALDB          | SYS$DELETION_INDEX$LCS$RECTANGLES        | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$RECTANGLES$ID    | 1     | 1                 | ID           | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$RECTANGLES$NAME  | 1     | 1                 | NAME         | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCS$RECTANGLES$R     | 1     | 1                 | R            | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+------------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into rectangles values('Default', new rectangle(), 1);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- can't execute this because we don't support returning UDT instances
0: jdbc:farrago:> -- via JDBC yet; but at least explain plan below should work
0: jdbc:farrago:> -- select * from rectangles t;
0: jdbc:farrago:> 
0: jdbc:farrago:> select id from rectangles t;
+-----+
| ID  |
+-----+
| 1   |
+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> select t.r.width from rectangles t;
+--------+
| WIDTH  |
+--------+
| 2.0    |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select t.r.height, name from rectangles t;
+---------+----------+
| HEIGHT  |   NAME   |
+---------+----------+
| 4.0     | Default  |
+---------+----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > insert into rectangles values('Default', new rectangle(), 1);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, RECTANGLES]])'
'    FennelCalcRel(expr#0=[{inputs}], expr#1=[_ISO-8859-1'Default'], expr#2=[false], expr#3=[2.0], expr#4=[Reinterpret($t3)], expr#5=[CAST($t4):DOUBLE NOT NULL], expr#6=[1E1], expr#7=[/($t5, $t6)], expr#8=[CAST($t7):DOUBLE], expr#9=[4.0], expr#10=[Reinterpret($t9)], expr#11=[CAST($t10):DOUBLE NOT NULL], expr#12=[/($t11, $t6)], expr#13=[CAST($t12):DOUBLE], expr#14=[1], expr#15=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#16=[CAST($t2):BOOLEAN], $f0=[$t15], $f1=[$t16], $f1=[$t8], $f1=[$t13], $f2=[$t14])'
'      FennelValuesRel(tuples=[[{ 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from rectangles t;
'column0'
'IterCalcRel(expr#0..4=[{inputs}], expr#5=[IS NULL($t1)], expr#6=[null], expr#7=[CAST($t6):ObjectSqlType(LOCALDB.LCS.RECTANGLE)], expr#8=[NEW($t2, $t3):ObjectSqlType(LOCALDB.LCS.RECTANGLE)], expr#9=[CASE($t5, $t7, $t8)], NAME=[$t0], R=[$t9], ID=[$t4])'
'  FennelToIteratorConverter'
'    FennelRenameRel(fieldNames=[[NAME, R, R, R, ID]])'
'      LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[0, 1, 2, 3, 4]], clustered indexes=[[SYS$CLUSTERED_INDEX$LCS$RECTANGLES$ID, SYS$CLUSTERED_INDEX$LCS$RECTANGLES$NAME, SYS$CLUSTERED_INDEX$LCS$RECTANGLES$R]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select id from rectangles t;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[ID]])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[4]], clustered indexes=[[SYS$CLUSTERED_INDEX$LCS$RECTANGLES$ID]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select t.r.width from rectangles t;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[WIDTH]])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LCS$RECTANGLES$R]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select t.r.height, name from rectangles t;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[HEIGHT, NAME]])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[3, 0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LCS$RECTANGLES$NAME, SYS$CLUSTERED_INDEX$LCS$RECTANGLES$R]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> truncate table rectangles;
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(*) from rectangles;
+---------+
| EXPR$0  |
+---------+
| 0       |
+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table rectangles;
0: jdbc:farrago:> drop type rectangle;
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------
0: jdbc:farrago:> -- Part 5. Misc tests for bugfixes
0: jdbc:farrago:> -------------------------------------
0: jdbc:farrago:> -- Tests LER-312 -- should not create empty cluster pages when no data
0: jdbc:farrago:> -- is inserted into table
0: jdbc:farrago:> create table empty(a int);
0: jdbc:farrago:> create view v(a) as values(1);
0: jdbc:farrago:> insert into empty select a from v where a = 2;
0: jdbc:farrago:> select * from empty;
+----+
| A  |
+----+
+----+
0: jdbc:farrago:> drop view v;
0: jdbc:farrago:> drop table empty;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Tests LER-31 -- Not handling appends to existing table when the records
0: jdbc:farrago:> -- are variable length and stored in either a compressed of variable mode
0: jdbc:farrago:> -- batch.  Prior testcases do exercise this, but the column size isn't long
0: jdbc:farrago:> -- enough to cause attempts to read invalid memory.  Note that the "null"
0: jdbc:farrago:> -- is what causes the testcase below to result in there being enough variation
0: jdbc:farrago:> -- in the record sizes to cause problems.
0: jdbc:farrago:> 
0: jdbc:farrago:> create table test_large_chars (a int, i char(100));
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into test_large_chars values(1, null);
0: jdbc:farrago:> insert into test_large_chars values(2, 'asdf');
0: jdbc:farrago:> insert into test_large_chars values(3,
. . . . . . . . >     'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb');
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from test_large_chars;
+----+-------------------------------------------------------------------------------------------------------+
| A  |                                                   I                                                   |
+----+-------------------------------------------------------------------------------------------------------+
| 1  |                                                                                                       |
| 2  | asdf                                                                                                  |
| 3  | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                              |
+----+-------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> select * from test_large_chars where i is null;
+----+----+
| A  | I  |
+----+----+
| 1  |    |
+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table test_large_chars;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table test_large_varchars (a int, i varchar(100));
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into test_large_varchars values(1, null);
0: jdbc:farrago:> insert into test_large_varchars values(2, 'asdf');
0: jdbc:farrago:> insert into test_large_varchars values(3,
. . . . . . . . >     'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb');
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from test_large_varchars;
+----+---------------------------------------------------------------------------+
| A  |                                     I                                     |
+----+---------------------------------------------------------------------------+
| 1  |                                                                           |
| 2  | asdf                                                                      |
| 3  | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb  |
+----+---------------------------------------------------------------------------+
0: jdbc:farrago:> select * from test_large_varchars where i is null;
+----+----+
| A  | I  |
+----+----+
| 1  |    |
+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table test_large_varchars;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Clean up
0: jdbc:farrago:> 
0: jdbc:farrago:> alter session implementation set default;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- drop schema
0: jdbc:farrago:> drop schema lcs;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- End lcs.sql
0: jdbc:farrago:> 
0: jdbc:farrago:> !quit
