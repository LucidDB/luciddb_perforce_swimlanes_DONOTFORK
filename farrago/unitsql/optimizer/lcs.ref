> -----------------------------------
> -- LucidDB Column Store SQL test --
> -----------------------------------
> 
> create schema lcs;
> set schema 'lcs';
> set path 'lcs';
> 
> -- set session personality to LucidDB so all tables
> -- will be column-store by default
> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
> 
> 
> ---------------------------------
> -- Part 1. Single Cluster test --
> ---------------------------------
> --
> -- 1.1 One cluster of a single column.
> --
> -- Without specifying the clustered index clause in create table, a default 
> -- index will be created for each column.
> -- Also, LCS tables do not require primary keys.
> create table lcsemps(empno int);
> 
> -- verify creation of system-defined clustered index
> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |             INDEX_NAME             | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                    | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCSEMPS         | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCSEMPS$EMPNO  | 1     | 1                 | EMPNO        | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
> 
> !set outputformat csv
> -- verify that explain plan works
> explain plan for insert into lcsemps values(10);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(INTEGER EMPNO) NOT NULL])'
'      FennelRenameRel(fieldNames=[[EMPNO]])'
'        FennelValuesRel(tuples=[[{ 10 }]])'
> 
> explain plan for 
> insert into lcsemps select empno from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(INTEGER EMPNO) NOT NULL])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0]], index=[EMPS_UX], preserveOrder=[false])'
> !set outputformat table
> 
> -- verify that insert values works
> insert into lcsemps values(10);
> 
> -- verify that insert select works
> insert into lcsemps select empno from sales.emps;
> 
> select * from lcsemps order by empno;
+--------+
| EMPNO  |
+--------+
| 10     |
| 100    |
| 110    |
| 110    |
| 120    |
+--------+
> 
> -- verify truncate works
> truncate table lcsemps;
> 
> select * from lcsemps;
+--------+
| EMPNO  |
+--------+
+--------+
> 
> -- verify that cached insert plans work (Jira Issue LDB-4)
> 
> insert into lcsemps values(20);
> truncate table lcsemps;
> insert into lcsemps values(20);
> select * from lcsemps order by empno;
+--------+
| EMPNO  |
+--------+
| 20     |
+--------+
> truncate table lcsemps;
> 
> -- drop lcsemps
> drop table lcsemps;
> 
> 
> --
> -- 1.2 One cluster of three columns.
> --
> -- Without specifying the clustered index clause in create table, a default 
> -- index will be created for each column.
> -- Also, LCS tables do not require primary keys.
> create table lcsemps(empno int, name varchar(128), empid int) 
> create clustered index explicit_lcsemps_all on lcsemps(empno, name, empid);
> 
> -- verify creation of system-defined clustered indices
> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+-----------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |         INDEX_NAME          | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+-----------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                             | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCSEMPS  | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | EXPLICIT_LCSEMPS_ALL        | 1     | 1                 | EMPNO        | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | EXPLICIT_LCSEMPS_ALL        | 1     | 2                 | NAME         | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | EXPLICIT_LCSEMPS_ALL        | 1     | 3                 | EMPID        | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+-----------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
> 
> -- verify that explain plan works
> !set outputformat csv
> explain plan for insert into lcsemps values(10, 'Selma', 10000);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0, 1, 2]], outputRowType=[RecordType(INTEGER EMPNO, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME, INTEGER EMPID) NOT NULL])'
'      FennelRenameRel(fieldNames=[[EMPNO, NAME, EMPID]])'
'        FennelValuesRel(tuples=[[{ 10, 'Selma', 10000 }]])'
> 
> explain plan for 
> insert into lcsemps select empno, name, empid from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0, 1, 2]], outputRowType=[RecordType(INTEGER EMPNO, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME, INTEGER EMPID) NOT NULL])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1, 5]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> !set outputformat table
> 
> -- verify that insert values works
> insert into lcsemps values(10, 'Selma', 10000);
> 
> -- verify that insert select works
> insert into lcsemps select empno, name, empid from sales.emps;
> 
> select * from lcsemps order by empno, name;
+--------+--------+--------+
| EMPNO  |  NAME  | EMPID  |
+--------+--------+--------+
| 10     | Selma  | 10000  |
| 100    | Fred   | 30     |
| 110    | Eric   | 3      |
| 110    | John   | 2      |
| 120    | Wilma  | 1      |
+--------+--------+--------+
> 
> -- test some projections
> select empno, name, empid from lcsemps order by empno;
+--------+--------+--------+
| EMPNO  |  NAME  | EMPID  |
+--------+--------+--------+
| 10     | Selma  | 10000  |
| 100    | Fred   | 30     |
| 110    | Eric   | 3      |
| 110    | John   | 2      |
| 120    | Wilma  | 1      |
+--------+--------+--------+
> select name from lcsemps order by name;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| John   |
| Selma  |
| Wilma  |
+--------+
> select name, name from lcsemps order by name;
+--------+--------+
|  NAME  |  NAME  |
+--------+--------+
| Eric   | Eric   |
| Fred   | Fred   |
| John   | John   |
| Selma  | Selma  |
| Wilma  | Wilma  |
+--------+--------+
> select empid, empno from lcsemps order by empno;
+--------+--------+
| EMPID  | EMPNO  |
+--------+--------+
| 10000  | 10     |
| 30     | 100    |
| 3      | 110    |
| 2      | 110    |
| 1      | 120    |
+--------+--------+
> select name, empno, empid from lcsemps order by empno;
+--------+--------+--------+
|  NAME  | EMPNO  | EMPID  |
+--------+--------+--------+
| Selma  | 10     | 10000  |
| Fred   | 100    | 30     |
| Eric   | 110    | 3      |
| John   | 110    | 2      |
| Wilma  | 120    | 1      |
+--------+--------+--------+
> select empno + empid as empno_plus_empid from lcsemps order by empno_plus_empid;
+-------------------+
| EMPNO_PLUS_EMPID  |
+-------------------+
| 112               |
| 113               |
| 121               |
| 130               |
| 10010             |
+-------------------+
> 
> -- verify truncate works
> truncate table lcsemps;
> 
> select * from lcsemps;
+--------+-------+--------+
| EMPNO  | NAME  | EMPID  |
+--------+-------+--------+
+--------+-------+--------+
> 
> -- drop lcsemps
> drop table lcsemps;
> 
> 
> --
> -- 1.3 One cluster of a single column.
> --     Testing inserting NULLs and empty strings.
> --
> -- Without specifying the clustered index clause in create table, a default 
> -- index will be created for each column.
> -- Also, LCS tables do not require primary keys.
> create table lcsemps(city varchar(20));
> 
> -- verify creation of system-defined clustered index
> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+-----------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |            INDEX_NAME             | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+-----------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                   | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCSEMPS        | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCSEMPS$CITY  | 1     | 1                 | CITY         | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+-----------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
> 
> -- verify that explain plan works
> !set outputformat csv
> explain plan for insert into lcsemps values(NULL);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelRenameRel(fieldNames=[[CITY]])'
'      FennelValuesRel(tuples=[[{ null }]])'
> explain plan for insert into lcsemps values('');
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CITY) NOT NULL])'
'      FennelRenameRel(fieldNames=[[CITY]])'
'        FennelValuesRel(tuples=[[{ '' }]])'
> explain plan for insert into lcsemps values('Pescadero');
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CITY) NOT NULL])'
'      FennelRenameRel(fieldNames=[[CITY]])'
'        FennelValuesRel(tuples=[[{ 'Pescadero' }]])'
> 
> -- Plans with NULL in the populating stream
> explain plan for 
> insert into lcsemps select city from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CITY) NOT NULL])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[4]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for 
> insert into lcsemps select city from sales.emps where empno = 100;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[1]], filterOp=[COMP_EQ], filterOrdinals=[[0]], filterTuple=[[100]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CITY) NOT NULL])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 4]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> !set outputformat table
> 
> -- Locate a NULL value from the source table.
> !set outputformat table
> select city from sales.emps where empno = 100;
+-------+
| CITY  |
+-------+
|       |
+-------+
> 
> -- verify that insert values works
> insert into lcsemps values(NULL);
> 
> -- verify that executing the same exec stream also works
> insert into lcsemps values(NULL);
> 
> -- verify that insert values works
> insert into lcsemps values('');
> 
> -- verify that insert values works
> insert into lcsemps values('Pescadero');
> 
> -- verify that insert select works
> insert into lcsemps select city from sales.emps where empno = 100;
> 
> -- verify that insert select works
> insert into lcsemps select city from sales.emps;
> 
> -- verify that executing the same exec stream also works
> insert into lcsemps select city from sales.emps;
> 
> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
|                |
|                |
|                |
|                |
| Pescadero      |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
> 
> -- verify truncate works
> truncate table lcsemps;
> 
> select * from lcsemps;
+-------+
| CITY  |
+-------+
+-------+
> 
> -- drop lcsemps
> drop table lcsemps;
> 
> 
> --
> -- 1.4 Bug case
> --
> create table lcsemps(city varchar(20));
> 
> insert into lcsemps select city from sales.emps;
> 
> insert into lcsemps select city from sales.emps;
> 
> -- NOTE: 2005-12-06(rchen) this used to fail with:
> -- java: SXMutex.cpp:144: bool fennel::SXMutex::tryUpgrade(): Assertion `!nExclusive' failed.
> -- It's now fixed by allocating a brand new LcsClusterNodeWriter for every 
> -- LcsClusterAppendExecStream::open()
> insert into lcsemps values(NULL);
> 
> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
|                |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
> 
> -- issue the select again to make sure state is correctly reset when the
> -- stream is re-executed
> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
|                |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
> 
> -- verify truncate works
> truncate table lcsemps;
> 
> select * from lcsemps;
+-------+
| CITY  |
+-------+
+-------+
> 
> drop table lcsemps;
> 
> 
> --
> -- 1.5 Bugcase
> --
> create table lcsemps(city varchar(20));
> 
> insert into lcsemps select city from sales.emps;
> 
> insert into lcsemps select city from sales.emps;
> 
> select * from lcsemps order by city;
+----------------+
|      CITY      |
+----------------+
|                |
|                |
|                |
|                |
| San Francisco  |
| San Francisco  |
| Vancouver      |
| Vancouver      |
+----------------+
> 
> -- verify truncate works
> truncate table lcsemps;
> 
> select * from lcsemps;
+-------+
| CITY  |
+-------+
+-------+
> 
> -- NOTE: 2005-12-06(rchen) this used to fail with:
> -- java: ../../fennel/cache/CacheMethodsImpl.h:299: void fennel::CacheImpl<PageT, VictimPolicyT>::discardPage:Assertion `page->nReferences == 1' failed.
> -- It's now fixed by allocating a brand new LcsClusterNodeWriter for every LcsClusterAppendExecStream::open()
> drop table lcsemps;
> 
> 
> --------------------------------
> -- Part 2. Multi-cluster test --
> --------------------------------
> --
> -- 2.1 Two clusters of a single column each.
> --
> -- Without specifying the clustered index clause in create table, a default 
> -- index will be created for each column.
> -- Also, LCS tables do not require primary keys.
> create table lcsemps(empno int, name varchar(128));
> 
> -- verify creation of system-defined clustered indices
> !indexes LCSEMPS
+------------+--------------+-------------+-------------+------------------+------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |             INDEX_NAME             | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | LCSEMPS     | false       |                  |                                    | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | false       | LOCALDB          | SYS$DELETION_INDEX$LCSEMPS         | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCSEMPS$EMPNO  | 1     | 1                 | EMPNO        | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | LCSEMPS     | true        | LOCALDB          | SYS$CLUSTERED_INDEX$LCSEMPS$NAME   | 1     | 1                 | NAME         | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
> 
> -- verify that explain plan works
> !set outputformat csv
> explain plan for insert into lcsemps values(10, 'Selma');
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0, 1]], outputRowType=[RecordType(INTEGER EMPNO, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME) NOT NULL])'
'      FennelRenameRel(fieldNames=[[EMPNO, NAME]])'
'        FennelValuesRel(tuples=[[{ 10, 'Selma' }]])'
> 
> explain plan for 
> insert into lcsemps select empno, name from sales.emps;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, LCSEMPS]])'
'    FennelReshapeRel(projection=[[0, 1]], outputRowType=[RecordType(INTEGER EMPNO, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME) NOT NULL])'
'      FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1]], index=[EMPS_UX], preserveOrder=[false])'
> !set outputformat table
> 
> -- verify that insert values works
> insert into lcsemps values(10, 'Selma');
> 
> -- verify that insert select works
> insert into lcsemps select empno, name from sales.emps;
> 
> select * from lcsemps order by empno, name;
+--------+--------+
| EMPNO  |  NAME  |
+--------+--------+
| 10     | Selma  |
| 100    | Fred   |
| 110    | Eric   |
| 110    | John   |
| 120    | Wilma  |
+--------+--------+
> 
> -- verify truncate works
> truncate table lcsemps;
> 
> select * from lcsemps;
+--------+-------+
| EMPNO  | NAME  |
+--------+-------+
+--------+-------+
> 
> -- drop lcsemps
> drop table lcsemps;
> 
> 
> --
> -- 2.2 Four clusters.
> --
> create table multicluster(
>     c0 int, c1 varchar(128), c2 int, c3 int, c4 int, c5 int, c6 varchar(128),
>     c7 int)
> create clustered index i_c0 on multicluster(c0)
> create clustered index i_c1_c2 on multicluster(c1, c2)
> create clustered index i_c3_c4_c5 on multicluster(c3, c4)
> create clustered index i_c6_c7_c8_c9 on multicluster(c5, c6, c7);
> 
> !set outputformat csv
> explain plan for
> insert into multicluster values(1, 'am', 100, 50, -10, 1000, NULL, 0);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, MULTICLUSTER]])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3, 4, 5, 6, 7]], outputRowType=[RecordType(INTEGER C0, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" C1, INTEGER C2, INTEGER C3, INTEGER C4, INTEGER C5, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" C6, INTEGER C7) NOT NULL])'
'      FennelRenameRel(fieldNames=[[C0, C1, C2, C3, C4, C5, C6, C7]])'
'        FennelValuesRel(tuples=[[{ 1, 'am', 100, 50, -10, 1000, null, 0 }]])'
> 
> explain plan for
> select * from multicluster order by c0, c1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, MULTICLUSTER]], projection=[*], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> !set outputformat table
> 
> insert into multicluster values(1, 'am', 100, 50, -10, 1000, NULL, 0);
> insert into multicluster values(1, 'am', 100, 50, -10, 1000, NULL, 0);
> insert into multicluster values(1, NULL, 101, 51, -11, 1001, NULL, 1);
> insert into multicluster values(2, '',   102, 52, -12, 1002, NULL, 2);
> 
> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+-----+------+-----+
| C7  | C1  |  C4  | C0  |
+-----+-----+------+-----+
| 1   |     | -11  | 1   |
| 0   | am  | -10  | 1   |
| 0   | am  | -10  | 1   |
| 2   |     | -12  | 2   |
+-----+-----+------+-----+
> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+-----+------+-----+
| C7  | C1  |  C4  | C0  |
+-----+-----+------+-----+
| 1   |     | -11  | 1   |
| 0   | am  | -10  | 1   |
| 0   | am  | -10  | 1   |
| 2   |     | -12  | 2   |
+-----+-----+------+-----+
> 
> select c3, c1, c1, c4, c7 from multicluster order by c1, c3;
+-----+-----+-----+------+-----+
| C3  | C1  | C1  |  C4  | C7  |
+-----+-----+-----+------+-----+
| 51  |     |     | -11  | 1   |
| 52  |     |     | -12  | 2   |
| 50  | am  | am  | -10  | 0   |
| 50  | am  | am  | -10  | 0   |
+-----+-----+-----+------+-----+
> 
> select * from multicluster order by c0, c1;
+-----+-----+------+-----+------+-------+-----+-----+
| C0  | C1  |  C2  | C3  |  C4  |  C5   | C6  | C7  |
+-----+-----+------+-----+------+-------+-----+-----+
| 1   |     | 101  | 51  | -11  | 1001  |     | 1   |
| 1   | am  | 100  | 50  | -10  | 1000  |     | 0   |
| 1   | am  | 100  | 50  | -10  | 1000  |     | 0   |
| 2   |     | 102  | 52  | -12  | 1002  |     | 2   |
+-----+-----+------+-----+------+-------+-----+-----+
> 
> -- A parser bug
> -- This sometimes does not work:
> -- !set outputformat csv
> -- explain plan with implementation for
> -- insert into multicluster select empno, name, 0, 10, 100, 1000, city, deptno from sales.emps;
> !set outputformat csv
> explain plan for insert into multicluster select empno, name, 0, 10, 100, 1000, city, deptno from sales.emps; 
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, MULTICLUSTER]])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3, 4, 5, 6, 7]], outputRowType=[RecordType(INTEGER C0, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" C1, INTEGER C2, INTEGER C3, INTEGER C4, INTEGER C5, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" C6, INTEGER C7) NOT NULL])'
'      FennelRenameRel(fieldNames=[[C0, C1, C2, C3, C4, C5, C6, C7]])'
'        FennelCalcRel(expr#0..3=[{inputs}], expr#4=[0], expr#5=[10], expr#6=[100], expr#7=[1000], proj#0..1=[{exprs}], EXPR$2=[$t4], EXPR$3=[$t5], EXPR$4=[$t6], EXPR$5=[$t7], CITY=[$t3], DEPTNO=[$t2])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[0, 1, 2, 4]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for
> select * from multicluster order by c0, c1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, MULTICLUSTER]], projection=[*], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> !set outputformat table
> 
> insert into multicluster select empno, name, 0, 10, 100, 1000, city, deptno from sales.emps; 
> 
> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+--------+------+------+
| C7  |   C1   |  C4  |  C0  |
+-----+--------+------+------+
| 1   |        | -11  | 1    |
| 0   | am     | -10  | 1    |
| 0   | am     | -10  | 1    |
| 2   |        | -12  | 2    |
| 10  | Fred   | 100  | 100  |
| 20  | Eric   | 100  | 110  |
| 40  | John   | 100  | 110  |
| 20  | Wilma  | 100  | 120  |
+-----+--------+------+------+
> select c7, c1, c4, c0 from multicluster order by c0, c1;
+-----+--------+------+------+
| C7  |   C1   |  C4  |  C0  |
+-----+--------+------+------+
| 1   |        | -11  | 1    |
| 0   | am     | -10  | 1    |
| 0   | am     | -10  | 1    |
| 2   |        | -12  | 2    |
| 10  | Fred   | 100  | 100  |
| 20  | Eric   | 100  | 110  |
| 40  | John   | 100  | 110  |
| 20  | Wilma  | 100  | 120  |
+-----+--------+------+------+
> 
> select c3, c1, c1, c4, c7 from multicluster order by c1, c3;
+-----+--------+--------+------+-----+
| C3  |   C1   |   C1   |  C4  | C7  |
+-----+--------+--------+------+-----+
| 51  |        |        | -11  | 1   |
| 52  |        |        | -12  | 2   |
| 10  | Eric   | Eric   | 100  | 20  |
| 10  | Fred   | Fred   | 100  | 10  |
| 10  | John   | John   | 100  | 40  |
| 10  | Wilma  | Wilma  | 100  | 20  |
| 50  | am     | am     | -10  | 0   |
| 50  | am     | am     | -10  | 0   |
+-----+--------+--------+------+-----+
> 
> select * from multicluster order by c0, c1;
+------+--------+------+-----+------+-------+----------------+-----+
|  C0  |   C1   |  C2  | C3  |  C4  |  C5   |       C6       | C7  |
+------+--------+------+-----+------+-------+----------------+-----+
| 1    |        | 101  | 51  | -11  | 1001  |                | 1   |
| 1    | am     | 100  | 50  | -10  | 1000  |                | 0   |
| 1    | am     | 100  | 50  | -10  | 1000  |                | 0   |
| 2    |        | 102  | 52  | -12  | 1002  |                | 2   |
| 100  | Fred   | 0    | 10  | 100  | 1000  |                | 10  |
| 110  | Eric   | 0    | 10  | 100  | 1000  | San Francisco  | 20  |
| 110  | John   | 0    | 10  | 100  | 1000  | Vancouver      | 40  |
| 120  | Wilma  | 0    | 10  | 100  | 1000  |                | 20  |
+------+--------+------+-----+------+-------+----------------+-----+
> 
> truncate table multicluster;
> 
> select * from multicluster;
+-----+-----+-----+-----+-----+-----+-----+-----+
| C0  | C1  | C2  | C3  | C4  | C5  | C6  | C7  |
+-----+-----+-----+-----+-----+-----+-----+-----+
+-----+-----+-----+-----+-----+-----+-----+-----+
> 
> drop table multicluster;
> 
> --
> -- 2.3 Try a different source
> --
> create table threeclusters(c0 int, c1 varchar(128), c2 char(2));
> 
> create server flatfile_server
> foreign data wrapper sys_file_wrapper
> options (
>     with_header 'yes', 
>     file_extension '',
>     log_directory 'testlog');
> 
> create foreign table flatfile_table(
>     id int not null,
>     name varchar(50) not null,
>     extra_field char(1) not null)
> server flatfile_server
> options (filename 'unitsql/med/example.csv');
> 
> !set outputformat csv
> explain plan for
> insert into threeclusters select * from flatfile_table;
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, THREECLUSTERS]])'
'    FennelCalcRel(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER], expr#4=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#5=[CAST($t2):CHAR(2) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], C0=[$t3], C1=[$t4], C2=[$t5])'
'      FennelRenameRel(fieldNames=[[C0, C1, C2]])'
'        FennelCalcRel(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER NOT NULL], expr#4=[CAST($t1):VARCHAR(50) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], expr#5=[CAST($t2):CHAR(1) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], ID=[$t3], NAME=[$t4], EXTRA_FIELD=[$t5])'
'          FlatFileFennelRel(table=[[LOCALDB, LCS, FLATFILE_TABLE]])'
> !set outputformat table
> 
> insert into threeclusters select * from flatfile_table;
> 
> insert into threeclusters select * from flatfile_table;
> 
> select * from threeclusters order by c0, c1;
+------+------------------------------------------+-----+
|  C0  |                    C1                    | C2  |
+------+------------------------------------------+-----+
| 123  | "S,"                                     | F   |
| 123  | "S,"                                     | F   |
| 123  | Jonathan Ackerman                        | A   |
| 123  | Jonathan Ackerman                        | A   |
| 234  | Grady O'Neil                             | B   |
| 234  | Grady O'Neil                             | B   |
| 234  | Peter "peg leg", Jimmy & Samantha "Sam"  | G   |
| 234  | Peter "peg leg", Jimmy & Samantha "Sam"  | G   |
| 456  | Susan, Peter and Dave                    | C   |
| 456  | Susan, Peter and Dave                    | C   |
| 789  | Amelia "meals" Maurice                   | E   |
| 789  | Amelia "meals" Maurice                   | E   |
+------+------------------------------------------+-----+
> 
> truncate table threeclusters;
> 
> select * from threeclusters;
+-----+-----+-----+
| C0  | C1  | C2  |
+-----+-----+-----+
+-----+-----+-----+
> 
> drop table threeclusters;
> drop table flatfile_table;
> 
> -------------------------------------
> -- Part 3. Cluster Projection test --
> -------------------------------------
> create table tencols(c0 int, c1 int, c2 int, c3 int, c4 int, c5 int, c6 int,
>                         c7 int, c8 int, c9 int)
> create clustered index i_c0 on tencols(c0)
> create clustered index i_c1_c2 on tencols(c1, c2)
> create clustered index i_c3_c4_c5 on tencols(c3, c4, c5)
> create clustered index i_c6_c7_c8_c9 on tencols(c6, c7, c8, c9);
> create index i_c9 on tencols(c9);
> insert into tencols values(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
> insert into tencols values(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
> 
> -- fake row count so that index access is considered
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LCS', 'TENCOLS', 100);
> 
> !set outputformat csv
> -- should select all clusters
> explain plan for select * from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[*], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> explain plan for select c4, c1, c8, c0 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[4, 1, 8, 0]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> 
> -- should select only one cluster
> explain plan for select c7, c9 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[7, 9]], clustered indexes=[[I_C6_C7_C8_C9]])'
> explain plan for select c5, c4, c3 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[5, 4, 3]], clustered indexes=[[I_C3_C4_C5]])'
> 
> -- should select two clusters
> explain plan for select c0, c4, c5 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 4, 5]], clustered indexes=[[I_C0, I_C3_C4_C5]])'
> explain plan for select c2, c6, c1, c9 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[2, 6, 1, 9]], clustered indexes=[[I_C1_C2, I_C6_C7_C8_C9]])'
> 
> -- should select three clusters
> explain plan for select c8, c7, c3, c6, c2 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[8, 7, 3, 6, 2]], clustered indexes=[[I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> explain plan for select c0, c1, c4, c5, c9 from tencols;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1, 4, 5, 9]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> 
> -- projection with filtering
> explain plan for select c2, c4, c8, c0 from tencols
>     where c0 = 0 and c2 = 2 and c4 = 4 and c8 = 8;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[2, 4, 8, 0]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]], residual columns=[[0, 2, 4, 8]])'
'    FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
'    FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
'    FennelValuesRel(tuples=[[{ '[', 4, ']', 4 }]])'
'    FennelValuesRel(tuples=[[{ '[', 8, ']', 8 }]])'
> explain plan for select c7, c0, c5, c1 from tencols
>     where c1 + c5 = 6;
'column0'
'IterCalcRel(expr#0..3=[{inputs}], expr#4=[+($t1, $t2)], expr#5=[6], expr#6=[=($t4, $t5)], C7=[$t3], C0=[$t0], C5=[$t2], C1=[$t1], $condition=[$t6])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1, 5, 7]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> explain plan for select c0, c5, c7, c1 from tencols
>     where c0 + c2 = 2;
'column0'
'IterCalcRel(expr#0..4=[{inputs}], expr#5=[+($t0, $t2)], expr#6=[2], expr#7=[=($t5, $t6)], C0=[$t0], C5=[$t3], C7=[$t4], C1=[$t1], $condition=[$t7])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1, 2, 5, 7]], clustered indexes=[[I_C0, I_C1_C2, I_C3_C4_C5, I_C6_C7_C8_C9]])'
> explain plan for select c0 + c1 from tencols where c0 = 0;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[+($t0, $t1)], EXPR$0=[$t2])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0, 1]], clustered indexes=[[I_C0, I_C1_C2]], residual columns=[[0]])'
'      FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
> -- column referenced in filter is processed by the index scan so it should
> -- not be projected
> explain plan for select c0 from tencols where c9 = 9;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LCS, TENCOLS]], projection=[[0]], clustered indexes=[[I_C0]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LCS, TENCOLS]], index=[I_C9], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ '[', 9, ']', 9 }]])'
> 
> !set outputformat table
> 
> select c2, c8, c4, c0 from tencols
>     where c0 = 0 and c2 = 2 and c4 = 4 and c8 = 8;
+-----+-----+-----+-----+
| C2  | C8  | C4  | C0  |
+-----+-----+-----+-----+
| 2   | 8   | 4   | 0   |
+-----+-----+-----+-----+
> select c7, c0, c5, c1 from tencols
>     where c1 + c5 = c6;
+-----+-----+-----+-----+
| C7  | C0  | C5  | C1  |
+-----+-----+-----+-----+
| 7   | 0   | 5   | 1   |
+-----+-----+-----+-----+
> select c7, c0, c5, c1 from tencols
>     where c0 + c2 = 2;
+-----+-----+-----+-----+
| C7  | C0  | C5  | C1  |
+-----+-----+-----+-----+
| 7   | 0   | 5   | 1   |
+-----+-----+-----+-----+
> select c0 + c1 from tencols where c0 = 0;
+---------+
| EXPR$0  |
+---------+
| 1       |
+---------+
> select c0 from tencols where c9 = 9;
+-----+
| C0  |
+-----+
| 0   |
+-----+
> 
> truncate table tencols;
> 
> select * from tencols;
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| C0  | C1  | C2  | C3  | C4  | C5  | C6  | C7  | C8  | C9  |
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
> 
> drop table tencols;
> 
> -------------------------------------
> -- Part 4. UDT test --
> -------------------------------------
> 
> create type rectangle as (
>     width double default 2.0,
>     height double default 4.0
> ) final;
> 
> create table rectangles(name varchar(128), r rectangle, id int not null);
> 
> -- verify that three indexes are created (not four)
> !indexes RECTANGLES
+------------+--------------+-------------+-------------+------------------+--------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| TABLE_CAT  | TABLE_SCHEM  | TABLE_NAME  | NON_UNIQUE  | INDEX_QUALIFIER  |              INDEX_NAME              | TYPE  | ORDINAL_POSITION  | COLUMN_NAME  | ASC_ORD_DESC  | CARDINALITY  | PAGES  | FILTER_CONDITION  |
+------------+--------------+-------------+-------------+------------------+--------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
| LOCALDB    | LCS          | RECTANGLES  | false       |                  |                                      | 0     | 0                 |              |               | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | false       | LOCALDB          | SYS$DELETION_INDEX$RECTANGLES        | 3     |                   |              | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | true        | LOCALDB          | SYS$CLUSTERED_INDEX$RECTANGLES$ID    | 1     | 1                 | ID           | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | true        | LOCALDB          | SYS$CLUSTERED_INDEX$RECTANGLES$NAME  | 1     | 1                 | NAME         | A             | 0            | 0      |                   |
| LOCALDB    | LCS          | RECTANGLES  | true        | LOCALDB          | SYS$CLUSTERED_INDEX$RECTANGLES$R     | 1     | 1                 | R            | A             | 0            | 0      |                   |
+------------+--------------+-------------+-------------+------------------+--------------------------------------+-------+-------------------+--------------+---------------+--------------+--------+-------------------+
> 
> insert into rectangles values('Default', new rectangle(), 1);
> 
> -- can't execute this because we don't support returning UDT instances
> -- via JDBC yet; but at least explain plan below should work
> -- select * from rectangles t;
> 
> select id from rectangles t;
+-----+
| ID  |
+-----+
| 1   |
+-----+
> 
> select t.r.width from rectangles t;
+--------+
| WIDTH  |
+--------+
| 2.0    |
+--------+
> 
> select t.r.height, name from rectangles t;
+---------+----------+
| HEIGHT  |   NAME   |
+---------+----------+
| 4.0     | Default  |
+---------+----------+
> 
> !set outputformat csv
> 
> explain plan for
> insert into rectangles values('Default', new rectangle(), 1);
'column0'
'FennelToIteratorConverter'
'  LcsTableAppendRel(table=[[LOCALDB, LCS, RECTANGLES]])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3, 4]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME, BOOLEAN R, DOUBLE R, DOUBLE R, INTEGER NOT NULL ID) NOT NULL])'
'      FennelRenameRel(fieldNames=[[NAME, R, R, R, ID]])'
'        FennelCalcRel(expr#0=[{inputs}], expr#1=['Default'], expr#2=[false], expr#3=[2.0], expr#4=[Reinterpret($t3)], expr#5=[CAST($t4):DOUBLE NOT NULL], expr#6=[1E1], expr#7=[/INT($t5, $t6)], expr#8=[CAST($t7):DOUBLE], expr#9=[4.0], expr#10=[Reinterpret($t9)], expr#11=[CAST($t10):DOUBLE NOT NULL], expr#12=[/INT($t11, $t6)], expr#13=[CAST($t12):DOUBLE], expr#14=[1], EXPR$0=[$t1], EXPR$1=[$t2], EXPR$1=[$t8], EXPR$1=[$t13], EXPR$2=[$t14])'
'          FennelValuesRel(tuples=[[{ 0 }]])'
> 
> explain plan for
> select * from rectangles t;
'column0'
'IterCalcRel(expr#0..4=[{inputs}], expr#5=[IS NULL($t1)], expr#6=[null], expr#7=[CAST($t6):ObjectSqlType(LOCALDB.LCS.RECTANGLE)], expr#8=[NEW($t2, $t3):ObjectSqlType(LOCALDB.LCS.RECTANGLE)], expr#9=[CASE($t5, $t7, $t8)], NAME=[$t0], R=[$t9], ID=[$t4])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RECTANGLES$ID, SYS$CLUSTERED_INDEX$RECTANGLES$NAME, SYS$CLUSTERED_INDEX$RECTANGLES$R]])'
> 
> explain plan for
> select id from rectangles t;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[ID]])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[4]], clustered indexes=[[SYS$CLUSTERED_INDEX$RECTANGLES$ID]])'
> 
> explain plan for
> select t.r.width from rectangles t;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[WIDTH]])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$RECTANGLES$R]])'
> 
> explain plan for
> select t.r.height, name from rectangles t;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[HEIGHT, NAME]])'
'    LcsRowScanRel(table=[[LOCALDB, LCS, RECTANGLES]], projection=[[3, 0]], clustered indexes=[[SYS$CLUSTERED_INDEX$RECTANGLES$NAME, SYS$CLUSTERED_INDEX$RECTANGLES$R]])'
> 
> !set outputformat table
> 
> truncate table rectangles;
> 
> select count(*) from rectangles;
+---------+
| EXPR$0  |
+---------+
| 0       |
+---------+
> 
> drop table rectangles;
> drop type rectangle;
> 
> ----------------------------------
> -- Part 5. Rowcounts on lcs tables
> ----------------------------------
> create server test_data
> foreign data wrapper sys_file_wrapper
> options (
>     directory 'unitsql/optimizer/data',
>     file_extension 'csv',
>     with_header 'yes',
>     log_directory 'testlog');
> 
> create foreign table matrix3x3(
>     a tinyint,
>     b integer,
>     c bigint)
> server test_data
> options (filename 'matrix3x3');
> 
> create table rowcount(a tinyint, b int, c bigint);
> create index irc1 on rowcount(a);
> insert into rowcount select * from matrix3x3;
> select * from rowcount order by 1;
+-----+-----+-----+
|  A  |  B  |  C  |
+-----+-----+-----+
| 11  | 12  | 13  |
| 21  | 22  | 23  |
| 31  | 32  | 33  |
+-----+-----+-----+
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 3                  | 0                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> -- make sure create index doesn't wipe out the rowcount
> create index irc2 on rowcount(b);
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 3                  | 0                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> insert into rowcount values(-1, -2, -3);
> select * from rowcount order by 1;
+-----+-----+-----+
|  A  |  B  |  C  |
+-----+-----+-----+
| -1  | -2  | -3  |
| 11  | 12  | 13  |
| 21  | 22  | 23  |
| 31  | 32  | 33  |
+-----+-----+-----+
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 4                  | 0                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> delete from rowcount where a = 11;
> select * from rowcount order by 1;
+-----+-----+-----+
|  A  |  B  |  C  |
+-----+-----+-----+
| -1  | -2  | -3  |
| 21  | 22  | 23  |
| 31  | 32  | 33  |
+-----+-----+-----+
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 3                  | 1                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> -- make sure rebuild maintains the same rowcount but resets the deletion count
> alter table rowcount rebuild;
> select * from rowcount order by 1;
+-----+-----+-----+
|  A  |  B  |  C  |
+-----+-----+-----+
| -1  | -2  | -3  |
| 21  | 22  | 23  |
| 31  | 32  | 33  |
+-----+-----+-----+
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 3                  | 0                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> -- make sure drop index doesn't wipe out rowcounts
> drop index irc1;
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 3                  | 0                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> -- make sure truncate resets the rowcounts
> truncate table rowcount;
> select * from rowcount order by 1;
+----+----+----+
| A  | B  | C  |
+----+----+----+
+----+----+----+
> select table_name, current_row_count, deleted_row_count
>     from sys_boot.mgmt.dba_stored_tables_internal1 
>     order by 1;
+-------------+--------------------+--------------------+
| TABLE_NAME  | CURRENT_ROW_COUNT  | DELETED_ROW_COUNT  |
+-------------+--------------------+--------------------+
| DEPTS       |                    |                    |
| EMPS        |                    |                    |
| MATRIX3X3   |                    |                    |
| ROWCOUNT    | 0                  | 0                  |
| TEMPS       |                    |                    |
+-------------+--------------------+--------------------+
> 
> drop table rowcount;
> drop server test_data cascade;
> 
> -------------------------------------
> -- Part 6. Misc tests for bugfixes
> -------------------------------------
> -- Tests LER-312 -- should not create empty cluster pages when no data
> -- is inserted into table
> create table empty(a int);
> create view v(a) as values(1);
> insert into empty select a from v where a = 2;
> select * from empty;
+----+
| A  |
+----+
+----+
> drop view v;
> drop table empty;
> 
> -- Tests LER-31 -- Not handling appends to existing table when the records
> -- are variable length and stored in either a compressed of variable mode
> -- batch.  Prior testcases do exercise this, but the column size isn't long
> -- enough to cause attempts to read invalid memory.  Note that the "null"
> -- is what causes the testcase below to result in there being enough variation
> -- in the record sizes to cause problems.
> 
> create table test_large_chars (a int, i char(100));
> 
> insert into test_large_chars values(1, null);
> insert into test_large_chars values(2, 'asdf');
> insert into test_large_chars values(3,
>     'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb');
> 
> select * from test_large_chars;
+----+-------------------------------------------------------------------------------------------------------+
| A  |                                                   I                                                   |
+----+-------------------------------------------------------------------------------------------------------+
| 1  |                                                                                                       |
| 2  | asdf                                                                                                  |
| 3  | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                              |
+----+-------------------------------------------------------------------------------------------------------+
> select * from test_large_chars where i is null;
+----+----+
| A  | I  |
+----+----+
| 1  |    |
+----+----+
> 
> drop table test_large_chars;
> 
> create table test_large_varchars (a int, i varchar(100));
> 
> insert into test_large_varchars values(1, null);
> insert into test_large_varchars values(2, 'asdf');
> insert into test_large_varchars values(3,
>     'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb');
> 
> select * from test_large_varchars;
+----+---------------------------------------------------------------------------+
| A  |                                     I                                     |
+----+---------------------------------------------------------------------------+
| 1  |                                                                           |
| 2  | asdf                                                                      |
| 3  | bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb  |
+----+---------------------------------------------------------------------------+
> select * from test_large_varchars where i is null;
+----+----+
| A  | I  |
+----+----+
| 1  |    |
+----+----+
> 
> drop table test_large_varchars;
> 
> -- LER-1402 -- the length of the data needs to be 510 to exercise this bug;
> -- in the repro for LER_1402, the crash occurs on the scan; in this testcase,
> -- the crash occurs on the insert
> create table test_large_varchars (a int, i varchar(1000));
> insert into test_large_varchars values(1,
> 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx');
> insert into test_large_varchars values(1,
> 'yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy');
> select char_length(i), * from test_large_varchars order by a;
+---------+----+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPR$0  | A  |                                                                                                                                                                                                                                                                I                                                                                                                                                                                                                                                                |
+---------+----+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 510     | 1  | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  |
| 510     | 1  | yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy  |
+---------+----+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
> drop table test_large_varchars;
> 
> -- LER-3681 (verify that self-insert with a UDX in the middle does not
> -- hang due to lockout)
> 
> create function stringify(c cursor, delimiter varchar(128))
> returns table(v varchar(65535))
> language java
> parameter style system defined java
> no sql
> external name 'class net.sf.farrago.test.FarragoTestUDR.stringify';
> 
> create table self_insert_udx(a char(10));
> insert into self_insert_udx values('abc');
> insert into self_insert_udx 
> select * from table(stringify(cursor(select * from self_insert_udx), '|'));
> 
> -- End lcs.sql
> 
> !quit
