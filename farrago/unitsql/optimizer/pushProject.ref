> -- $Id$
> -- Test pushdown of projections.  This test primarily tests projections 
> -- involving views.  Other tests do a fairly good job testing projections
> -- on base tables.
> 
> create schema pp;
> set schema 'pp';
> 
> -- force usage of Fennel calculator
> alter system set "calcVirtualMachine" = 'CALCVM_FENNEL';
> 
> -- test a few queries on FTRS first, but the bulk of the tests are against LCS
> create view vemps(eno, name, deptno, doubleage)
>     as select empno, upper(name), deptno, age * 2 from sales.emps;
> create view vdepts(name, deptno)
>     as select upper(name), deptno from sales.depts;
> 
> !set outputformat csv
> explain plan for
>     select ve.name, ve.doubleage, vd.name
>         from vemps ve, vdepts vd
>         where ve.deptno = vd.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..4=[{inputs}], expr#5=[=($t1, $t4)], NAME=[$t0], DOUBLEAGE=[$t2], NAME0=[$t3], $condition=[$t5])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      FennelCalcRel(expr#0..2=[{inputs}], expr#3=[UPPER($t0)], expr#4=[2], expr#5=[*($t2, $t4)], NAME=[$t3], DEPTNO=[$t1], DOUBLEAGE=[$t5])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
'      FennelBufferRel(inMemory=[false], multiPass=[true])'
'        FennelRenameRel(fieldNames=[[NAME, DEPTNO]])'
'          FennelCalcRel(expr#0..1=[{inputs}], expr#2=[UPPER($t1)], EXPR$0=[$t2], DEPTNO=[$t0])'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
> explain plan for
>     select lower(ve.name), ve.doubleage/2
>         from vemps ve, vdepts vd
>         where ve.deptno = vd.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..3=[{inputs}], expr#4=[LOWER($t0)], expr#5=[2], expr#6=[/($t2, $t5)], EXPR$0=[$t4], EXPR$1=[$t6])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[1]], inputJoinProj=[[0, 1, 2]], inputDirectiveProj=[[]])'
'      FennelCalcRel(expr#0..2=[{inputs}], expr#3=[UPPER($t0)], expr#4=[2], expr#5=[*($t2, $t4)], NAME=[$t3], DEPTNO=[$t1], DOUBLEAGE=[$t5])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
>         
> !set outputformat table
> select ve.name, ve.doubleage, vd.name
>     from vemps ve, vdepts vd
>     where ve.deptno = vd.deptno order by 1;
+--------+------------+------------+
|  NAME  | DOUBLEAGE  |    NAME    |
+--------+------------+------------+
| ERIC   | 160        | MARKETING  |
| FRED   | 50         | SALES      |
| WILMA  | 100        | MARKETING  |
+--------+------------+------------+
> select lower(ve.name), ve.doubleage/2
>     from vemps ve, vdepts vd
>     where ve.deptno = vd.deptno order by 1;
+---------+---------+
| EXPR$0  | EXPR$1  |
+---------+---------+
| eric    | 80      |
| fred    | 25      |
| wilma   | 50      |
+---------+---------+
> 
> drop view vemps;
> drop view vdepts;
> 
> -- now, LCS
> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
> 
> create table lcsemps(
>     empno int, name varchar(12), deptno int, gender char(1), city varchar(12),
>     empid int, age int);
> insert into lcsemps
>     select empno, name, deptno, gender, city, empid, age from sales.emps;
> create table lcsdepts(deptno int, name varchar(12));
> insert into lcsdepts select * from sales.depts;
> 
> create view vemps(eno, name, deptno, doubleage)
>     as select empno, upper(name), deptno, age * 2 from lcsemps;
> create view vdepts(name, deptno)
>     as select upper(name), deptno from lcsdepts;
> 
> !set outputformat csv
> explain plan for
>     select ve.name, ve.doubleage, vd.name
>         from vemps ve, vdepts vd
>         where ve.deptno = vd.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 2, 3]], outputRowType=[RecordType(VARCHAR(12) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME, INTEGER DOUBLEAGE, VARCHAR(12) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NAME0) NOT NULL])'
'    LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'      FennelCalcRel(expr#0..2=[{inputs}], expr#3=[UPPER($t0)], expr#4=[2], expr#5=[*($t2, $t4)], NAME=[$t3], DEPTNO=[$t1], DOUBLEAGE=[$t5])'
'        LcsRowScanRel(table=[[LOCALDB, PP, LCSEMPS]], projection=[[1, 2, 6]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$LCSEMPS$AGE, SYS$CLUSTERED_INDEX$PP$LCSEMPS$DEPTNO, SYS$CLUSTERED_INDEX$PP$LCSEMPS$NAME]])'
'      FennelRenameRel(fieldNames=[[NAME, DEPTNO]])'
'        FennelCalcRel(expr#0..1=[{inputs}], expr#2=[UPPER($t1)], EXPR$0=[$t2], DEPTNO=[$t0])'
'          LcsRowScanRel(table=[[LOCALDB, PP, LCSDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$LCSDEPTS$DEPTNO, SYS$CLUSTERED_INDEX$PP$LCSDEPTS$NAME]])'
> explain plan for
>     select lower(ve.name), ve.doubleage/2
>         from vemps ve, vdepts vd
>         where ve.deptno = vd.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..3=[{inputs}], expr#4=[LOWER($t0)], expr#5=[2], expr#6=[/($t2, $t5)], EXPR$0=[$t4], EXPR$1=[$t6])'
'    LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'      FennelCalcRel(expr#0..2=[{inputs}], expr#3=[UPPER($t0)], expr#4=[2], expr#5=[*($t2, $t4)], NAME=[$t3], DEPTNO=[$t1], DOUBLEAGE=[$t5])'
'        LcsRowScanRel(table=[[LOCALDB, PP, LCSEMPS]], projection=[[1, 2, 6]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$LCSEMPS$AGE, SYS$CLUSTERED_INDEX$PP$LCSEMPS$DEPTNO, SYS$CLUSTERED_INDEX$PP$LCSEMPS$NAME]])'
'      LcsRowScanRel(table=[[LOCALDB, PP, LCSDEPTS]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$LCSDEPTS$DEPTNO]])'
>         
> !set outputformat table
> select ve.name, ve.doubleage, vd.name
>     from vemps ve, vdepts vd
>     where ve.deptno = vd.deptno order by 1;
+--------+------------+------------+
|  NAME  | DOUBLEAGE  |    NAME    |
+--------+------------+------------+
| ERIC   | 160        | MARKETING  |
| FRED   | 50         | SALES      |
| WILMA  | 100        | MARKETING  |
+--------+------------+------------+
> select lower(ve.name), ve.doubleage
>     from vemps ve, vdepts vd
>     where ve.deptno = vd.deptno order by 1;
+---------+------------+
| EXPR$0  | DOUBLEAGE  |
+---------+------------+
| eric    | 160        |
| fred    | 50         |
| wilma   | 100        |
+---------+------------+
> 
> create table t1(t1a int, t1b int, t1c int);
> create table t2(t2a int, t2b int, t2c int, t2d int);
> create table t3(t3a int, t3b int, t3c int, t3d int, t3e int);
> insert into t1 values(1, 11, 12);
> insert into t1 values(2, 21, 22);
> insert into t1 values(3, 31, 32);
> insert into t1 values(4, 41, 42);
> insert into t1 values(5, 51, 52);
> insert into t2 values(1, 101, 102, 103);
> insert into t2 values(2, 201, 202, 203);
> insert into t2 values(3, 301, 302, 303);
> insert into t2 values(4, 401, 402, 403);
> insert into t2 values(5, 501, 502, 503);
> insert into t3 values(1, 1001, 1002, 1003, 1004);
> insert into t3 values(2, 2001, 2002, 2003, 2004);
> insert into t3 values(3, 3001, 3002, 3003, 3004);
> insert into t3 values(4, 4001, 4002, 4003, 4004);
> insert into t3 values(5, 5001, 5002, 5003, 5004);
> create view vjoin(vja, vjb, vjc) as
>     select t1.t1b - 10, t2.t2c - 100, t3.t3d - 1000
>         from t1, t2, t3 where t1.t1a = t2.t2a and t2.t2a = t3.t3a;
> 
> select * from vjoin order by vja;
+------+------+-------+
| VJA  | VJB  |  VJC  |
+------+------+-------+
| 1    | 2    | 3     |
| 11   | 102  | 1003  |
| 21   | 202  | 2003  |
| 31   | 302  | 3003  |
| 41   | 402  | 4003  |
+------+------+-------+
> select vjc/1000, vja/10, vjb/100 from vjoin order by 1;
+---------+---------+---------+
| EXPR$0  | EXPR$1  | EXPR$2  |
+---------+---------+---------+
| 0       | 0       | 0       |
| 1       | 1       | 1       |
| 2       | 2       | 2       |
| 3       | 3       | 3       |
| 4       | 4       | 4       |
+---------+---------+---------+
> select count(*) from vjoin;
+---------+
| EXPR$0  |
+---------+
| 5       |
+---------+
> select lcs_rid(vja) from vjoin order by 1;
+---------+
| EXPR$0  |
+---------+
| 0       |
| 1       |
| 2       |
| 3       |
| 4       |
+---------+
> select 2*vjb, lcs_rid(vja) from vjoin order by 2;
+---------+---------+
| EXPR$0  | EXPR$1  |
+---------+---------+
| 4       | 0       |
| 204     | 1       |
| 404     | 2       |
| 604     | 3       |
| 804     | 4       |
+---------+---------+
> 
> !set outputformat csv
> explain plan for select * from vjoin order by vja;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelRenameRel(fieldNames=[[VJA, VJB, VJC]])'
'      FennelCalcRel(expr#0..4=[{inputs}], expr#5=[10], expr#6=[-($t0, $t5)], expr#7=[100], expr#8=[-($t2, $t7)], expr#9=[1000], expr#10=[-($t4, $t9)], EXPR$0=[$t6], EXPR$1=[$t8], EXPR$2=[$t10])'
'        LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'          FennelReshapeRel(projection=[[1, 2, 3]], outputRowType=[RecordType(INTEGER T1B, INTEGER T2A, INTEGER T2C) NOT NULL])'
'            LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'              LcsRowScanRel(table=[[LOCALDB, PP, T1]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T1$T1A, SYS$CLUSTERED_INDEX$PP$T1$T1B]])'
'              LcsRowScanRel(table=[[LOCALDB, PP, T2]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T2$T2A, SYS$CLUSTERED_INDEX$PP$T2$T2C]])'
'          LcsRowScanRel(table=[[LOCALDB, PP, T3]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T3$T3A, SYS$CLUSTERED_INDEX$PP$T3$T3D]])'
> explain plan for select vjc/1000, vja/10, vjb/100 from vjoin order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..4=[{inputs}], expr#5=[1000], expr#6=[-($t4, $t5)], expr#7=[/($t6, $t5)], expr#8=[10], expr#9=[-($t0, $t8)], expr#10=[/($t9, $t8)], expr#11=[100], expr#12=[-($t2, $t11)], expr#13=[/($t12, $t11)], EXPR$0=[$t7], EXPR$1=[$t10], EXPR$2=[$t13])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[1, 2, 3]], outputRowType=[RecordType(INTEGER T1B, INTEGER T2A, INTEGER T2C) NOT NULL])'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, PP, T1]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T1$T1A, SYS$CLUSTERED_INDEX$PP$T1$T1B]])'
'            LcsRowScanRel(table=[[LOCALDB, PP, T2]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T2$T2A, SYS$CLUSTERED_INDEX$PP$T2$T2C]])'
'        LcsRowScanRel(table=[[LOCALDB, PP, T3]], projection=[[0, 3]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T3$T3A, SYS$CLUSTERED_INDEX$PP$T3$T3D]])'
> explain plan for select count(*) from vjoin;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[EXPR$0]])'
'    FennelAggRel(groupCount=[0], agg#0=[COUNT()])'
'      FennelCalcRel(expr#0..1=[{inputs}], expr#2=[true], $f0=[$t2])'
'        LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'          FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(INTEGER T2A) NOT NULL])'
'            LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'              LcsRowScanRel(table=[[LOCALDB, PP, T1]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T1$T1A]])'
'              LcsRowScanRel(table=[[LOCALDB, PP, T2]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T2$T2A]])'
'          LcsRowScanRel(table=[[LOCALDB, PP, T3]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T3$T3A]])'
> explain plan for select lcs_rid(vja) from vjoin order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT EXPR$0) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(INTEGER T2A, BIGINT LCS_RID) NOT NULL])'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, PP, T1]], projection=[[0, LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T1$T1A]])'
'            LcsRowScanRel(table=[[LOCALDB, PP, T2]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T2$T2A]])'
'        LcsRowScanRel(table=[[LOCALDB, PP, T3]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T3$T3A]])'
> explain plan for select 2*vjb, lcs_rid(vja) from vjoin order by 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..3=[{inputs}], expr#4=[2], expr#5=[100], expr#6=[-($t1, $t5)], expr#7=[*($t4, $t6)], EXPR$0=[$t7], EXPR$1=[$t2])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[2, 3, 1]], outputRowType=[RecordType(INTEGER T2A, INTEGER T2C, BIGINT LCS_RID) NOT NULL])'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, PP, T1]], projection=[[0, LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T1$T1A]])'
'            LcsRowScanRel(table=[[LOCALDB, PP, T2]], projection=[[0, 2]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T2$T2A, SYS$CLUSTERED_INDEX$PP$T2$T2C]])'
'        LcsRowScanRel(table=[[LOCALDB, PP, T3]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$PP$T3$T3A]])'
> 
> !quit
