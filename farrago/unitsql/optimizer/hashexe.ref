> -------------------------------------------------
> -- LucidDB SQL test for Hash Join and Hash Agg --
> -------------------------------------------------
> 
> ------------------------------------------------
> -- default personality uses cartesian product --
> ------------------------------------------------
> create schema lhx;
> set schema 'lhx';
> set path 'lhx';
> 
> -- force usage of Java calculator
> alter system set "calcVirtualMachine" = 'CALCVM_JAVA';
> 
> alter session implementation set default;
> 
> -- for first portion, prevent usage of hash/NL join so that we can use
> -- cartesian join as a reference instead
> call sys_boot.mgmt.set_opt_rule_desc_exclusion_filter(
>     'Lhx.*Rule|.*NestedLoop.*');
> 
> create table lhxemps(
>     empno integer primary key,
>     ename varchar(40),
>     deptno integer);
> 
> create table lhxdepts(
>     deptnoA integer primary key);
> 
> insert into lhxemps
>     select empno, name, deptno from sales.emps where empno <> 110;
> 
> insert into lhxdepts select deptno from sales.emps where deptno <> 20;
> 
> !set outputformat csv
> select * from lhxemps order by 1;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'120','Wilma','20'
> select * from lhxdepts order by 1;
'DEPTNOA'
'10'
'40'
> 
> explain plan for 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$LHXDEPTS], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[3]], inputJoinProj=[[0, 1, 2]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..2=[{inputs}], expr#3=[IS NOT NULL($t2)], expr#4=[CAST($t2):INTEGER NOT NULL], proj#0..2=[{exprs}], DEPTNOA=[$t4], $condition=[$t3])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$LHXEMPS], preserveOrder=[false])'
> 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA'
'100','Fred','10','10'
> 
> ---------------------------------------------------
> -- test "is not distinct from" as join condition --
> ---------------------------------------------------
> explain plan for
> select * from lhxemps, lhxdepts
> where lhxemps.deptno is not distinct from lhxdepts.deptnoA;
'column0'
'IterCalcRel(expr#0..3=[{inputs}], expr#4=[IS NULL($t2)], expr#5=[IS NULL($t3)], expr#6=[=($t2, $t3)], expr#7=[CASE($t4, $t5, $t5, $t4, $t6)], expr#8=[CAST($t7):BOOLEAN NOT NULL], proj#0..3=[{exprs}], $condition=[$t8])'
'  FennelToIteratorConverter'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      FtrsIndexScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$LHXEMPS], preserveOrder=[false])'
'      FennelBufferRel(inMemory=[false], multiPass=[true])'
'        FtrsIndexScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$LHXDEPTS], preserveOrder=[false])'
> 
> -- Clean up
> !set outputformat table
> drop schema lhx cascade;
> 
> 
> ------------------------------------
> -- test LDB personality with hash join --
> ------------------------------------
> create schema lhx;
> set schema 'lhx';
> set path 'lhx';
> 
> -- force usage of Java calculator
> alter system set "calcVirtualMachine" = 'CALCVM_JAVA';
> 
> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
> 
> -- allow hash joins again
> call sys_boot.mgmt.set_opt_rule_desc_exclusion_filter(null);
> 
> create table lhxemps(
>     empno integer not null,
>     ename varchar(40),
>     deptno integer);
> 
> create table lhxdepts(
>     deptnoA integer,
>     deptnoB integer);
> 
> create table lhxdepts2(
>     deptnoC integer,
>     deptnoD integer);
> 
> create table lhxdepts3(
>     deptnoE integer,
>     deptnoF integer);
> 
> create table lhxdepts4(
>     deptnoG integer,
>     deptnoH integer);
> 
> insert into lhxemps select empno, name, deptno from sales.emps;
> insert into lhxemps select empno, name, deptno from sales.emps;
> 
> insert into lhxdepts select deptno, deptno from sales.emps;
> insert into lhxdepts2 select deptno, deptno from sales.emps;
> insert into lhxdepts3 select deptno, deptno from sales.emps;
> insert into lhxdepts4 select deptno, deptno from sales.emps;
> 
> 
> !set outputformat csv
> select * from lhxemps order by 1;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> select * from lhxdepts order by 1;
'DEPTNOA','DEPTNOB'
'10','10'
'20','20'
'20','20'
'40','40'
> select * from lhxdepts2 order by 1;
'DEPTNOC','DEPTNOD'
'10','10'
'20','20'
'20','20'
'40','40'
> 
> explain plan for 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOB]])'
> 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB'
'100','Fred','10','10','10'
'100','Fred','10','10','10'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','John','40','40','40'
'110','John','40','40','40'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
> 
> -- test hash join implementation for big IN
> explain plan for 
> select ename from lhxemps
> where empno in 
> (110, 110, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
> order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFTSEMI])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelValuesRel(tuples=[[{ 110 }, { 110 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }]])'
> 
> select ename from lhxemps
> where empno in 
> (110, 110, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
> order by ename;
'ENAME'
'Eric'
'Eric'
'John'
'John'
> 
> -- this query uses hash join after pushing down the RHS expression
> explain plan for 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA + 1
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3, 4]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, INTEGER DEPTNOA, INTEGER DEPTNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[2]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0..1=[{inputs}], expr#2=[1], expr#3=[+($t0, $t2)], proj#0..1=[{exprs}], +($0, 1)=[$t3])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOB]])'
> 
> -- multiple conditions between the same pair of tables
> explain plan for 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA and lhxemps.deptno = lhxdepts.deptnoB
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2, 2]], rightKeys=[[0, 1]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOB]])'
> 
> select * from lhxemps, lhxdepts
> where lhxemps.deptno = lhxdepts.deptnoA and lhxemps.deptno = lhxdepts.deptnoB
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB'
'100','Fred','10','10','10'
'100','Fred','10','10','10'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','John','40','40','40'
'110','John','40','40','40'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
> 
> -- now try two joins
> explain plan for 
> select * from lhxemps, lhxdepts, lhxdepts2
> where lhxemps.deptno = lhxdepts.deptnoB and lhxdepts.deptnoA = lhxdepts2.deptnoC
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[INNER])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS2$DEPTNOC, SYS$CLUSTERED_INDEX$LHXDEPTS2$DEPTNOD]])'
> 
> select * from lhxemps, lhxdepts, lhxdepts2
> where lhxemps.deptno = lhxdepts.deptnoB and lhxdepts.deptnoA = lhxdepts2.deptnoC
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB','DEPTNOC','DEPTNOD'
'100','Fred','10','10','10','10','10'
'100','Fred','10','10','10','10','10'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','John','40','40','40','40','40'
'110','John','40','40','40','40','40'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
> 
> -- four joins
> explain plan for 
> select * from lhxemps, lhxdepts, lhxdepts2, lhxdepts3, lhxdepts4
> where lhxemps.deptno = lhxdepts.deptnoB and lhxemps.deptno = lhxdepts2.deptnoC
>     and lhxemps.deptno = lhxdepts3.deptnoF and lhxemps.deptno = lhxdepts4.deptnoG
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'        LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'          LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOB]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS2$DEPTNOC, SYS$CLUSTERED_INDEX$LHXDEPTS2$DEPTNOD]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS3$DEPTNOE, SYS$CLUSTERED_INDEX$LHXDEPTS3$DEPTNOF]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS4$DEPTNOG, SYS$CLUSTERED_INDEX$LHXDEPTS4$DEPTNOH]])'
> 
> select * from lhxemps, lhxdepts, lhxdepts2, lhxdepts3, lhxdepts4
> where lhxemps.deptno = lhxdepts.deptnoB and lhxemps.deptno = lhxdepts2.deptnoC
>     and lhxemps.deptno = lhxdepts3.deptnoF and lhxemps.deptno = lhxdepts4.deptnoG
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB','DEPTNOC','DEPTNOD','DEPTNOE','DEPTNOF','DEPTNOG','DEPTNOH'
'100','Fred','10','10','10','10','10','10','10','10','10'
'100','Fred','10','10','10','10','10','10','10','10','10'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','John','40','40','40','40','40','40','40','40','40'
'110','John','40','40','40','40','40','40','40','40','40'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
> 
> -- explicit type casting is added because hash join requires 
> -- join keys have identical types
> create table lhxemps2(
>     enameA varchar(20))
> server sys_column_store_data_server;
> 
> insert into lhxemps2 select name from sales.emps;
> 
> select * from lhxemps2 order by 1;
'ENAMEA'
'Eric'
'Fred'
'John'
'Wilma'
> 
> explain plan for
> select * from lhxemps, lhxemps2
> where lhxemps.ename = lhxemps2.enameA
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS2$ENAMEA]])'
> 
> select * from lhxemps, lhxemps2
> where lhxemps.ename = lhxemps2.enameA
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEA'
'100','Fred','10','Fred'
'100','Fred','10','Fred'
'110','Eric','20','Eric'
'110','Eric','20','Eric'
'110','John','40','John'
'110','John','40','John'
'120','Wilma','20','Wilma'
'120','Wilma','20','Wilma'
> 
> -- try both explicit and implicit casting
> explain plan for
> select * from lhxemps, lhxemps2
> where lhxemps.ename = cast(lhxemps2.enameA as varchar(40))
>       and lhxemps.ename = lhxemps2.enameA
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1, 1]], rightKeys=[[1, 2]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelReshapeRel(projection=[[0, 0, 0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary", VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS2$ENAMEA]])'
> 
> select * from lhxemps, lhxemps2
> where lhxemps.ename = cast(lhxemps2.enameA as varchar(40))
>       and lhxemps.ename = lhxemps2.enameA
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEA'
'100','Fred','10','Fred'
'100','Fred','10','Fred'
'110','Eric','20','Eric'
'110','Eric','20','Eric'
'110','John','40','John'
'110','John','40','John'
'120','Wilma','20','Wilma'
'120','Wilma','20','Wilma'
> 
> explain plan for
> select * from lhxemps, lhxemps2
> where cast(lhxemps.ename as varchar(20)) = lhxemps2.enameA
>       and lhxemps.ename = cast(lhxemps2.enameA as varchar(40))
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 2, 4]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA) NOT NULL])'
'      LhxJoinRel(leftKeys=[[3, 1]], rightKeys=[[0, 1]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[0, 1, 2, 1]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($1):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS2$ENAMEA]])'
> 
> select * from lhxemps, lhxemps2
> where cast(lhxemps.ename as varchar(20)) = lhxemps2.enameA
>       and lhxemps.ename = cast(lhxemps2.enameA as varchar(40))
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEA'
'100','Fred','10','Fred'
'100','Fred','10','Fred'
'110','Eric','20','Eric'
'110','Eric','20','Eric'
'110','John','40','John'
'110','John','40','John'
'120','Wilma','20','Wilma'
'120','Wilma','20','Wilma'
> 
> -- make sure casting in both directions work
> explain plan for
> select * from lhxemps2, lhxemps
> where lhxemps2.enameA = lhxemps.ename
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 2]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0, 1, 2]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA, INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS2$ENAMEA]])'
> 
> select * from lhxemps2, lhxemps
> where lhxemps2.enameA = lhxemps.ename
> order by empno, ename;
'ENAMEA','EMPNO','ENAME','DEPTNO'
'Fred','100','Fred','10'
'Fred','100','Fred','10'
'Eric','110','Eric','20'
'Eric','110','Eric','20'
'John','110','John','40'
'John','110','John','40'
'Wilma','120','Wilma','20'
'Wilma','120','Wilma','20'
> 
> drop table lhxemps2;
> create table lhxemps2(
>     enameA varchar(60) not null)
> server sys_column_store_data_server;
> 
> insert into lhxemps2 select name from sales.emps;
> 
> explain plan for
> select * from lhxemps2, lhxemps
> where lhxemps2.enameA = lhxemps.ename
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 2]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[4, 0, 1, 2]], outputRowType=[RecordType(VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAMEA, INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO) NOT NULL])'
'      LhxJoinRel(leftKeys=[[3]], rightKeys=[[1]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[0, 1, 2, 1]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($1):VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAMEA, VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS2$ENAMEA]])'
> 
> select * from lhxemps2, lhxemps
> where lhxemps2.enameA = lhxemps.ename
> order by empno, ename;
'ENAMEA','EMPNO','ENAME','DEPTNO'
'Fred','100','Fred','10'
'Fred','100','Fred','10'
'Eric','110','Eric','20'
'Eric','110','Eric','20'
'John','110','John','40'
'John','110','John','40'
'Wilma','120','Wilma','20'
'Wilma','120','Wilma','20'
> 
> 
> -- trailing blanks are insignificant when joining two
> -- character types.
> create table lhxemps3(
>     enameB char(20))
> server sys_column_store_data_server;
> 
> insert into lhxemps3 select name from sales.emps;
> 
> select * from lhxemps3 order by 1;
'ENAMEB'
'Eric                '
'Fred                '
'John                '
'Wilma               '
> 
> explain plan for
> select * from lhxemps, lhxemps3
> where lhxemps.ename = lhxemps3.enameB
> order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 2, 3]], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
> 
> select * from lhxemps, lhxemps3
> where lhxemps.ename = lhxemps3.enameB
> order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEB'
'100','Fred','10','Fred                '
'100','Fred','10','Fred                '
'110','Eric','20','Eric                '
'110','Eric','20','Eric                '
'110','John','40','John                '
'110','John','40','John                '
'120','Wilma','20','Wilma               '
'120','Wilma','20','Wilma               '
> 
> -- column values containing null
> -- nulls should not join with nulls of a different type
> drop table lhxemps2;
> create table lhxemps2(
>     enameA varchar(60))
> server sys_column_store_data_server;
> 
> insert into lhxemps2 select name from sales.emps;
> 
> insert into lhxemps2 values(null);
> 
> insert into lhxemps3 values(null);
> 
> explain plan for
> select * from lhxemps2, lhxemps3
> where lhxemps2.enameA = lhxemps3.enameB
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1]], outputRowType=[RecordType(VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEA, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS2$ENAMEA]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB, VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(60) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
> 
> select * from lhxemps2, lhxemps3
> where lhxemps2.enameA = lhxemps3.enameB
> order by 1, 2;
'ENAMEA','ENAMEB'
'Eric','Eric                '
'Fred','Fred                '
'John','John                '
'Wilma','Wilma               '
> 
> -- nulls should not join with nulls of the same type either
> create table lhxemps4(
>     enameC char(20))
> server sys_column_store_data_server;
> 
> insert into lhxemps4 select name from sales.emps;
> 
> insert into lhxemps4 values(null);
> 
> select * from lhxemps4 order by 1;
'ENAMEC'
''
'Eric                '
'Fred                '
'John                '
'Wilma               '
> 
> explain plan for
> select * from lhxemps3, lhxemps4
> where lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3, lhxemps4
> where lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'ENAMEB','ENAMEC'
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
> 
> insert into lhxemps3 values('Leo');
> 
> insert into lhxemps4 values('Adel');
> 
> -- outer join types
> explain plan for
> select * from lhxemps3 left outer join lhxemps4
> on lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 left outer join lhxemps4
> on lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'ENAMEB','ENAMEC'
'',''
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Leo                 ',''
'Wilma               ','Wilma               '
> 
> -- put a filter on the RHS of the outer join to force the RHS to remain on
> -- the RHS
> explain plan for
> select * from lhxemps3 right outer join
>     (select * from lhxemps4 where enameC > 'A' or enameC is null) as lhxemps4
> on lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[RIGHT])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]], residual columns=[[0]])'
'        FennelValuesRel(tuples=[[{ '[', null, ']', null }, { '(', 'A                   ', '+', null }]])'
> 
> select * from lhxemps3 right outer join
>     (select * from lhxemps4 where enameC > 'A' or enameC is null) as lhxemps4
> on lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'ENAMEB','ENAMEC'
'',''
'','Adel                '
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
> 
> explain plan for
> select * from lhxemps3 full outer join lhxemps4
> on lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[FULL])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 full outer join lhxemps4
> on lhxemps3.enameB = lhxemps4.enameC
> order by 1, 2;
'ENAMEB','ENAMEC'
'',''
'',''
'','Adel                '
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Leo                 ',''
'Wilma               ','Wilma               '
> 
> -- semi/anti join types
> explain plan for
> select * from lhxemps3 intersect select * from lhxemps4
> order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFTSEMI], setop=[true])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'      FennelRenameRel(fieldNames=[[ENAMEB]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 intersect select * from lhxemps4
> order by 1;
'ENAMEB'
''
'Eric                '
'Fred                '
'John                '
'Wilma               '
> 
> explain plan for
> select * from lhxemps3 except select * from lhxemps4
> order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[RIGHTANTI], setop=[true])'
'      FennelRenameRel(fieldNames=[[ENAMEB]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
> 
> select * from lhxemps3 except select * from lhxemps4
> order by 1;
'ENAMEB'
'Leo                 '
> 
> -- Use an explicit cast operator will make the joinkeys
> -- have same data types. HashJoin can be used.
> 
> explain plan for
> select * from lhxemps3 inner join lhxemps4
> on lhxemps3.enameB = cast(lhxemps4.enameC as char(20))
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEC) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEC, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 inner join lhxemps4
> on lhxemps3.enameB = cast(lhxemps4.enameC as char(20))
> order by 1, 2;
'ENAMEB','ENAMEC'
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
> 
> explain plan for
> select * from lhxemps3 inner join lhxemps4
> on upper(lhxemps3.enameB) = upper(cast(lhxemps4.enameC as char(20)))
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEC) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#2=[UPPER($t1)], ENAMEC=[$t0], UPPER(CAST($0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary")=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 inner join lhxemps4
> on upper(lhxemps3.enameB) = upper(cast(lhxemps4.enameC as char(20)))
> order by 1, 2;
'ENAMEB','ENAMEC'
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
> 
> explain plan for
> select * from lhxemps3 inner join lhxemps4
> on upper(cast(lhxemps3.enameB as char(20))) = upper(cast(lhxemps4.enameC as char(20)))
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEC) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#2=[UPPER($t1)], ENAMEB=[$t0], UPPER(CAST($0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary")=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#2=[UPPER($t1)], ENAMEC=[$t0], UPPER(CAST($0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary")=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 inner join lhxemps4
> on upper(cast(lhxemps3.enameB as char(20))) = upper(cast(lhxemps4.enameC as char(20)))
> order by 1, 2;
'ENAMEB','ENAMEC'
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
> 
> explain plan for
> select * from lhxemps3 inner join lhxemps4
> on upper(cast(lhxemps3.enameB as char(20))) = cast(lhxemps4.enameC as char(20))
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEB, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEC) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[1]], joinType=[INNER])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#2=[UPPER($t1)], ENAMEB=[$t0], UPPER(CAST($0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary")=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS3$ENAMEB]])'
'        FennelReshapeRel(projection=[[0, 0]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAMEC, CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS4$ENAMEC]])'
> 
> select * from lhxemps3 inner join lhxemps4
> on upper(cast(lhxemps3.enameB as char(20))) = cast(lhxemps4.enameC as char(20))
> order by 1, 2;
'ENAMEB','ENAMEC'
> 
> -- test ON clause filter conditions for outer joins
> create table lhxemps5(
>     empnoA integer)
> server sys_column_store_data_server;
> 
> create table lhxemps6(
>     empnoB integer)
> server sys_column_store_data_server;
> 
> insert into lhxemps5 values(1);
> insert into lhxemps5 values(2);
> 
> insert into lhxemps6 values(2);
> insert into lhxemps6 values(3);
> 
> explain plan for
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[FULL])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
> 
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB
> order by 1, 2;
'EMPNOA','EMPNOB'
'','3'
'1',''
'2','2'
> 
> -- outer join with filter predicates
> -- filter pushed down
> explain plan for
> select * from lhxemps5 join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 2
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1, 0]], outputRowType=[RecordType(INTEGER EMPNOA, INTEGER EMPNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[2], expr#2=[<>($t0, $t1)], EMPNOA=[$t0], $condition=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
> 
> -- filter not pushed down
> -- outer join on filter can not be evaluated as post filter
> explain plan for
> select * from lhxemps5 left outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 2
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(INTEGER EMPNOA, INTEGER EMPNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[0, 1]], joinType=[LEFT])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[2], expr#2=[<>($t0, $t1)], EMPNOA=[$t0], <>($0, 2)=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
> 
> select * from lhxemps5 left outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 2
> order by 1, 2;
'EMPNOA','EMPNOB'
'1',''
'2',''
> 
> select * from lhxemps5 left outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 3
> order by 1, 2;
'EMPNOA','EMPNOB'
'1',''
'2','2'
> 
> -- filter pushed down
> explain plan for
> select * from lhxemps5 right outer join
>     (select * from lhxemps6 where empnoB > 0) as lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 2
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1, 0]], outputRowType=[RecordType(INTEGER EMPNOA, INTEGER EMPNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]], residual columns=[[0]])'
'          FennelValuesRel(tuples=[[{ '(', 0, '+', null }]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[2], expr#2=[<>($t0, $t1)], EMPNOA=[$t0], $condition=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
> 
> -- filter not pushed down
> -- outer join on filter can not be evaluated as post filter
> explain plan for
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 2
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(INTEGER EMPNOA, INTEGER EMPNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[0, 1]], joinType=[FULL])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[2], expr#2=[<>($t0, $t1)], EMPNOA=[$t0], <>($0, 2)=[$t2])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
> 
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA <> 2
> order by 1, 2;
'EMPNOA','EMPNOB'
'','2'
'','3'
'1',''
'2',''
> 
> -- this can use hash outer join also
> explain plan for
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA > lhxemps5.empnoA
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(INTEGER EMPNOA, INTEGER EMPNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[0, 1]], joinType=[FULL])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[>($t0, $t0)], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
> 
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA > lhxemps5.empnoA
> order by 1, 2;
'EMPNOA','EMPNOB'
'','2'
'','3'
'1',''
'2',''
> 
> explain plan for
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA * lhxemps5.empnoA > 10
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 2]], outputRowType=[RecordType(INTEGER EMPNOA, INTEGER EMPNOB) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[0, 1]], joinType=[FULL])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[*($t0, $t0)], expr#2=[10], expr#3=[>($t1, $t2)], EMPNOA=[$t0], >(*($0, $0), 10)=[$t3])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[true], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
> 
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA * lhxemps5.empnoA > 10
> order by 1, 2;
'EMPNOA','EMPNOB'
'','2'
'','3'
'1',''
'2',''
> 
> -- this will use a post-join filter
> explain plan for
> select * from lhxemps5 join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA > lhxemps6.empnoB
> order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..1=[{inputs}], expr#2=[>($t0, $t1)], proj#0..1=[{exprs}], $condition=[$t2])'
'        FennelToIteratorConverter'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS5$EMPNOA]])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS6$EMPNOB]])'
> 
> -- outer join on filter can not be evaluated as post filter
> -- this should report an error
> explain plan without implementation for
> select * from lhxemps5 left outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA > lhxemps6.empnoB
> order by 1, 2;
'column0'
'SortRel(sort0=[$0], sort1=[$1], dir0=[Ascending], dir1=[Ascending])'
'  ProjectRel(EMPNOA=[$0], EMPNOB=[$1])'
'    JoinRel(condition=[AND(=($0, $1), >($0, $1))], joinType=[left])'
'      TableAccessRel(table=[[LOCALDB, LHX, LHXEMPS5]])'
'      TableAccessRel(table=[[LOCALDB, LHX, LHXEMPS6]])'
> 
> -- outer join on filter can not be evaluated as post filter
> -- this should report an error
> explain plan without implementation for
> select * from lhxemps5 right outer join
>     (select * from lhxemps6 where empnoB > 0) as lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA > lhxemps6.empnoB
> order by 1, 2;
'column0'
'SortRel(sort0=[$0], sort1=[$1], dir0=[Ascending], dir1=[Ascending])'
'  ProjectRel(EMPNOA=[$0], EMPNOB=[$1])'
'    JoinRel(condition=[AND(=($0, $1), >($0, $1))], joinType=[right])'
'      TableAccessRel(table=[[LOCALDB, LHX, LHXEMPS5]])'
'      ProjectRel(EMPNOB=[$0])'
'        FilterRel(condition=[>($0, 0)])'
'          TableAccessRel(table=[[LOCALDB, LHX, LHXEMPS6]])'
> 
> -- outer join on filter can not be evaluated as post filter
> -- this should report an error
> explain plan without implementation for
> select * from lhxemps5 full outer join lhxemps6
> on lhxemps5.empnoA = lhxemps6.empnoB and
>    lhxemps5.empnoA > lhxemps6.empnoB
> order by 1, 2;
'column0'
'SortRel(sort0=[$0], sort1=[$1], dir0=[Ascending], dir1=[Ascending])'
'  ProjectRel(EMPNOA=[$0], EMPNOB=[$1])'
'    JoinRel(condition=[AND(=($0, $1), >($0, $1))], joinType=[full])'
'      TableAccessRel(table=[[LOCALDB, LHX, LHXEMPS5]])'
'      TableAccessRel(table=[[LOCALDB, LHX, LHXEMPS6]])'
> 
> ---------------------------------------------------
> -- test "is not distinct from" as join condition --
> ---------------------------------------------------
> explain plan for
> select * from lhxemps, lhxdepts
> where lhxemps.deptno is not distinct from lhxdepts.deptnoA;
'column0'
'FennelToIteratorConverter'
'  FennelNestedLoopJoinRel(joinType=[INNER], leftJoinKeys=[[2]], joinKeyParamIds=[[1]])'
'    LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[IS NULL($t2)], expr#4=[IS NULL($t0)], expr#5=[=($t2, $t0)], expr#6=[CASE($t3, $t4, $t4, $t3, $t5)], expr#7=[CAST($t6):BOOLEAN NOT NULL], proj#0..1=[{exprs}], $condition=[$t7])'
'        FennelToIteratorConverter'
'          FennelReshapeRel(projection=[[0, 1]], dynamicParameters=[[1]], paramCompareOffsets=[[-1]], outputRowType=[RecordType(INTEGER DEPTNOA, INTEGER DEPTNOB, INTEGER DEPTNO) NOT NULL])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHXDEPTS$DEPTNOB]])'
> 
> --------------------
> -- hash aggregate --
> --------------------
> 
> -- make sure nulls are in the same group
> truncate table lhxemps;
> insert into lhxemps values (10, NULL, null);
> insert into lhxemps values (20, 'Lance', null);
> insert into lhxemps values (30, NULL, null);
> 
> explain plan for
> select ename from lhxemps group by ename order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxAggRel(groupCount=[1])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
> 
> select ename from lhxemps group by ename order by 1;
'ENAME'
''
'Lance'
> 
> truncate table lhxemps;
> insert into lhxemps select empno, name, deptno from sales.emps;
> 
> explain plan for
> select deptno from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxAggRel(groupCount=[1])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select deptno from lhxemps group by deptno order by 1;
'DEPTNO'
'10'
'20'
'40'
> 
> explain plan for
> select distinct deptno from lhxemps order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxAggRel(groupCount=[1])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select distinct deptno from lhxemps order by 1;
'DEPTNO'
'10'
'20'
'40'
> 
> explain plan for
> select count(deptno) from lhxemps;
'column0'
'FennelToIteratorConverter'
'  FennelAggRel(groupCount=[0], EXPR$0=[COUNT(0)])'
'    LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select count(deptno) from lhxemps;
'EXPR$0'
'4'
> 
> explain plan for
> select count(empno) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT NOT NULL EXPR$0) NOT NULL])'
'      LhxAggRel(groupCount=[1], EXPR$0=[COUNT(1)])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2, 0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO]])'
> 
> select count(empno) from lhxemps group by deptno order by 1;
'EXPR$0'
'1'
'1'
'2'
> 
> explain plan for
> select count(distinct empno) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT NOT NULL EXPR$0) NOT NULL])'
'      LhxAggRel(groupCount=[1], EXPR$0=[COUNT(1)])'
'        LhxAggRel(groupCount=[2])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2, 0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO]])'
> 
> select count(distinct empno) from lhxemps group by deptno order by 1;
'EXPR$0'
'1'
'1'
'2'
> 
> explain plan for
> select count(*) from lhxemps;
'column0'
'FennelToIteratorConverter'
'  FennelAggRel(groupCount=[0], EXPR$0=[COUNT()])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0=[{inputs}], expr#1=[true], $f0=[$t1])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select count(*) from lhxemps;
'EXPR$0'
'4'
> 
> explain plan for
> select count(*) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT NOT NULL EXPR$0) NOT NULL])'
'      LhxAggRel(groupCount=[1], EXPR$0=[COUNT()])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select count(*) from lhxemps group by deptno order by 1;
'EXPR$0'
'1'
'1'
'2'
> 
> -- make sure empty single group produces correct result
> truncate table lhxemps;
> 
> explain plan for
> select count(*) from lhxemps;
'column0'
'FennelToIteratorConverter'
'  FennelAggRel(groupCount=[0], EXPR$0=[COUNT()])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0=[{inputs}], expr#1=[true], $f0=[$t1])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select count(*) from lhxemps;
'EXPR$0'
'0'
> 
> explain plan for
> select count(*) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT NOT NULL EXPR$0) NOT NULL])'
'      LhxAggRel(groupCount=[1], EXPR$0=[COUNT()])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO]])'
> 
> select count(*) from lhxemps group by deptno order by 1;
'EXPR$0'
> 
> -- make sure the hash table handles partial aggregate of increasing size
> truncate table lhxemps;
> insert into lhxemps values(100, 'a', 20);
> insert into lhxemps values(100, 'ab', 20);
> insert into lhxemps values(100, 'abc', 20);
> insert into lhxemps values(100, 'abcd', 20);
> insert into lhxemps values(100, 'abcde', 20);
> insert into lhxemps values(100, 'abcdef', 20);
> 
> explain plan for select max(ename) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" EXPR$0) NOT NULL])'
'      LhxAggRel(groupCount=[1], EXPR$0=[MAX(1)])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
> select max(ename) from lhxemps group by deptno order by 1;
'EXPR$0'
'abcdef'
> 
> -- testing run time error message for row length
> drop table lhxemps;
> create table lhxemps(empno char(2000), ename char(2000));
> 
> insert into lhxemps values('abc', 'abc');
> 
> explain plan for
> select empno, min(ename), max(ename) from lhxemps group by empno;
'column0'
'FennelToIteratorConverter'
'  LhxAggRel(groupCount=[1], EXPR$1=[MIN(1)], EXPR$2=[MAX(1)])'
'    LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHXEMPS$ENAME]])'
> 
> select empno, min(ename), max(ename) from lhxemps group by empno;
Error: Row size (6017 bytes) exceeds maximum (4092 bytes); row data:  [ 'abc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ', 'abc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ', 'abc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ' ] (state=,code=0)
> 
> -----------------------------
> -- aggregating NULL values --
> -----------------------------
> create table emps1(
>     ename1 varchar(20))
> server sys_column_store_data_server;
> 
> insert into emps1 values(NULL);
> insert into emps1 values(NULL);
> 
> explain plan for select ename1 from emps1 group by ename1;
'column0'
'FennelToIteratorConverter'
'  LhxAggRel(groupCount=[1])'
'    LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
> explain plan for select distinct ename1 from emps1;
'column0'
'FennelToIteratorConverter'
'  LhxAggRel(groupCount=[1])'
'    LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
> explain plan for select count(*) from emps1 group by ename1;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT NOT NULL EXPR$0) NOT NULL])'
'    LhxAggRel(groupCount=[1], EXPR$0=[COUNT()])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
> explain plan for select count(ename1) from emps1 group by ename1;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(BIGINT NOT NULL EXPR$0) NOT NULL])'
'    LhxAggRel(groupCount=[1], EXPR$0=[COUNT(0)])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
> explain plan for select count(distinct ename1) from emps1;
'column0'
'FennelToIteratorConverter'
'  FennelAggRel(groupCount=[0], EXPR$0=[COUNT(0)])'
'    LhxAggRel(groupCount=[1])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
> 
> select ename1 from emps1 group by ename1;
'ENAME1'
''
> select distinct ename1 from emps1;
'ENAME1'
''
> select count(*) from emps1 group by ename1;
'EXPR$0'
'2'
> select count(ename1) from emps1 group by ename1;
'EXPR$0'
'0'
> select count(distinct ename1) from emps1;
'EXPR$0'
'0'
> 
> --------------------
> -- Hash Semi Join --
> --------------------
> create table emps2(
>     ename2 varchar(20))
> server sys_column_store_data_server;
> 
> insert into emps1 values('abc');
> insert into emps1 values('abc');
> insert into emps1 values('def');
> insert into emps2 values(NULL);
> insert into emps2 values('abc');
> insert into emps2 values('abc');
> 
> explain plan for
> select ename1 from emps1
> where ename1 in (select ename2 from emps2)
> order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME1) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFTSEMI])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, EMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS2$ENAME2]])'
> 
> select ename1 from emps1
> where ename1 in (select ename2 from emps2)
> order by 1;
'ENAME1'
'abc'
'abc'
> 
> explain plan for
> select upper(ename1) from emps1
> where ename1 in (select ename2 from emps2)
> order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], EXPR$0=[$t1])'
'        FennelToIteratorConverter'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFTSEMI])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, EMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS2$ENAME2]])'
> 
> select upper(ename1) from emps1
> where ename1 in (select ename2 from emps2)
> order by 1;
'EXPR$0'
'ABC'
'ABC'
> 
> explain plan for
> select ename1 from emps1
> where ename1 in (select upper(ename2) from emps2)
> order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME1) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFTSEMI])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], EXPR$0=[$t1])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, EMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS2$ENAME2]])'
> 
> explain plan for
> select ename1 from emps1
> where upper(ename1) in (select upper(ename2) from emps2)
> order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME1) NOT NULL])'
'      LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[LEFTSEMI])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], proj#0..1=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, EMPS1]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS1$ENAME1]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], EXPR$0=[$t1])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LHX, EMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$EMPS2$ENAME2]])'
> 
> -----------------------------------------------------
> -- LDB-144
> -- removed an incorrect assert in LhxHashGenerator --
> -- check that the following query no longer fails  --
> -----------------------------------------------------
> create table A(a int not null);
> create table B(b int not null);
> create table C(c int not null);
> insert into A values (1), (2), (3);
> insert into B values (2), (3), (4);
> insert into C values (3), (4), (5);
> 
> explain plan for
> select * from A right outer join (select * from B inner join C on b = c) on a = b and a = c order by a;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 0, 1]], outputRowType=[RecordType(INTEGER A, INTEGER NOT NULL B, INTEGER NOT NULL C) NOT NULL])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[0, 0]], joinType=[LEFT])'
'        LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, B]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$B$B]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, C]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$C$C]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, A]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$A$A]])'
> 
> select * from A right outer join (select * from B inner join C on b = c) on a = b and a = c order by a;
'A','B','C'
'','4','4'
'3','3','3'
> 
> drop table A;
> drop table B;
> drop table C;
> 
> -- LER-6819
> create table tab(a int, b int, c int);
> insert into tab values(1,2,3),(1,2,4);
> create view vtab(a,b,c) as
>     select coalesce(t2.a, t1.a), coalesce(t2.b, t1.b), coalesce(t2.c, t1.c)
>         from tab t1, tab t2 where t1.a = t2.a;
> !set outputformat table
> select * from vtab where a = 1 and b = 2 and c = 3 order by a, b, c; 
+----+----+----+
| A  | B  | C  |
+----+----+----+
| 1  | 2  | 3  |
| 1  | 2  | 3  |
+----+----+----+
> 
> --------------
> -- Clean up --
> --------------
> !set outputformat table
> alter session implementation set default;
> drop schema lhx cascade;
> 
> !quit
