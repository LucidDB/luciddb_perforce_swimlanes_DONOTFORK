0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> -- LucidDB SQL test for Hash Join and Hash Agg --
0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------------------------------------
0: jdbc:farrago:> -- non LDB personality uses cartesian product --
0: jdbc:farrago:> ------------------------------------------------
0: jdbc:farrago:> create schema lhx;
0: jdbc:farrago:> set schema 'lhx';
0: jdbc:farrago:> set path 'lhx';
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxemps(
. . . . . . . . >     empno integer not null,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts(
. . . . . . . . >     deptnoA integer)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxdepts select deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> select * from lhxemps order by 1;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> select * from lhxdepts order by 1;
'DEPTNOA'
'10'
'20'
'20'
'40'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..3=[{inputs}], expr#4=[=($t2, $t3)], proj#0..3=[{exprs}], $condition=[$t4])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA'
'100','Fred','10','10'
'100','Fred','10','10'
'110','Eric','20','20'
'110','Eric','20','20'
'110','Eric','20','20'
'110','Eric','20','20'
'110','John','40','40'
'110','John','40','40'
'120','Wilma','20','20'
'120','Wilma','20','20'
'120','Wilma','20','20'
'120','Wilma','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Clean up
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> drop schema lhx cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------------------------
0: jdbc:farrago:> -- LDB personality uses hash join --
0: jdbc:farrago:> ------------------------------------
0: jdbc:farrago:> create schema lhx;
0: jdbc:farrago:> set schema 'lhx';
0: jdbc:farrago:> set path 'lhx';
0: jdbc:farrago:> 
0: jdbc:farrago:> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxemps(
. . . . . . . . >     empno integer not null,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts(
. . . . . . . . >     deptnoA integer,
. . . . . . . . >     deptnoB integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts2(
. . . . . . . . >     deptnoC integer,
. . . . . . . . >     deptnoD integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts3(
. . . . . . . . >     deptnoE integer,
. . . . . . . . >     deptnoF integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts4(
. . . . . . . . >     deptnoG integer,
. . . . . . . . >     deptnoH integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxdepts select deptno, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxdepts2 select deptno, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxdepts3 select deptno, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxdepts4 select deptno, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> select * from lhxemps order by 1;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> select * from lhxdepts order by 1;
'DEPTNOA','DEPTNOB'
'10','10'
'20','20'
'20','20'
'40','40'
0: jdbc:farrago:> select * from lhxdepts2 order by 1;
'DEPTNOC','DEPTNOD'
'10','10'
'20','20'
'20','20'
'40','40'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB'
'100','Fred','10','10','10'
'100','Fred','10','10','10'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','John','40','40','40'
'110','John','40','40','40'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- test hash join implementation for big IN
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select ename from lhxemps
. . . . . . . . > where empno in 
. . . . . . . . > (110, 110, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
. . . . . . . . > order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..2=[{inputs}], ENAME=[$t1])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LhxAggRel(groupCount=[1])'
'          FennelValuesRel(tuples=[[{ 110 }, { 110 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select ename from lhxemps
. . . . . . . . > where empno in 
. . . . . . . . > (110, 110, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
. . . . . . . . > order by ename;
'ENAME'
'Eric'
'Eric'
'John'
'John'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- this query still uses cartesian product
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA + 1
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..4=[{inputs}], expr#5=[1], expr#6=[+($t3, $t5)], expr#7=[=($t2, $t6)], proj#0..4=[{exprs}], $condition=[$t7])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- multiple conditions between the same pair of tables
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA and lhxemps.deptno = lhxdepts.deptnoB
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..4=[{inputs}], EMPNO=[$t2], ENAME=[$t3], DEPTNO=[$t4], DEPTNOA=[$t0], DEPTNOB=[$t1])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[2, 2]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA and lhxemps.deptno = lhxdepts.deptnoB
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB'
'100','Fred','10','10','10'
'100','Fred','10','10','10'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','John','40','40','40'
'110','John','40','40','40'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- now try two joins
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts, lhxdepts2
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxdepts.deptnoA = lhxdepts2.deptnoC
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[INNER])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOC, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOD]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts, lhxdepts2
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxdepts.deptnoA = lhxdepts2.deptnoC
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB','DEPTNOC','DEPTNOD'
'100','Fred','10','10','10','10','10'
'100','Fred','10','10','10','10','10'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','John','40','40','40','40','40'
'110','John','40','40','40','40','40'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- four joins
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts, lhxdepts2, lhxdepts3, lhxdepts4
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxemps.deptno = lhxdepts2.deptnoC
. . . . . . . . >     and lhxemps.deptno = lhxdepts3.deptnoF and lhxemps.deptno = lhxdepts4.deptnoG
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'        LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'          LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOC, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOD]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS3$DEPTNOE, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS3$DEPTNOF]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS4$DEPTNOG, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS4$DEPTNOH]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts, lhxdepts2, lhxdepts3, lhxdepts4
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxemps.deptno = lhxdepts2.deptnoC
. . . . . . . . >     and lhxemps.deptno = lhxdepts3.deptnoF and lhxemps.deptno = lhxdepts4.deptnoG
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB','DEPTNOC','DEPTNOD','DEPTNOE','DEPTNOF','DEPTNOG','DEPTNOH'
'100','Fred','10','10','10','10','10','10','10','10','10'
'100','Fred','10','10','10','10','10','10','10','10','10'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','John','40','40','40','40','40','40','40','40','40'
'110','John','40','40','40','40','40','40','40','40','40'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- only identical types are recognized and can use hash join
0: jdbc:farrago:> create table lhxemps2(
. . . . . . . . >     enameA varchar(40))
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps2 select name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps2 order by 1;
'ENAMEA'
'Eric'
'Fred'
'John'
'Wilma'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps, lhxemps2
. . . . . . . . > where lhxemps.ename = lhxemps2.enameA
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS2$ENAMEA]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxemps2
. . . . . . . . > where lhxemps.ename = lhxemps2.enameA
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEA'
'100','Fred','10','Fred'
'100','Fred','10','Fred'
'110','Eric','20','Eric'
'110','Eric','20','Eric'
'110','John','40','John'
'110','John','40','John'
'120','Wilma','20','Wilma'
'120','Wilma','20','Wilma'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- trailing blanks are insignificant when joining two
0: jdbc:farrago:> -- character types.
0: jdbc:farrago:> -- currently since hash join does not do type casting,
0: jdbc:farrago:> -- if join keys have different types, do not use hash join
0: jdbc:farrago:> create table lhxemps3(
. . . . . . . . >     enameB char(20))
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps3 select name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 order by 1;
'ENAMEB'
'Eric                '
'Fred                '
'John                '
'Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps, lhxemps3
. . . . . . . . > where lhxemps.ename = lhxemps3.enameB
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..3=[{inputs}], expr#4=[=($t1, $t3)], proj#0..3=[{exprs}], $condition=[$t4])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxemps3
. . . . . . . . > where lhxemps.ename = lhxemps3.enameB
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEB'
'100','Fred','10','Fred                '
'100','Fred','10','Fred                '
'110','Eric','20','Eric                '
'110','Eric','20','Eric                '
'110','John','40','John                '
'110','John','40','John                '
'120','Wilma','20','Wilma               '
'120','Wilma','20','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> -- column values containing null
0: jdbc:farrago:> -- nulls should not join with nulls of a different type
0: jdbc:farrago:> -- note a join with keys of different types does not use hash join
0: jdbc:farrago:> insert into lhxemps2 values(null);
0: jdbc:farrago:> insert into lhxemps3 values(null);
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps2, lhxemps3
. . . . . . . . > where lhxemps2.enameA = lhxemps3.enameB
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[=($t0, $t1)], proj#0..1=[{exprs}], $condition=[$t2])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS2$ENAMEA]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps2, lhxemps3
. . . . . . . . > where lhxemps2.enameA = lhxemps3.enameB
. . . . . . . . > order by 1, 2;
'ENAMEA','ENAMEB'
'Eric','Eric                '
'Fred','Fred                '
'John','John                '
'Wilma','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> -- nulls should not join with nulls of the same type either
0: jdbc:farrago:> create table lhxemps4(
. . . . . . . . >     enameC char(20))
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps4 select name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps4 values(null);
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps4 order by 1;
'ENAMEC'
''
'Eric                '
'Fred                '
'John                '
'Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3, lhxemps4
. . . . . . . . > where lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3, lhxemps4
. . . . . . . . > where lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'ENAMEB','ENAMEC'
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps3 values('Leo');
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps4 values('Adel');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join types
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 left outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 left outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'ENAMEB','ENAMEC'
'',''
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Leo                 ',''
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 right outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[RIGHT])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 right outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'ENAMEB','ENAMEC'
'',''
'','Adel                '
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 full outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[FULL])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 full outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1, 2;
'ENAMEB','ENAMEC'
'',''
'',''
'','Adel                '
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Leo                 ',''
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> -- FIXME: currently only join conditions referencing input fields are
0: jdbc:farrago:> -- recognized by hash join; cast() is produced by the input so the join
0: jdbc:farrago:> -- condition is not recognized.
0: jdbc:farrago:> -- In future, using an explicit cast operator will make the joinkeys
0: jdbc:farrago:> -- have same data types. HashJoin can be used.
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 inner join lhxemps4
. . . . . . . . > on lhxemps3.enameB = cast(lhxemps4.enameC as char(20))
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t1):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#3=[=($t0, $t2)], proj#0..1=[{exprs}], $condition=[$t3])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- not null types are compatible with hash outer joins
0: jdbc:farrago:> create table lhxemps5(
. . . . . . . . >     enameB char(20) not null)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxemps6(
. . . . . . . . >     enameC char(20) not null)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps5 values('Leo');
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps6 values('Adel');
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps5 full outer join lhxemps6
. . . . . . . . > on lhxemps5.enameB = lhxemps6.enameC
. . . . . . . . > order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[FULL])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS5$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS6$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps5 full outer join lhxemps6
. . . . . . . . > on lhxemps5.enameB = lhxemps6.enameC
. . . . . . . . > order by 1, 2;
'ENAMEB','ENAMEC'
'','Adel                '
'Leo                 ',''
0: jdbc:farrago:> 
0: jdbc:farrago:> --------------------
0: jdbc:farrago:> -- hash aggregate --
0: jdbc:farrago:> --------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> truncate table lhxemps;
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select deptno from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0=[{inputs}], DEPTNO=[$t0])'
'      LhxAggRel(groupCount=[1])'
'        FennelRenameRel(fieldNames=[[$f0]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select deptno from lhxemps group by deptno order by 1;
'DEPTNO'
'10'
'20'
'40'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select distinct deptno from lhxemps order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxAggRel(groupCount=[1])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select distinct deptno from lhxemps order by 1;
'DEPTNO'
'10'
'20'
'40'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(deptno) from lhxemps;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[COUNT(0)])'
'      FennelRenameRel(fieldNames=[[$f0]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(deptno) from lhxemps;
'EXPR$0'
'4'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(empno) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], EXPR$0=[$t1])'
'      LhxAggRel(groupCount=[1], agg#0=[COUNT(1)])'
'        FennelRenameRel(fieldNames=[[$f0, $f1]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2, 0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(empno) from lhxemps group by deptno order by 1;
'EXPR$0'
'1'
'1'
'2'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(distinct empno) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], EXPR$0=[$t1])'
'      LhxAggRel(groupCount=[1], agg#0=[COUNT(1)])'
'        LhxAggRel(groupCount=[2])'
'          FennelRenameRel(fieldNames=[[$f0, $f1]])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2, 0]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(distinct empno) from lhxemps group by deptno order by 1;
'EXPR$0'
'1'
'1'
'2'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(*) from lhxemps;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[COUNT()])'
'      FennelCalcRel(expr#0=[{inputs}], expr#1=[true], $f0=[$t1])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(*) from lhxemps;
'EXPR$0'
'4'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(*) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], EXPR$0=[$t1])'
'      LhxAggRel(groupCount=[1], agg#0=[COUNT()])'
'        FennelRenameRel(fieldNames=[[$f0]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(*) from lhxemps group by deptno order by 1;
'EXPR$0'
'1'
'1'
'2'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure empty single group produces correct result
0: jdbc:farrago:> truncate table lhxemps;
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(*) from lhxemps;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[COUNT()])'
'      FennelCalcRel(expr#0=[{inputs}], expr#1=[true], $f0=[$t1])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(*) from lhxemps;
'EXPR$0'
'0'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(*) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], EXPR$0=[$t1])'
'      LhxAggRel(groupCount=[1], agg#0=[COUNT()])'
'        FennelRenameRel(fieldNames=[[$f0]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(*) from lhxemps group by deptno order by 1;
'EXPR$0'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure the hash table handles partial aggregate of increasing size
0: jdbc:farrago:> truncate table lhxemps;
0: jdbc:farrago:> insert into lhxemps values(100, 'a', 20);
0: jdbc:farrago:> insert into lhxemps values(100, 'ab', 20);
0: jdbc:farrago:> insert into lhxemps values(100, 'abc', 20);
0: jdbc:farrago:> insert into lhxemps values(100, 'abcd', 20);
0: jdbc:farrago:> insert into lhxemps values(100, 'abcde', 20);
0: jdbc:farrago:> insert into lhxemps values(100, 'abcdef', 20);
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for select max(ename) from lhxemps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], EXPR$0=[$t1])'
'      LhxAggRel(groupCount=[1], agg#0=[MAX(1)])'
'        FennelRenameRel(fieldNames=[[$f0, $f1]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[2, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
0: jdbc:farrago:> select max(ename) from lhxemps group by deptno order by 1;
'EXPR$0'
'abcdef'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- testing run time error message for row length
0: jdbc:farrago:> drop table lhxemps;
0: jdbc:farrago:> create table lhxemps(empno char(2000), ename char(2000));
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps values('abc', 'abc');
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select empno, min(ename), max(ename) from lhxemps group by empno;
'column0'
'IterCalcRel(expr#0..2=[{inputs}], proj#0..2=[{exprs}])'
'  FennelToIteratorConverter'
'    LhxAggRel(groupCount=[1], agg#0=[MIN(1)], agg#1=[MAX(1)])'
'      FennelRenameRel(fieldNames=[[$f0, $f1]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select empno, min(ename), max(ename) from lhxemps group by empno;
Error: Row size (6013 bytes) exceeds maximum (4092 bytes); row data:  [ 'abc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ', 'abc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ', 'abc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ' ] (state=,code=0)
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------------------------
0: jdbc:farrago:> -- the following are from agg.sql --
0: jdbc:farrago:> ------------------------------------
0: jdbc:farrago:> set schema 'sales';
0: jdbc:farrago:> 
0: jdbc:farrago:> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(*) from depts;
'EXPR$0'
'3'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(city) from emps;
'EXPR$0'
'2'
0: jdbc:farrago:> 
0: jdbc:farrago:> select count(city) from emps where empno > 100000;
'EXPR$0'
'0'
0: jdbc:farrago:> 
0: jdbc:farrago:> select sum(deptno) from depts;
'EXPR$0'
'60'
0: jdbc:farrago:> 
0: jdbc:farrago:> select sum(deptno) from depts where deptno > 100000;
'EXPR$0'
''
0: jdbc:farrago:> 
0: jdbc:farrago:> select max(deptno) from depts;
'EXPR$0'
'30'
0: jdbc:farrago:> 
0: jdbc:farrago:> select min(deptno) from depts;
'EXPR$0'
'10'
0: jdbc:farrago:> 
0: jdbc:farrago:> select avg(deptno) from depts;
'EXPR$0'
'20'
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------
0: jdbc:farrago:> -- group bys
0: jdbc:farrago:> ------------
0: jdbc:farrago:> 
0: jdbc:farrago:> select deptno, count(*) from emps group by deptno order by 1;
'DEPTNO','EXPR$1'
'10','1'
'20','2'
'40','1'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Issue the same statement again to make sure LhxAggStream
0: jdbc:farrago:> -- is in good state when reopened
0: jdbc:farrago:> select deptno, count(*) from emps group by deptno order by 1;
'DEPTNO','EXPR$1'
'10','1'
'20','2'
'40','1'
0: jdbc:farrago:> 
0: jdbc:farrago:> select d.name, count(*) from emps e, depts d
. . . . . . . . >     where d.deptno = e.deptno group by d.name order by 1;
'NAME','EXPR$1'
'Marketing','2'
'Sales','1'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Test group by key where key value could be NULL
0: jdbc:farrago:> select deptno, gender, min(age), max(age) from emps
. . . . . . . . >     group by deptno, gender order by 1, 2;
'DEPTNO','GENDER','EXPR$2','EXPR$3'
'10','','25','25'
'20','F','50','50'
'20','M','80','80'
'40','M','',''
0: jdbc:farrago:> 
0: jdbc:farrago:> select sum(age) from emps group by deptno order by 1;
'EXPR$0'
''
'25'
'130'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Test where input stream is empty
0: jdbc:farrago:> select deptno, count(*) from emps where deptno < 0 group by deptno order by 1;
'DEPTNO','EXPR$1'
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> -- verify plans
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(*) from depts;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[COUNT()])'
'      FennelCalcRel(expr#0..1=[{inputs}], expr#2=[true], $f0=[$t2])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select count(city) from emps;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[COUNT(0)])'
'      FennelRenameRel(fieldNames=[[$f0]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[4]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select sum(deptno) from depts;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[SUM(0)])'
'      FennelRenameRel(fieldNames=[[$f0]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select max(deptno) from depts;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[MAX(0)])'
'      FennelRenameRel(fieldNames=[[$f0]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select min(deptno) from depts;
'column0'
'IterCalcRel(expr#0=[{inputs}], EXPR$0=[$t0])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[MIN(0)])'
'      FennelRenameRel(fieldNames=[[$f0]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select avg(deptno) from depts;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[/($t0, $t1)], expr#3=[CAST($t2):INTEGER], EXPR$0=[$t3])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[SUM(0)], agg#1=[COUNT(0)])'
'      FennelRenameRel(fieldNames=[[$f0]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan without implementation for
. . . . . . . . > select deptno,max(name) from sales.emps group by deptno order by 1;
'column0'
'SortRel(sort0=[$0])'
'  ProjectRel(DEPTNO=[$0], EXPR$1=[$1])'
'    AggregateRel(groupCount=[1], agg#0=[MAX(1)])'
'      ProjectRel($f0=[$2], $f1=[$1])'
'        TableAccessRel(table=[[LOCALDB, SALES, EMPS]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -----------------------------
0: jdbc:farrago:> -- verify plans for group bys
0: jdbc:farrago:> -----------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select deptno, count(*) from emps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], proj#0..1=[{exprs}])'
'      LhxAggRel(groupCount=[1], agg#0=[COUNT()])'
'        FennelRenameRel(fieldNames=[[$f0]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select d.name, count(*) from emps e, depts d
. . . . . . . . >     where d.deptno = e.deptno group by d.name order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], proj#0..1=[{exprs}])'
'      LhxAggRel(groupCount=[1], agg#0=[COUNT()])'
'        FennelCalcRel(expr#0..2=[{inputs}], $f0=[$t2])'
'          LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2]], index=[EMPS_UX], preserveOrder=[false])'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select deptno, gender, min(age), max(age) from emps
. . . . . . . . >     group by deptno, gender order by 1, 2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..3=[{inputs}], proj#0..3=[{exprs}])'
'      LhxAggRel(groupCount=[2], agg#0=[MIN(2)], agg#1=[MAX(2)])'
'        FennelRenameRel(fieldNames=[[$f0, $f1, $f2]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 3, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select sum(age) from emps group by deptno order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], EXPR$0=[$t1])'
'      LhxAggRel(groupCount=[1], agg#0=[SUM(1)])'
'        FennelRenameRel(fieldNames=[[$f0, $f1]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> --------------
0: jdbc:farrago:> -- Clean up --
0: jdbc:farrago:> --------------
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> alter session implementation set default;
0: jdbc:farrago:> drop schema lhx cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> !quit
