0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> -- LucidDB SQL test for Hash Join and Hash Agg --
0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------------------------------------
0: jdbc:farrago:> -- non LDB personality uses cartesian product --
0: jdbc:farrago:> ------------------------------------------------
0: jdbc:farrago:> create schema lhx;
0: jdbc:farrago:> set schema 'lhx';
0: jdbc:farrago:> set path 'lhx';
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxemps(
. . . . . . . . >     empno integer not null,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts(
. . . . . . . . >     deptnoA integer)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxdepts select deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> select * from lhxemps order by 1;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> select * from lhxdepts order by 1;
'DEPTNOA'
'10'
'20'
'20'
'40'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..3=[{inputs}], expr#4=[=($t2, $t3)], proj#0..3=[{exprs}], $condition=[$t4])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA'
'100','Fred','10','10'
'100','Fred','10','10'
'110','Eric','20','20'
'110','Eric','20','20'
'110','Eric','20','20'
'110','Eric','20','20'
'110','John','40','40'
'110','John','40','40'
'120','Wilma','20','20'
'120','Wilma','20','20'
'120','Wilma','20','20'
'120','Wilma','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Clean up
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> drop schema lhx cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------------------------------
0: jdbc:farrago:> -- LDB personality uses hash join --
0: jdbc:farrago:> ------------------------------------
0: jdbc:farrago:> create schema lhx;
0: jdbc:farrago:> set schema 'lhx';
0: jdbc:farrago:> set path 'lhx';
0: jdbc:farrago:> 
0: jdbc:farrago:> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxemps(
. . . . . . . . >     empno integer not null,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts(
. . . . . . . . >     deptnoA integer,
. . . . . . . . >     deptnoB integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts2(
. . . . . . . . >     deptnoC integer,
. . . . . . . . >     deptnoD integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts3(
. . . . . . . . >     deptnoE integer,
. . . . . . . . >     deptnoF integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxdepts4(
. . . . . . . . >     deptnoG integer,
. . . . . . . . >     deptnoH integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxdepts select deptno, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxdepts2 select deptno, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxdepts3 select deptno, deptno from sales.emps;
0: jdbc:farrago:> insert into lhxdepts4 select deptno, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> select * from lhxemps order by 1;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> select * from lhxdepts order by 1;
'DEPTNOA','DEPTNOB'
'10','10'
'20','20'
'20','20'
'40','40'
0: jdbc:farrago:> select * from lhxdepts2 order by 1;
'DEPTNOC','DEPTNOD'
'10','10'
'20','20'
'20','20'
'40','40'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB'
'100','Fred','10','10','10'
'100','Fred','10','10','10'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','John','40','40','40'
'110','John','40','40','40'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- test hash join implementation for big IN
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select ename from lhxemps
. . . . . . . . > where empno in 
. . . . . . . . > (110, 110, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
. . . . . . . . > order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..2=[{inputs}], ENAME=[$t1])'
'      LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'        FennelCalcRel(expr#0..1=[{inputs}], expr#2=[true], expr#3=[IS TRUE($t2)], proj#0..1=[{exprs}], $condition=[$t3])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        FennelAggRel(groupCount=[1])'
'          FennelSortRel(key=[[0]], discardDuplicates=[false])'
'            FennelValuesRel(tuples=[[{ 110 }, { 110 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }, { 1 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select ename from lhxemps
. . . . . . . . > where empno in 
. . . . . . . . > (110, 110, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
. . . . . . . . > order by ename;
'ENAME'
'Eric'
'Eric'
'John'
'John'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- this query still uses cartesian product
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA + 1
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..4=[{inputs}], expr#5=[1], expr#6=[+($t3, $t5)], expr#7=[=($t2, $t6)], proj#0..4=[{exprs}], $condition=[$t7])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- multiple conditions between the same pair of tables
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA and lhxemps.deptno = lhxdepts.deptnoB
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..4=[{inputs}], EMPNO=[$t2], ENAME=[$t3], DEPTNO=[$t4], DEPTNOA=[$t0], DEPTNOB=[$t1])'
'      LhxJoinRel(leftKeys=[[0, 1]], rightKeys=[[2, 2]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoA and lhxemps.deptno = lhxdepts.deptnoB
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB'
'100','Fred','10','10','10'
'100','Fred','10','10','10'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','Eric','20','20','20'
'110','John','40','40','40'
'110','John','40','40','40'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
'120','Wilma','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- now try two joins
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts, lhxdepts2
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxdepts.deptnoA = lhxdepts2.deptnoC
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[3]], rightKeys=[[0]], joinType=[INNER])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOC, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOD]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts, lhxdepts2
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxdepts.deptnoA = lhxdepts2.deptnoC
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB','DEPTNOC','DEPTNOD'
'100','Fred','10','10','10','10','10'
'100','Fred','10','10','10','10','10'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','Eric','20','20','20','20','20'
'110','John','40','40','40','40','40'
'110','John','40','40','40','40','40'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
'120','Wilma','20','20','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- four joins
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lhxemps, lhxdepts, lhxdepts2, lhxdepts3, lhxdepts4
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxemps.deptno = lhxdepts2.deptnoC
. . . . . . . . >     and lhxemps.deptno = lhxdepts3.deptnoF and lhxemps.deptno = lhxdepts4.deptnoG
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'        LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'          LhxJoinRel(leftKeys=[[2]], rightKeys=[[1]], joinType=[INNER])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'            LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOA, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS$DEPTNOB]])'
'          LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOC, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS2$DEPTNOD]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS3$DEPTNOE, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS3$DEPTNOF]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXDEPTS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXDEPTS4$DEPTNOG, SYS$CLUSTERED_INDEX$LHX$LHXDEPTS4$DEPTNOH]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxdepts, lhxdepts2, lhxdepts3, lhxdepts4
. . . . . . . . > where lhxemps.deptno = lhxdepts.deptnoB and lhxemps.deptno = lhxdepts2.deptnoC
. . . . . . . . >     and lhxemps.deptno = lhxdepts3.deptnoF and lhxemps.deptno = lhxdepts4.deptnoG
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','DEPTNOA','DEPTNOB','DEPTNOC','DEPTNOD','DEPTNOE','DEPTNOF','DEPTNOG','DEPTNOH'
'100','Fred','10','10','10','10','10','10','10','10','10'
'100','Fred','10','10','10','10','10','10','10','10','10'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','Eric','20','20','20','20','20','20','20','20','20'
'110','John','40','40','40','40','40','40','40','40','40'
'110','John','40','40','40','40','40','40','40','40','40'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
'120','Wilma','20','20','20','20','20','20','20','20','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- only identical types are recognized and can use hash join
0: jdbc:farrago:> create table lhxemps2(
. . . . . . . . >     enameA varchar(40))
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps2 select name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps2 order by 1;
'ENAMEA'
'Eric'
'Fred'
'John'
'Wilma'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps, lhxemps2
. . . . . . . . > where lhxemps.ename = lhxemps2.enameA
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[1]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS2$ENAMEA]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxemps2
. . . . . . . . > where lhxemps.ename = lhxemps2.enameA
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEA'
'100','Fred','10','Fred'
'100','Fred','10','Fred'
'110','Eric','20','Eric'
'110','Eric','20','Eric'
'110','John','40','John'
'110','John','40','John'
'120','Wilma','20','Wilma'
'120','Wilma','20','Wilma'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- trailing blanks are insignificant when joining two
0: jdbc:farrago:> -- character types.
0: jdbc:farrago:> -- currently since hash join does not do type casting,
0: jdbc:farrago:> -- if join keys have different types, do not use hash join
0: jdbc:farrago:> create table lhxemps3(
. . . . . . . . >     enameB char(20))
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps3 select name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 order by 1;
'ENAMEB'
'Eric                '
'Fred                '
'John                '
'Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps, lhxemps3
. . . . . . . . > where lhxemps.ename = lhxemps3.enameB
. . . . . . . . > order by empno, ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..3=[{inputs}], expr#4=[=($t1, $t3)], proj#0..3=[{exprs}], $condition=[$t4])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$EMPNO, SYS$CLUSTERED_INDEX$LHX$LHXEMPS$ENAME]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps, lhxemps3
. . . . . . . . > where lhxemps.ename = lhxemps3.enameB
. . . . . . . . > order by empno, ename;
'EMPNO','ENAME','DEPTNO','ENAMEB'
'100','Fred','10','Fred                '
'100','Fred','10','Fred                '
'110','Eric','20','Eric                '
'110','Eric','20','Eric                '
'110','John','40','John                '
'110','John','40','John                '
'120','Wilma','20','Wilma               '
'120','Wilma','20','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> -- column values containing null
0: jdbc:farrago:> -- nulls should not join with nulls of a different type
0: jdbc:farrago:> -- note a join with keys of different types does not use hash join
0: jdbc:farrago:> insert into lhxemps2 values(null);
0: jdbc:farrago:> insert into lhxemps3 values(null);
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps2, lhxemps3
. . . . . . . . > where lhxemps2.enameA = lhxemps3.enameB
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[=($t0, $t1)], proj#0..1=[{exprs}], $condition=[$t2])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS2]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS2$ENAMEA]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps2, lhxemps3
. . . . . . . . > where lhxemps2.enameA = lhxemps3.enameB
. . . . . . . . > order by 1;
'ENAMEA','ENAMEB'
'Eric','Eric                '
'Fred','Fred                '
'John','John                '
'Wilma','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> -- nulls should not join with nulls of the same type either
0: jdbc:farrago:> create table lhxemps4(
. . . . . . . . >     enameC char(20))
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps4 select name from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps4 values(null);
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps4 order by 1;
'ENAMEC'
''
'Eric                '
'Fred                '
'John                '
'Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3, lhxemps4
. . . . . . . . > where lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[INNER])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3, lhxemps4
. . . . . . . . > where lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'ENAMEB','ENAMEC'
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps3 values('Leo');
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps4 values('Adel');
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join types
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 left outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 left outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'ENAMEB','ENAMEC'
'',''
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Leo                 ',''
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 right outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[RIGHT])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 right outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'ENAMEB','ENAMEC'
'','Adel                '
'',''
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 full outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[FULL])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps3 full outer join lhxemps4
. . . . . . . . > on lhxemps3.enameB = lhxemps4.enameC
. . . . . . . . > order by 1;
'ENAMEB','ENAMEC'
'',''
'','Adel                '
'',''
'Eric                ','Eric                '
'Fred                ','Fred                '
'John                ','John                '
'Leo                 ',''
'Wilma               ','Wilma               '
0: jdbc:farrago:> 
0: jdbc:farrago:> -- FIXME: currently only join conditions referencing input fields are
0: jdbc:farrago:> -- recognized by hash join; cast() is produced by the input so the join
0: jdbc:farrago:> -- condition is not recognized.
0: jdbc:farrago:> -- In future, using an explicit cast operator will make the joinkeys
0: jdbc:farrago:> -- have same data types. HashJoin can be used.
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps3 inner join lhxemps4
. . . . . . . . > on lhxemps3.enameB = cast(lhxemps4.enameC as char(20))
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t1):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], expr#3=[=($t0, $t2)], proj#0..1=[{exprs}], $condition=[$t3])'
'      FennelCartesianProductRel(leftouterjoin=[false])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS3]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS3$ENAMEB]])'
'        LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS4]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS4$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- not null types are compatible with hash outer joins
0: jdbc:farrago:> create table lhxemps5(
. . . . . . . . >     enameB char(20) not null)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lhxemps6(
. . . . . . . . >     enameC char(20) not null)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps5 values('Leo');
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lhxemps6 values('Adel');
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lhxemps5 full outer join lhxemps6
. . . . . . . . > on lhxemps5.enameB = lhxemps6.enameC
. . . . . . . . > order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[FULL])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS5]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS5$ENAMEB]])'
'      LcsRowScanRel(table=[[LOCALDB, LHX, LHXEMPS6]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LHX$LHXEMPS6$ENAMEC]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lhxemps5 full outer join lhxemps6
. . . . . . . . > on lhxemps5.enameB = lhxemps6.enameC
. . . . . . . . > order by 1;
'ENAMEB','ENAMEC'
'','Adel                '
'Leo                 ',''
0: jdbc:farrago:> 
0: jdbc:farrago:> --------------
0: jdbc:farrago:> -- Clean up --
0: jdbc:farrago:> --------------
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> alter session implementation set default;
0: jdbc:farrago:> drop schema lhx cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> !quit
