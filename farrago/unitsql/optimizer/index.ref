> -- $Id$
> -- Test queries which make use of indexes
> 
> -- use Volcano for these because Hep can't do a very good job
> -- with many of the patterns, and it's a good workout for Volcano
> alter session implementation add jar sys_boot.sys_boot.volcano_plugin;
> 
> create schema oj;
> 
> create table oj.t1(i int not null primary key, j int unique);
> 
> create table oj.t2(i int not null primary key, j int unique);
> 
> insert into oj.t1 values (1,null), (2, 2), (3, 3);
> 
> insert into oj.t2 values (1,null), (2, 2), (4, 4);
> 
> create table oj.t3(v varchar(15) not null primary key);
> insert into oj.t3 
> values ('Mesmer'), ('Houdini'), ('Copperfield'), ('Mandrake');
> 
> create table oj.t4(i int not null primary key, j boolean unique);
> insert into oj.t4 values (1, null), (2, true), (3, false);
> 
> set schema 'sales';
> 
> -- force usage of Java calculator
> alter system set "calcVirtualMachine" = 'CALCVM_JAVA';
> 
> -- search unique clustered index
> select name from depts where deptno=20;
+------------+
|    NAME    |
+------------+
| Marketing  |
+------------+
> 
> select name from depts where deptno > 20 order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
+-----------+
> 
> select name from depts where deptno >= 20 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
> 
> select name from depts where deptno < 20 order by name;
+--------+
|  NAME  |
+--------+
| Sales  |
+--------+
> 
> select name from depts where deptno <= 20 order by name;
+------------+
|    NAME    |
+------------+
| Marketing  |
| Sales      |
+------------+
> 
> select name from depts where deptno between 20 and 30 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
> 
> select name from depts where deptno > 20 and deptno < 30 order by name;
+-------+
| NAME  |
+-------+
+-------+
> 
> select name from depts where deptno < 20 or deptno between 30 and 40 
> order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
| Sales     |
+-----------+
> 
> select name from depts where deptno in (20,30) order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
> 
> -- scaling
> select name from depts where deptno=20.00;
+------------+
|    NAME    |
+------------+
| Marketing  |
+------------+
> 
> -- scaling with rounding:  strictness change
> select name from depts where deptno > 19.6 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
> 
> -- scaling with rounding:  strictness change the other way
> select name from depts where deptno >= 20.1 order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
+-----------+
> 
> -- no match:  overflow
> select name from depts where deptno=20000000000000;
+-------+
| NAME  |
+-------+
+-------+
> 
> -- no match:  overflow
> select name from depts where deptno>20000000000000;
+-------+
| NAME  |
+-------+
+-------+
> 
> -- all match:  negative overflow
> select name from depts where deptno>-20000000000000 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
| Sales      |
+------------+
> 
> -- no match:  make sure truncation doesn't make it look like one
> select v from oj.t3 where v='Houdini                 xyz';
+----+
| V  |
+----+
+----+
> 
> -- no match for Houdini:  make sure truncation doesn't make it look like one
> select v from oj.t3 where v >= 'Houdini                 xyz'
> order by v;
+--------------+
|      V       |
+--------------+
| Mandrake     |
| Mesmer       |
+--------------+
> 
> -- match for Houdini:  make sure truncation doesn't obscure that
> select v from oj.t3 where v <= 'Houdini                 xyz'
> order by v;
+--------------+
|      V       |
+--------------+
| Copperfield  |
| Houdini      |
+--------------+
> 
> -- contradiction:  empty range
> select name from depts where deptno=20 and deptno=30;
+-------+
| NAME  |
+-------+
+-------+
> 
> -- search beyond end
> select name from depts where deptno > 50 order by name;
+-------+
| NAME  |
+-------+
+-------+
> 
> -- search before start
> select name from depts where deptno < 5 order by name;
+-------+
| NAME  |
+-------+
+-------+
> 
> -- search unique clustered index with a prefix key
> select name from emps where deptno=20 order by 1;
+--------+
|  NAME  |
+--------+
| Eric   |
| Wilma  |
+--------+
> 
> -- search unique clustered index with a prefix key and a non-indexable condition
> select name from emps where deptno=20 and gender='M';
+-------+
| NAME  |
+-------+
| Eric  |
+-------+
> 
> -- search unique unclustered index
> select name from emps where empid=3;
+-------+
| NAME  |
+-------+
| Eric  |
+-------+
> 
> -- project columns covered by clustered index
> select gender from emps order by 1;
+---------+
| GENDER  |
+---------+
|         |
| F       |
| M       |
| M       |
+---------+
> 
> -- project columns covered by an unclustered index
> select name from emps order by 1;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| John   |
| Wilma  |
+--------+
> select upper(name) from emps order by 1;
+---------+
| EXPR$0  |
+---------+
| ERIC    |
| FRED    |
| JOHN    |
| WILMA   |
+---------+
> 
> -- sort multiple columns covered by an unclustered index
> select name,gender,deptno,empno from emps order by 3,4;
+--------+---------+---------+--------+
|  NAME  | GENDER  | DEPTNO  | EMPNO  |
+--------+---------+---------+--------+
| Fred   |         | 10      | 100    |
| Eric   | M       | 20      | 110    |
| Wilma  | F       | 20      | 120    |
| John   | M       | 40      | 110    |
+--------+---------+---------+--------+
> 
> -- unique inner join via clustered index
> select depts.name as dname,emps.name as ename
> from emps inner join depts
> on emps.deptno=depts.deptno
> order by 1,2;
+------------+--------+
|   DNAME    | ENAME  |
+------------+--------+
| Marketing  | Eric   |
| Marketing  | Wilma  |
| Sales      | Fred   |
+------------+--------+
> 
> -- unique left outer join via clustered index
> select depts.name as dname,emps.name as ename
> from emps left outer join depts
> on emps.deptno=depts.deptno
> order by 1,2;
+------------+--------+
|   DNAME    | ENAME  |
+------------+--------+
|            | John   |
| Marketing  | Eric   |
| Marketing  | Wilma  |
| Sales      | Fred   |
+------------+--------+
> 
> -- left outer join via clustered index prefix
> select emps.name as ename,depts.name as dname
> from depts left outer join emps
> on depts.deptno=emps.deptno
> order by 2,1;
+--------+------------+
| ENAME  |   DNAME    |
+--------+------------+
|        | Accounts   |
| Eric   | Marketing  |
| Wilma  | Marketing  |
| Fred   | Sales      |
+--------+------------+
> 
> -- inner join via unclustered index
> select emps.name as ename,depts.name as dname
> from depts inner join emps
> on depts.deptno=emps.empid
> order by 2,1;
+--------+-----------+
| ENAME  |   DNAME   |
+--------+-----------+
| Fred   | Accounts  |
+--------+-----------+
> 
> -- left outer join via unclustered index
> select emps.name as ename,depts.name as dname
> from depts left outer join emps
> on depts.deptno=emps.empid
> order by 2,1;
+--------+------------+
| ENAME  |   DNAME    |
+--------+------------+
| Fred   | Accounts   |
|        | Marketing  |
|        | Sales      |
+--------+------------+
> 
> -- inner join on nullable key
> select e.name as ename,e.age,depts.name as dname
> from
> (select name,age - 20 as age from emps) e
> inner join depts on e.age = depts.deptno;
+--------+------+-----------+
| ENAME  | AGE  |   DNAME   |
+--------+------+-----------+
| Wilma  | 30   | Accounts  |
+--------+------+-----------+
> 
> -- outer join on nullable key
> select e.name as ename,e.age,depts.name as dname
> from
> (select name,age - 20 as age from emps) e
> left outer join depts on e.age = depts.deptno;
+--------+------+-----------+
| ENAME  | AGE  |   DNAME   |
+--------+------+-----------+
| Fred   | 5    |           |
| Eric   | 60   |           |
| Wilma  | 30   | Accounts  |
| John   |      |           |
+--------+------+-----------+
> 
> -- outer join with keys on both sides nullable
> select *
> from oj.t1 left outer join oj.t2
> on t1.j = t2.j;
+----+----+-----+-----+
| I  | J  | I0  | J0  |
+----+----+-----+-----+
| 1  |    |     |     |
| 2  | 2  | 2   | 2   |
| 3  | 3  |     |     |
+----+----+-----+-----+
> 
> -- index join which requires swapped join inputs
> select 
>     depts.name as dname,e.name as ename
> from 
>     depts 
> inner join 
>     (select name,age - 20 as age from emps) e
> on 
>     e.age=depts.deptno
> order by 1,2;
+-----------+--------+
|   DNAME   | ENAME  |
+-----------+--------+
| Accounts  | Wilma  |
+-----------+--------+
> 
> -- is null predicate
> select * from oj.t1 where j is null;
+----+----+
| I  | J  |
+----+----+
| 1  |    |
+----+----+
> select * from oj.t1 where not(j is null);
+----+----+
| I  | J  |
+----+----+
| 2  | 2  |
| 3  | 3  |
+----+----+
> 
> -- predicates on boolean
> select * from oj.t4 where j is true;
+----+-------+
| I  |   J   |
+----+-------+
| 2  | true  |
+----+-------+
> select * from oj.t4 where j is false;
+----+--------+
| I  |   J    |
+----+--------+
| 3  | false  |
+----+--------+
> select * from oj.t4 where j is unknown;
+----+----+
| I  | J  |
+----+----+
| 1  |    |
+----+----+
> 
> -- csv format is nicest for query plans
> !set outputformat csv
> 
> -- Note that we explain some queries both with and without order by;
> -- with to make sure what we executed above was using the correct plan
> -- without to make sure that the order by doesn't affect other
> -- aspects of optimization.
> 
> explain plan for
> select name from depts where deptno=20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> explain plan for
> select name from depts where deptno > 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 20, '+', null }]])'
> 
> explain plan for
> select name from depts where deptno >= 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 20, '+', null }]])'
> 
> explain plan for
> select name from depts where deptno < 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '-', null, ')', 20 }]])'
> 
> explain plan for
> select name from depts where deptno <= 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '-', null, ']', 20 }]])'
> 
> explain plan for
> select name from depts where deptno between 20 and 30;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 20, ']', 30 }]])'
> 
> explain plan for
> select name from depts where deptno > 20 and deptno < 30;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 20, ')', 30 }]])'
> 
> explain plan for
> select name from depts where deptno < 20 or deptno between 30 and 40;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '-', null, ')', 20 }, { '[', 30, ']', 40 }]])'
> 
> explain plan for
> select name from depts where deptno in (20,30) order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }, { '[', 30, ']', 30 }]])'
> 
> explain plan for
> select name from depts where deptno=20.00;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> explain plan for
> select name from depts where deptno > 19.6 order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 20, '+', null }]])'
> 
> explain plan for
> select name from depts where deptno >= 20.1 order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '(', 20, '+', null }]])'
> 
> explain plan for
> select name from depts where deptno=20000000000000;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', null, ')', null }]])'
> 
> explain plan for
> select name from depts where deptno>20000000000000;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', null, ')', null }]])'
> 
> explain plan for
> select name from depts where deptno>-20000000000000 order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '-', null, '+', null }]])'
> 
> explain plan for
> select v from oj.t3 where v='Houdini                 xyz';
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T3]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T3], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'    FennelValuesRel(tuples=[[{ '(', 'Houdini', ']', 'Houdini' }]])'
> 
> explain plan for
> select v from oj.t3 where v >= 'Houdini                 xyz'
> order by v;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T3]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T3], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 'Houdini', '+', null }]])'
> 
> explain plan for
> select v from oj.t3 where v <= 'Houdini                 xyz'
> order by v;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T3]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T3], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '-', null, ']', 'Houdini' }]])'
> 
> explain plan for
> select name from depts where deptno=20 and deptno=30;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', null, ')', null }]])'
> 
> explain plan for
> select name from emps where deptno=20 order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> explain plan for
> select name from emps where deptno=20 and gender='M';
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0]], filterOp=[COMP_EQ], filterOrdinals=[[2]], filterTuple=[['M']], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2, 3]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> explain plan for
> select name from emps where empid=3;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 5]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$EMPS$EMPID], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 3, ']', 3 }]])'
> 
> explain plan for
> select gender from emps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[3]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for
> select gender from emps order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[3]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for
> select name from emps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])'
> 
> explain plan for
> select upper(name) from emps;
'column0'
'IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], EXPR$0=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])'
> 
> explain plan for
> select name from emps order by 1;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[true])'
> 
> explain plan for
> select name,gender,deptno,empno from emps order by 3,4;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 3, 2, 0]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[true])'
> 
> explain plan for
> select depts.name as dname,emps.name as ename
> from emps inner join depts
> on emps.deptno=depts.deptno
> order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0, 1]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])'
> 
> explain plan for
> select depts.name as dname,emps.name as ename
> from emps left outer join depts
> on emps.deptno=depts.deptno
> order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" DNAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0, 1]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])'
> 
> explain plan for
> select emps.name as ename,depts.name as dname
> from depts left outer join emps
> on depts.deptno=emps.deptno
> order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], uniqueKey=[false], preserveOrder=[false], outer=[true], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], preserveOrder=[false])'
> 
> explain plan for
> select emps.name as ename,depts.name as dname
> from depts inner join emps
> on depts.deptno=emps.empid
> order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 5]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2, 3]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$EMPS$EMPID], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], preserveOrder=[false])'
> 
> explain plan for
> select emps.name as ename,depts.name as dname
> from depts left outer join emps
> on depts.deptno=emps.empid
> order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 5]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2, 3]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$EMPS$EMPID], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], preserveOrder=[false])'
> 
> explain plan for
> select e.name as ename,e.age,depts.name as dname
> from
> (select name,age - 20 as age from emps) e
> inner join depts on e.age = depts.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 1, 3]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME, INTEGER AGE, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..1=[{inputs}], expr#2=[20], expr#3=[-($t1, $t2)], expr#4=[CAST($t3):INTEGER NOT NULL], expr#5=[IS NOT NULL($t3)], NAME=[$t0], AGE=[$t3], DEPTNO=[$t4], $condition=[$t5])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 6]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for
> select e.name as ename,e.age,depts.name as dname
> from
> (select name,age - 20 as age from emps) e
> left outer join depts on e.age = depts.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 1, 3]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME, INTEGER AGE, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" DNAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..1=[{inputs}], expr#2=[20], expr#3=[-($t1, $t2)], NAME=[$t0], AGE=[$t3])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 6]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for
> select 
>     depts.name as dname,e.name as ename
> from 
>     depts 
> inner join 
>     (select name,age - 20 as age from emps) e
> on 
>     e.age=depts.deptno
> order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0..1=[{inputs}], expr#2=[20], expr#3=[-($t1, $t2)], expr#4=[CAST($t3):INTEGER NOT NULL], expr#5=[IS NOT NULL($t3)], NAME=[$t0], AGE=[$t3], DEPTNO=[$t4], $condition=[$t5])'
'            FennelToIteratorConverter'
'              FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 6]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$EMPS], preserveOrder=[false])'
> 
> explain plan for
> select *
> from oj.t1 left outer join oj.t2
> on t1.j = t2.j;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T2]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T2], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T2]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$T2$J], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      FtrsIndexScanRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T1], preserveOrder=[false])'
> 
> explain plan for select * from oj.t1 where j is null;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T1], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$T1$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', null, ']', null }]])'
> explain plan for select * from oj.t1 where not(j is null);
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T1], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$T1$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', null, '+', null }]])'
> 
> explain plan for select * from oj.t4 where j is true;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T4], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$T4$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', true, ']', true }]])'
> explain plan for select * from oj.t4 where j is false;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T4], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$T4$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', false, ']', false }]])'
> explain plan for select * from oj.t4 where j is unknown;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$T4], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$SYS$UNIQUE_KEY$T4$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', null, ']', null }]])'
> 
> -- can only explain plan for dynamic parameter search
> explain plan for
> select name from depts where deptno=?;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[?0], expr#3=[']'], expr#4=[IS NOT NULL($t2)], expr#5=[AND($t4, $t4)], $f0=[$t1], $f1=[$t2], $f2=[$t3], $f3=[$t2], $condition=[$t5])'
'          IterOneRowRel'
> 
> -- can't yet support usage of index when predicate on dynamic param
> -- is combined with another predicate on same column;
> -- at least make sure we recompose it correctly (FRG-72)
> explain plan for
> select name from depts where deptno > ? and deptno < 30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[?0], expr#3=[>($t0, $t2)], expr#4=[30], expr#5=[<($t0, $t4)], expr#6=[AND($t3, $t5)], NAME=[$t1], $condition=[$t6])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], preserveOrder=[false])'
> 
> explain plan for
> select name from depts where deptno > ? and deptno < ?;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[?0], expr#3=[>($t0, $t2)], expr#4=[?1], expr#5=[<($t0, $t4)], expr#6=[AND($t3, $t5)], NAME=[$t1], $condition=[$t6])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], preserveOrder=[false])'
> 
> -- this one should work because predicates are on different columns
> explain plan for
> select name from depts where deptno > ? and name='Hysteria';
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], filterOp=[COMP_EQ], filterOrdinals=[[1]], filterTuple=[['Hysteria']], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$DEPTS], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[?0], expr#3=['+'], expr#4=[null], expr#5=[CAST($t4):INTEGER], expr#6=[IS NOT NULL($t2)], $f0=[$t1], $f1=[$t2], $f2=[$t3], $f3=[$t5], $condition=[$t6])'
'          IterOneRowRel'
> 
> -- FRG-198
> create table oj.frg198(a char(5) primary key, b char(5));
> insert into oj.frg198 values ('t1a1', 't1a1'), ('t2a2', 't2a2');
> select * from oj.frg198 where a > 't1a1';
'A','B'
't2a2 ','t2a2 '
> 
> ----------------------------------------------
> -- LucidDB column store bitmap indexes test --
> ----------------------------------------------
> 
> create schema lbm;
> set schema 'lbm';
> set path 'lbm';
> 
> -------------------------------------------------
> -- Some ftrs tests to compare behavior against --
> -------------------------------------------------
> 
> create table ftrsemps(
>     empno integer not null constraint empno_pk primary key,
>     ename varchar(40),
>     deptno integer);
> 
> create index deptno_ix on ftrsemps(deptno);
> create index ename_ix on ftrsemps(ename);
> 
> insert into ftrsemps 
> select empno+deptno*1000, name, deptno from sales.emps;
> 
> !set outputformat csv
> 
> -- no sarg pred
> explain plan for
> select * from ftrsemps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], preserveOrder=[false])'
> 
> -- the most simple case
> explain plan for
> select * from ftrsemps where deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
> 
> -- negative number in index search
> explain plan for
> select * from ftrsemps where deptno = -2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', -2, ']', -2 }]])'
> 
> -- range predicate uses index access
> explain plan for
> select * from ftrsemps where deptno > 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 2, '+', null }]])'
> 
> -- Merge ranges on the same index key
> explain plan for
> select * from ftrsemps where deptno = 2 or deptno = 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }, { '[', 10, ']', 10 }]])'
> 
> -- Should have only one range
> explain plan for
> select * from ftrsemps where deptno = 10 or deptno > 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 2, '+', null }]])'
> 
> -- recognize AND on the same key
> explain plan for
> select * from ftrsemps where deptno > 2 and deptno < 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 2, ')', 10 }]])'
> 
> -- make sure NULL range from sarg analysis is working
> explain plan for
> select * from ftrsemps where deptno = 2 and deptno = 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', null, ')', null }]])'
> 
> -- Index only access:
> -- It seems index only access is not used here.
> explain plan for
> select deptno from ftrsemps where deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[2]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'    FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
> 
> -- index on char types:
> -- simple comparison predicate
> explain plan for
> select ename from ftrsemps where ename = 'ADAM';
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[1]], index=[ENAME_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'    FennelValuesRel(tuples=[[{ '[', 'ADAM', ']', 'ADAM' }]])'
> 
> -- index on char types:
> -- predicate specific to character types
> explain plan for
> select ename from ftrsemps where ename like 'ADAM%';
'column0'
'IterCalcRel(expr#0=[{inputs}], expr#1=['ADAM%'], expr#2=[LIKE($t0, $t1)], ENAME=[$t0], $condition=[$t2])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[1]], index=[ENAME_IX], preserveOrder=[false])'
> 
> -- AND: does recognize one index, but not two
> explain plan for
> select * from ftrsemps where deptno = 2 and ename = 'ADAM';
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 1, 2]], filterOp=[COMP_EQ], filterOrdinals=[[1]], filterTuple=[['ADAM']], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
> 
> -- OR: does not use any index access
> explain plan for
> select * from ftrsemps where deptno = 2 or ename = 'ADAM';
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=['ADAM'], expr#6=[=($t1, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPNO_PK], preserveOrder=[false])'
> 
> !set outputformat table
> 
> drop table ftrsemps cascade;
> 
> -------------------------------------------------------
> -- Part 1. index created on empty column store table --
> -------------------------------------------------------
> -- Use LucidDB personality
> alter session implementation set jar
>     sys_boot.sys_boot.luciddb_index_only_plugin;
> 
> create table lbmemps(
>     empno integer not null,
>     ename varchar(40),
>     deptno integer)
>     server sys_column_store_data_server
> create index empno_ix on lbmemps(empno, deptno)
> create index ename_ix on lbmemps(ename)
> create index deptno_ix on lbmemps(deptno)
> ;
> 
> create table lbmdepts(
>     deptno integer)
> server sys_column_store_data_server;
> 
> -- create index on existing column store table does not work yet
> -- create index ename_ix on lbmemps(ename);
> 
> -- two indexes on the same column
> -- create index on exisitng column store table does not work yet
> -- create index empno_ix2 on lbmemps(empno);
> 
> insert into lbmemps select empno, name, deptno from sales.emps;
> insert into lbmemps select empno, name, deptno from sales.emps;
> 
> !set outputformat csv
> 
> -- no sarg pred
> explain plan for
> select * from lbmemps order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
> 
> select * from lbmemps order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- fake row count so that index access is considered
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'LBMEMPS', 100);
> 
> -- the most simple case
> explain plan for
> select * from lbmemps where deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> select * from lbmemps where deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- negative number in index search
> explain plan for
> select * from lbmemps where deptno = -2;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ '[', -2, ']', -2 }]])'
> 
> select * from lbmemps where deptno = -2;
'EMPNO','ENAME','DEPTNO'
> 
> -- range predicate uses index access
> explain plan for
> select * from lbmemps where deptno > 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '(', 20, '+', null }]])'
> 
> select * from lbmemps where deptno > 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','John','40'
'110','John','40'
> 
> -- Merge ranges on the same index key
> explain plan for
> select * from lbmemps where deptno = 10 or deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 10, ']', 10 }, { '[', 20, ']', 20 }]])'
> 
> select * from lbmemps where deptno = 10 or deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- Should have only one range
> explain plan for
> select * from lbmemps where deptno = 20 or deptno > 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '(', 10, '+', null }]])'
> 
> select * from lbmemps where deptno = 20 or deptno > 10 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'110','John','40'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- recognize AND on the same key
> explain plan for
> select * from lbmemps where deptno > 10 and deptno <= 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '(', 10, ']', 20 }]])'
> 
> select * from lbmemps where deptno > 10 and deptno <= 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- make sure NULL range from sarg analysis is working
> explain plan for
> select * from lbmemps where deptno = 20 and deptno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '(', null, ')', null }]])'
> 
> select * from lbmemps where deptno = 20 and deptno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
> 
> -- make sure Merge is allocated on top of index search if 
> -- partial key is used in search
> explain plan for
> select * from lbmemps where empno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 10, ']', 10 }]])'
> 
> select * from lbmemps where empno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
> 
> explain plan for
> select * from lbmemps where empno = 10 and empno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '(', null, ')', null }]])'
> 
> select * from lbmemps where empno = 10 and empno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
> 
> -- IN on small values list
> explain plan for
> select ename from lbmemps where deptno in (20, 30)
> order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }, { '[', 30, ']', 30 }]])'
> 
> select ename from lbmemps where deptno in (20, 30)
> order by ename;
'ENAME'
'Eric'
'Eric'
'Wilma'
'Wilma'
> 
> -- OR on same column is supported
> explain plan for
> select *
> from lbmemps
> where (empno = 110 or empno = 120) and (deptno = 10 or deptno = 20)
> order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[3])'
'        LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[1])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ '[', 10, ']', 10 }, { '[', 20, ']', 20 }]])'
'        LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[4])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ '[', 110, ']', 110 }, { '[', 120, ']', 120 }]])'
> 
> -- same explain as above but with all attributes so deletion index scan should
> -- appear in the plan
> explain plan including all attributes for
> select *
> from lbmemps
> where (empno = 110 or empno = 120) and (deptno = 10 or deptno = 20)
> order by empno;
'column0'
'FennelToIteratorConverter: rowcount = 1.0000000000000002, cumulative cost = 12.000000000000002'
'  FennelSortRel(key=[[0]], discardDuplicates=[false]): rowcount = 1.0000000000000002, cumulative cost = 11.000000000000002'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]]): rowcount = 1.0000000000000002, cumulative cost = 10.000000000000002'
'      LcsIndexMinusRel(startRidParamId=[5], rowLimitParamId=[6]): rowcount = 1.0, cumulative cost = 111.0'
'        LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[3]): rowcount = 1.0, cumulative cost = 9.0'
'          LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[1]): rowcount = 1.0000000000000002, cumulative cost = 4.0'
'            LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0]): rowcount = 1.0000000000000002, cumulative cost = 3.0'
'              FennelValuesRel(tuples=[[{ '[', 10, ']', 10 }, { '[', 20, ']', 20 }]]): rowcount = 2.0, cumulative cost = 2.0'
'          LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[4]): rowcount = 1.0000000000000002, cumulative cost = 4.0'
'            LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0]): rowcount = 1.0000000000000002, cumulative cost = 3.0'
'              FennelValuesRel(tuples=[[{ '[', 110, ']', 110 }, { '[', 120, ']', 120 }]]): rowcount = 2.0, cumulative cost = 2.0'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[SYS$DELETION_INDEX$LBMEMPS], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[5], rowLimitParamId=[6]): rowcount = 100.0, cumulative cost = 101.0'
'          FennelValuesRel(tuples=[[{ '[', null, '+', null }]]): rowcount = 1.0, cumulative cost = 1.0'
> 
> select *
> from lbmemps
> where (empno = 110 or empno = 120) and (deptno = 10 or deptno = 20)
> order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- index only access.
> explain plan for
> select deptno from lbmemps where deptno = 20 order by deptno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsNormalizerRel'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> select deptno from lbmemps where deptno = 20 order by deptno;
'DEPTNO'
'20'
'20'
'20'
'20'
> 
> -- index on char types:
> -- simple comparison predicate
> explain plan for
> select ename from lbmemps where ename = 'ADAM' order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsNormalizerRel'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[ENAME_IX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 'ADAM', ']', 'ADAM' }]])'
> 
> select ename from lbmemps where ename = 'ADAM' order by ename;
'ENAME'
> 
> -- index on char types:
> -- predicate specific to character types
> explain plan for
> select ename from lbmemps where ename like 'ADAM%' order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0=[{inputs}], expr#1=['ADAM%'], expr#2=[LIKE($t0, $t1)], ENAME=[$t0], $condition=[$t2])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
> 
> select ename from lbmemps where ename like 'ADAM%' order by ename;
'ENAME'
> 
> explain plan for
> select * from lbmemps where deptno = 10 and ename = 'Fred' order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[ENAME_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'          FennelValuesRel(tuples=[[{ '[', 'Fred', ']', 'Fred' }]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'          FennelValuesRel(tuples=[[{ '[', 10, ']', 10 }]])'
> 
> select * from lbmemps where deptno = 10 and ename = 'Fred' order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
> 
> -- test composite key indexes
> explain plan for
> select * from lbmemps where empno = 100 and deptno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '[', 100, 10, ']', 100, 10 }]])'
> 
> select * from lbmemps where empno = 100 and deptno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
> 
> explain plan for
> select * from lbmemps where deptno = 10 and empno = 100 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '[', 100, 10, ']', 100, 10 }]])'
> 
> select * from lbmemps where deptno = 10 and empno = 100 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
> 
> explain plan for
> select * from lbmemps where empno = 100 and deptno >= 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 100, 10, '+', 100, null }]])'
> 
> select * from lbmemps where empno = 100 and deptno >= 10 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
> 
> -- test "not null" data type
> explain plan for
> select * from lbmemps where empno between 100 and 200 and deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'          FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
'        LcsIndexMergeRel(consumerSridParamId=[1], segmentLimitParamId=[2], ridLimitParamId=[3])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ '[', 100, ']', 200 }]])'
> 
> select * from lbmemps where empno between 100 and 200 and deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
> 
> -- test multiple inputs to Intersect
> explain plan for
> select * 
> from lbmemps
> where empno between 100 and 200 and deptno = 20 and ename = 'Eric'
> order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[ENAME_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'          FennelValuesRel(tuples=[[{ '[', 'Eric', ']', 'Eric' }]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'          FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
'        LcsIndexMergeRel(consumerSridParamId=[1], segmentLimitParamId=[2], ridLimitParamId=[3])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ '[', 100, ']', 200 }]])'
> 
> select * 
> from lbmemps
> where empno between 100 and 200 and deptno = 20 and ename = 'Eric'
> order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
> 
> -- TODO OR: currently does not use any index access
> explain plan for
> select * from lbmemps where deptno = 2 or ename = 'Fred' order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=['Fred'], expr#6=[=($t1, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
> 
> select * from lbmemps where deptno = 2 or ename = 'Fred' order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
> 
> ----------------------------------------------------------------------
> -- Tests using multiple index keys with range searches on the last key
> ----------------------------------------------------------------------
> create table multikey(a int, b int) server sys_column_store_data_server;
> insert into multikey values (0, 0);
> insert into multikey values (1, 1);
> insert into multikey values (1, 2);
> insert into multikey values (1, 3);
> insert into multikey values (1, 4);
> insert into multikey values (2, 2);
> create index imultikey on multikey(a, b);
> 
> -- fake row count so that index access is considered
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'MULTIKEY', 100);
> 
> !set outputformat csv
> explain plan for select * from multikey where a = 1 and b > 1;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ '(', 1, 1, '+', 1, null }]])'
> explain plan for select * from multikey where a = 1 and b <= 3;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ '(', 1, null, ']', 1, 3 }]])'
> explain plan for select * from multikey where a = 1 and b >= 2 and b < 4;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ '[', 1, 2, ')', 1, 4 }]])'
> 
> !set outputformat table
> select * from multikey where a = 1 and b > 1;
+----+----+
| A  | B  |
+----+----+
| 1  | 2  |
| 1  | 3  |
| 1  | 4  |
+----+----+
> select * from multikey where a = 1 and b <= 3;
+----+----+
| A  | B  |
+----+----+
| 1  | 1  |
| 1  | 2  |
| 1  | 3  |
+----+----+
> select * from multikey where a = 1 and b >= 2 and b < 4;
+----+----+
| A  | B  |
+----+----+
| 1  | 2  |
| 1  | 3  |
+----+----+
> 
> ----------------------------
> -- Tests of index only scans
> ----------------------------
> create table person(
>     id int primary key,
>     age int)
> server sys_column_store_data_server
> create index age_idx on person(age);
> 
> -- fake row count so that index access is considered
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'PERSON', 100);
> 
> !set outputformat csv
> 
> -- index search
> explain plan for
> select id from person where id = 30;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$PERSON], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 30, ']', 30 }]])'
> 
> -- index search with merge
> explain plan for
> select id from person where id > 30;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$PERSON], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '(', 30, '+', null }]])'
> 
> -- histogram type aggregate
> explain plan for 
> select age, count(*) from person group by age order by age;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsIndexAggRel(groupCount=[1], EXPR$1=[COUNT()])'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]])'
> 
> -- cardinality type aggregate
> explain plan for 
> select count(distinct(age)) from person;
'column0'
'FennelToIteratorConverter'
'  FennelAggRel(groupCount=[0], EXPR$0=[COUNT($0)])'
'    LcsIndexAggRel(groupCount=[1])'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]])'
> 
> -- agg with index search
> explain plan for 
> select avg(age) from person where age > 30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t0):DOUBLE], expr#3=[CAST($t1):DOUBLE NOT NULL], expr#4=[/($t2, $t3)], expr#5=[1E6], expr#6=[*($t4, $t5)], expr#7=[CAST($t6):BIGINT], expr#8=[Reinterpret($t7)], expr#9=[Reinterpret($t8)], expr#10=[0], expr#11=[>($t9, $t10)], expr#12=[500000], expr#13=[+($t9, $t12)], expr#14=[-($t9, $t12)], expr#15=[CASE($t11, $t13, $t14)], expr#16=[1000000], expr#17=[/INT($t15, $t16)], expr#18=[CAST($t17):INTEGER], EXPR$0=[$t18])'
'  FennelToIteratorConverter'
'    LcsIndexAggRel(groupCount=[0], agg#0=[SUM($0)], agg#1=[COUNT($0)])'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '(', 30, '+', null }]])'
> 
> -- multikey
> explain plan for 
> select a from multikey where a = 1 and b > 1 group by a;
'column0'
'FennelToIteratorConverter'
'  LcsIndexAggRel(groupCount=[1])'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ '(', 1, 1, '+', 1, null }]])'
> 
> explain plan for 
> select b from multikey where a = 1;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[1, 2, 3, 4]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 1, ']', 1 }]])'
> 
> explain plan for 
> select b from multikey where a = 1 group by b;
'column0'
'FennelToIteratorConverter'
'  LhxAggRel(groupCount=[1])'
'    LcsNormalizerRel'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[1, 2, 3, 4]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ '[', 1, ']', 1 }]])'
> 
> -- widening of an index search 
> create index multikey_a on multikey(a);
> 
> explain plan for
> select a, b from multikey where a = 1;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ '[', 1, ']', 1 }]])'
> 
> -- negative test: row scan with child can't be converted
> explain plan for 
> select age, count(*) from person where id > 5 group by age;
'column0'
'FennelToIteratorConverter'
'  LhxAggRel(groupCount=[1], EXPR$1=[COUNT()])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, PERSON]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$PERSON$AGE]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, PERSON]], index=[SYS$CONSTRAINT_INDEX$SYS$PRIMARY_KEY$PERSON], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '(', 5, '+', null }]])'
> 
> -- negative test: index only scan produces wrong sort order for agg
> explain plan for 
> select a, b from multikey where a = 1 and b > 1 group by b, a;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1, 0]], outputRowType=[RecordType(INTEGER A, INTEGER B) NOT NULL])'
'    LhxAggRel(groupCount=[2])'
'      LcsNormalizerRel'
'        LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[1, 0, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'          FennelValuesRel(tuples=[[{ '(', 1, 1, '+', 1, null }]])'
> 
> -- TODO: implement interposed calc when we have sort order propagation
> explain plan for 
> select avg(age+1) from person;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t0):DOUBLE], expr#3=[CAST($t1):DOUBLE NOT NULL], expr#4=[/($t2, $t3)], expr#5=[1E6], expr#6=[*($t4, $t5)], expr#7=[CAST($t6):BIGINT], expr#8=[Reinterpret($t7)], expr#9=[Reinterpret($t8)], expr#10=[0], expr#11=[>($t9, $t10)], expr#12=[500000], expr#13=[+($t9, $t12)], expr#14=[-($t9, $t12)], expr#15=[CASE($t11, $t13, $t14)], expr#16=[1000000], expr#17=[/INT($t15, $t16)], expr#18=[CAST($t17):INTEGER], EXPR$0=[$t18])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[SUM($0)], agg#1=[COUNT($0)])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=[1], expr#2=[+($t0, $t1)], $f0=[$t2])'
'          FennelToIteratorConverter'
'            LcsRowScanRel(table=[[LOCALDB, LBM, PERSON]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$PERSON$AGE]])'
> 
> explain plan for 
> select avg(age+1) from person where age = 30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t0):DOUBLE], expr#3=[CAST($t1):DOUBLE NOT NULL], expr#4=[/($t2, $t3)], expr#5=[1E6], expr#6=[*($t4, $t5)], expr#7=[CAST($t6):BIGINT], expr#8=[Reinterpret($t7)], expr#9=[Reinterpret($t8)], expr#10=[0], expr#11=[>($t9, $t10)], expr#12=[500000], expr#13=[+($t9, $t12)], expr#14=[-($t9, $t12)], expr#15=[CASE($t11, $t13, $t14)], expr#16=[1000000], expr#17=[/INT($t15, $t16)], expr#18=[CAST($t17):INTEGER], EXPR$0=[$t18])'
'  FennelToIteratorConverter'
'    FennelAggRel(groupCount=[0], agg#0=[SUM($0)], agg#1=[COUNT($0)])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=[1], expr#2=[+($t0, $t1)], $f0=[$t2])'
'          FennelToIteratorConverter'
'            LcsNormalizerRel'
'              LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'                FennelValuesRel(tuples=[[{ '[', 30, ']', 30 }]])'
> 
> ----------------------------------------------------------
> -- Tests to exercise using startrid in bitmap index search
> ----------------------------------------------------------
> 
> create server test_data
> foreign data wrapper sys_file_wrapper
> options (
>     directory 'unitsql/optimizer/data',
>     file_extension 'csv',
>     with_header 'yes',
>     log_directory 'testlog');
> 
> create foreign table ridsearchdata(a int, b int, c int)
>     server test_data
>     options (filename 'ridsearchdata');
> 
> create table ridsearchtable(fakerid int, a int, b int)
>     server sys_column_store_data_server;
> create index i_a on ridsearchtable(a);
> create index i_b on ridsearchtable(b);
> insert into ridsearchtable select * from ridsearchdata;
> 
> !set outputformat csv
> explain plan for select * from ridsearchtable where b = 0 and a = 2;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
> explain plan for select * from ridsearchtable where b = 0 and a = 3;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 3, ']', 3 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
> explain plan for select * from ridsearchtable where b = 0 and a = 1;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 1, ']', 1 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
> 
> !set outputformat table
> select * from ridsearchtable order by fakerid;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
| 1        | 3  | 1  |
| 2        | 3  | 2  |
| 3        | 3  | 3  |
| 4        | 3  | 4  |
| 5        | 3  | 5  |
| 6        | 3  | 6  |
| 7        | 3  | 7  |
| 8        | 2  | 0  |
| 9        | 2  | 1  |
| 10       | 2  | 2  |
| 11       | 2  | 3  |
| 12       | 2  | 4  |
| 13       | 2  | 5  |
| 14       | 2  | 6  |
| 15       | 2  | 7  |
| 16       | 0  | 0  |
+----------+----+----+
> select * from ridsearchtable where b = 0 and a = 2;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 8        | 2  | 0  |
+----------+----+----+
> select * from ridsearchtable where b = 0 and a = 3;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
+----------+----+----+
> -- no rows
> select * from ridsearchtable where b = 0 and a = 1;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
+----------+----+----+
> 
> -- reverse the order of the index creation and repeat
> 
> drop table ridsearchtable;
> create table ridsearchtable(fakerid int, a int, b int)
>     server sys_column_store_data_server;
> create index i_b on ridsearchtable(b);
> create index i_a on ridsearchtable(a);
> insert into ridsearchtable select * from ridsearchdata;
> 
> !set outputformat csv
> explain plan for select * from ridsearchtable where b = 0 and a = 2;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
> explain plan for select * from ridsearchtable where b = 0 and a = 3;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 3, ']', 3 }]])'
> explain plan for select * from ridsearchtable where b = 0 and a = 1;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[1], rowLimitParamId=[2])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 0, ']', 0 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[1], rowLimitParamId=[2])'
'        FennelValuesRel(tuples=[[{ '[', 1, ']', 1 }]])'
> 
> !set outputformat table
> select * from ridsearchtable order by fakerid;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
| 1        | 3  | 1  |
| 2        | 3  | 2  |
| 3        | 3  | 3  |
| 4        | 3  | 4  |
| 5        | 3  | 5  |
| 6        | 3  | 6  |
| 7        | 3  | 7  |
| 8        | 2  | 0  |
| 9        | 2  | 1  |
| 10       | 2  | 2  |
| 11       | 2  | 3  |
| 12       | 2  | 4  |
| 13       | 2  | 5  |
| 14       | 2  | 6  |
| 15       | 2  | 7  |
| 16       | 0  | 0  |
+----------+----+----+
> select * from ridsearchtable where b = 0 and a = 2;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 8        | 2  | 0  |
+----------+----+----+
> select * from ridsearchtable where b = 0 and a = 3;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
+----------+----+----+
> -- no rows
> select * from ridsearchtable where b = 0 and a = 1;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
+----------+----+----+
> 
> ---------------------
> -- Some join tests --
> ---------------------
> -- Filter above join gets pushed down so index can be used.
> !set outputformat csv
> explain plan for 
> select * from lbmdepts, lbmemps where lbmemps.deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[3, 0, 1, 2]], outputRowType=[RecordType(INTEGER DEPTNO, INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO0) NOT NULL])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
'      LcsRowScanRel(table=[[LOCALDB, LBM, LBMDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMDEPTS$DEPTNO]])'
> 
> select * from lbmdepts, lbmemps where lbmemps.deptno = 2;
'DEPTNO','EMPNO','ENAME','DEPTNO0'
> 
> -- Filter in an inline view is already in the right place for indexing.
> explain plan for 
> select * from lbmdepts, 
>               (select * from lbmemps where lbmemps.deptno = 2) view;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[3, 0, 1, 2]], outputRowType=[RecordType(INTEGER DEPTNO, INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO) NOT NULL])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBMEMPS$ENAME]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 2, ']', 2 }]])'
'      LcsRowScanRel(table=[[LOCALDB, LBM, LBMDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMDEPTS$DEPTNO]])'
> 
> select * from lbmdepts, 
>               (select * from lbmemps where lbmemps.deptno = 2) view;
'DEPTNO','EMPNO','ENAME','DEPTNO0'
> 
> !set outputformat table
> 
> ------------
> -- Misc bugs
> ------------
> -- FRG-83
> create table t(a int, b int, c int) server sys_column_store_data_server;
> create index ita on t(a);
> create index itb on t(b);
> insert into t values(1, 2, 3);
> create view v as select * from t where a = 1 and b = 2;
> select * from v v1, v v2; 
+----+----+----+-----+-----+-----+
| A  | B  | C  | A0  | B0  | C0  |
+----+----+----+-----+-----+-----+
| 1  | 2  | 3  | 1   | 2   | 3   |
+----+----+----+-----+-----+-----+
> drop table t cascade;
> 
> ----------------------------------------
> -- Test for cost based index access   --
> -- 1.1 Single table index access path --
> --     with stats                     --
> ----------------------------------------
> !set outputformat csv
> 
> -- analyze table
> create table test(a int, b int, c int, d int);
> 
> insert into test values(10,20,30,40);
> insert into test values(11,21,31,41);
> insert into test values(12,22,32,42);
> insert into test values(13,23,33,43);
> insert into test values(14,24,34,44);
> insert into test values(15,25,35,45);
> insert into test values(10,20,30,40);
> insert into test values(11,21,31,41);
> insert into test values(12,22,32,42);
> insert into test values(13,23,33,43);
> insert into test values(14,24,34,44);
> insert into test values(15,25,35,45);
> insert into test values(10,20,30,40);
> insert into test values(11,21,31,41);
> insert into test values(12,22,32,42);
> insert into test values(13,23,33,43);
> insert into test values(14,24,34,44);
> insert into test values(15,25,35,45);
> 
> -- create index test_ab on test(a, b);
> create index test_cb on test(c, b);
> create index test_b on test(b);
> create index test_ba on test(b, a);
> 
> -- plan without analyze
> explain plan for
> select * from test
> where a = 10 and b = 20 and c > 30;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, TEST]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$TEST$A, SYS$CLUSTERED_INDEX$TEST$B, SYS$CLUSTERED_INDEX$TEST$C, SYS$CLUSTERED_INDEX$TEST$D]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[3])'
'      LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[3], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, TEST]], index=[TEST_CB], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '(', 30, '+', null }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, TEST]], index=[TEST_BA], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[2], rowLimitParamId=[3])'
'        FennelValuesRel(tuples=[[{ '[', 20, 10, ']', 20, 10 }]])'
> 
> explain plan for
> select * from test
> where b = 20;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, TEST]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$TEST$A, SYS$CLUSTERED_INDEX$TEST$B, SYS$CLUSTERED_INDEX$TEST$C, SYS$CLUSTERED_INDEX$TEST$D]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LBM, TEST]], index=[TEST_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> select * from test
> where a = 10 and b = 20 and c > 10
> order by a;
'A','B','C','D'
'10','20','30','40'
'10','20','30','40'
'10','20','30','40'
> 
> select * from test
> where b = 20
> order by a;
'A','B','C','D'
'10','20','30','40'
'10','20','30','40'
'10','20','30','40'
> 
> -- plan with analyze
> analyze table test compute statistics for all columns;
> 
> explain plan for
> select * from test
> where a = 10 and b = 20 and c > 30;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, TEST]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$TEST$C, SYS$CLUSTERED_INDEX$TEST$A, SYS$CLUSTERED_INDEX$TEST$B, SYS$CLUSTERED_INDEX$TEST$D]], residual columns=[[2]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LBM, TEST]], index=[TEST_BA], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ '[', 20, 10, ']', 20, 10 }]])'
'    FennelValuesRel(tuples=[[{ '(', 30, '+', null }]])'
> 
> explain plan for
> select * from test
> where b = 20;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, TEST]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$TEST$A, SYS$CLUSTERED_INDEX$TEST$B, SYS$CLUSTERED_INDEX$TEST$C, SYS$CLUSTERED_INDEX$TEST$D]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LBM, TEST]], index=[TEST_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> select * from test
> where a = 10 and b = 20 and c > 10
> order by a;
'A','B','C','D'
'10','20','30','40'
'10','20','30','40'
'10','20','30','40'
> 
> select * from test
> where b = 20
> order by a;
'A','B','C','D'
'10','20','30','40'
'10','20','30','40'
'10','20','30','40'
> 
> drop table test cascade;
> 
> ----------------------------------------
> -- Test for cost based index access   --
> -- 1.2 Single table index access path --
> --     with fake stats                --
> ----------------------------------------
> create table t(a varchar(20), b char(20), c varchar(20), d varchar(20));
> 
> create index t_abcd on t(a,b,c,d);
> create index t_a on t(a);
> create index t_b on t(b);
> 
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'T', 100000);
> 
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'T', 'A', 2, 100, 2, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> 
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'T', 'B', 3, 100, 3, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> 
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'T', 'C', 200, 100, 200, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> 
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'T', 'D', 300, 100, 300, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> 
> -- deletion index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$DELETION_INDEX$T', 2);
> 
> -- clustered index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$A', 2);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$B', 3);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$C', 200);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$D', 300);
> 
> -- unclustered index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'T_ABCD', 1000);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'T_A', 2);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'T_B', 2);
> 
> 
> explain plan for
> select * from t
> where a= 'a' and b= 'b';
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$T$A, SYS$CLUSTERED_INDEX$T$B, SYS$CLUSTERED_INDEX$T$C, SYS$CLUSTERED_INDEX$T$D]], residual columns=[[0]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LBM, T]], index=[T_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ '[', 'b                   ', ']', 'b                   ' }]])'
'    FennelValuesRel(tuples=[[{ '[', 'a', ']', 'a' }]])'
> 
> -- change stats and try again
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'T', 100000);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$C', 20);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$D', 30);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'T_ABCD', 20);
> 
> explain plan for
> select * from t
> where a= 'a' and b= 'b';
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$T$A, SYS$CLUSTERED_INDEX$T$B, SYS$CLUSTERED_INDEX$T$C, SYS$CLUSTERED_INDEX$T$D]], residual columns=[[0, 1]])'
'    FennelValuesRel(tuples=[[{ '[', 'a', ']', 'a' }]])'
'    FennelValuesRel(tuples=[[{ '[', 'b                   ', ']', 'b                   ' }]])'
> 
> drop table t cascade;
> 
> ----------------------------------------
> -- Test for cost based index access   --
> -- 2. Semijoin index access path      --
> --     with fake stats                --
> ----------------------------------------
> create table t(b char(20), d varchar(20) not null);
> 
> create index it_b on t(b);
> create index it_bd on t(b, d);
> create index it_d on t(d);
> create index it_db on t(d, b);
> 
> insert into t values('abcdef', 'this is row 1');
> insert into t values('abcdef', 'this is row 2');
> insert into t values('abcdef', 'this is row 3');
> insert into t values(null, 'this is row 4');
> insert into t values(null, 'no match');
> 
> -- although this table has the same number of rows as t, we will force this
> -- to be the dimension table in the semijoin by putting a dummy filter on
> -- the table
> 
> create table smalltable(s1 varchar(128) not null, s3 varchar(128) not null);
> 
> insert into smalltable values('this is row 1', 'abcdef');
> insert into smalltable values('this is row 2', 'abcdef');
> insert into smalltable values('this is row 3', 'abcdef');
> insert into smalltable values('this is row 4', 'abcdef');
> insert into smalltable values('this is row 5', 'abcdef');
> 
> -- plan without stats
> explain plan for
> select *
>     from t inner join smalltable s
>     on t.b = s.s3 and s.s1 = 'this is row 1' 
>     order by d;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 3, 4]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" B, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL D, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S1, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S3) NOT NULL])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[2]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[0, 1, 0]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" B, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL D, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LBM, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$T$B, SYS$CLUSTERED_INDEX$T$D]])'
'        FennelReshapeRel(projection=[[0, 1, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S1, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S3, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LBM, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SMALLTABLE$S3]], residual columns=[[0]])'
'            FennelValuesRel(tuples=[[{ '[', 'this is row 1', ']', 'this is row 1' }]])'
> 
> explain plan for 
> select *
>     from t inner join smalltable s
>     on t.d = s.s1 where s.s3 = 'abcdef' order by d;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 3, 4]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" B, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL D, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S1, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S3) NOT NULL])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], proj#0..2=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LBM, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$T$B, SYS$CLUSTERED_INDEX$T$D]])'
'        LcsRowScanRel(table=[[LOCALDB, LBM, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SMALLTABLE$S1]], residual columns=[[1]])'
'          FennelValuesRel(tuples=[[{ '[', 'abcdef', ']', 'abcdef' }]])'
> 
> select *
>     from t inner join smalltable s
>     on t.b = s.s3 and s.s1 = 'this is row 1' 
>     order by d;
'B','D','S1','S3'
'abcdef              ','this is row 1','this is row 1','abcdef'
'abcdef              ','this is row 2','this is row 1','abcdef'
'abcdef              ','this is row 3','this is row 1','abcdef'
> 
> select *
>     from t inner join smalltable s
>     on t.d = s.s1 where s.s3 = 'abcdef' order by d;
'B','D','S1','S3'
'abcdef              ','this is row 1','this is row 1','abcdef'
'abcdef              ','this is row 2','this is row 2','abcdef'
'abcdef              ','this is row 3','this is row 3','abcdef'
'','this is row 4','this is row 4','abcdef'
> 
> -- Create fake statistics.  The stats do not match the actual data in the
> -- tables and are meant to force the optimizer to choose semijoins
> 
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'T', 10000);
> call sys_boot.mgmt.stat_set_row_count('LOCALDB', 'LBM', 'SMALLTABLE', 10);
> 
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'T', 'B', 10, 100, 10, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'T', 'D', 10, 100, 10, 1, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> 
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'SMALLTABLE', 'S1', 10, 100, 10, 1,
>     'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> call sys_boot.mgmt.stat_set_column_histogram(
>     'LOCALDB', 'LBM', 'SMALLTABLE', 'S3', 10, 100, 10, 1,
>     'ABCDEFGHIJKLMNOPQRSTUVWXYZ');
> 
> -- deletion index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$DELETION_INDEX$T', 2);
> 
> -- clustered index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$B', 2);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$T$D', 2);
> 
> -- unclustered index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'IT_B', 10);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'IT_BD', 20);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'IT_D', 1);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'IT_DB', 2);
> 
> -- deletion index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$DELETION_INDEX$SMALLTABLE', 2);
> 
> -- clustered index
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$SMALLTABLE$S1', 2);
> call sys_boot.mgmt.stat_set_page_count('LOCALDB', 'LBM', 'SYS$CLUSTERED_INDEX$SMALLTABLE$S3', 2);
> 
> explain plan for
> select *
>     from t inner join smalltable s
>     on t.b = s.s3 and s.s1 = 'this is row 1' 
>     order by d;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 3, 4]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" B, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL D, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S1, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S3) NOT NULL])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[2]], joinType=[INNER])'
'        FennelReshapeRel(projection=[[0, 1, 0]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" B, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL D, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($0):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LBM, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$T$B, SYS$CLUSTERED_INDEX$T$D]])'
'            LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'              LcsIndexSearchRel(table=[[LOCALDB, LBM, T]], index=[IT_B], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                FennelSortRel(key=[[0]], discardDuplicates=[false])'
'                  LhxAggRel(groupCount=[1])'
'                    IteratorToFennelConverter'
'                      IterCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], S3=[$t1])'
'                        FennelToIteratorConverter'
'                          LcsRowScanRel(table=[[LOCALDB, LBM, SMALLTABLE]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SMALLTABLE$S3]], residual columns=[[0]])'
'                            FennelValuesRel(tuples=[[{ '[', 'this is row 1', ']', 'this is row 1' }]])'
'        FennelReshapeRel(projection=[[0, 1, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S1, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S3, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" CAST($1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary") NOT NULL])'
'          LcsRowScanRel(table=[[LOCALDB, LBM, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SMALLTABLE$S1, SYS$CLUSTERED_INDEX$SMALLTABLE$S3]], residual columns=[[0]])'
'            FennelValuesRel(tuples=[[{ '[', 'this is row 1', ']', 'this is row 1' }]])'
> 
> explain plan for 
> select *
>     from t inner join smalltable s
>     on t.d = s.s1 where s.s3 = 'abcdef' order by d;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0, 1, 3, 4]], outputRowType=[RecordType(CHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" B, VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL D, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S1, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL S3) NOT NULL])'
'      LhxJoinRel(leftKeys=[[2]], rightKeys=[[0]], joinType=[INNER])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0..1=[{inputs}], expr#2=[CAST($t1):VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], proj#0..2=[{exprs}])'
'            FennelToIteratorConverter'
'              LcsRowScanRel(table=[[LOCALDB, LBM, T]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$T$B, SYS$CLUSTERED_INDEX$T$D]])'
'                LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'                  LcsIndexSearchRel(table=[[LOCALDB, LBM, T]], index=[IT_D], projection=[*], inputKeyProj=[*], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'                    FennelSortRel(key=[[0]], discardDuplicates=[false])'
'                      LhxAggRel(groupCount=[1])'
'                        IteratorToFennelConverter'
'                          IterCalcRel(expr#0=[{inputs}], expr#1=[CAST($t0):VARCHAR(20) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL], S1=[$t1])'
'                            FennelToIteratorConverter'
'                              LcsRowScanRel(table=[[LOCALDB, LBM, SMALLTABLE]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SMALLTABLE$S1]], residual columns=[[1]])'
'                                FennelValuesRel(tuples=[[{ '[', 'abcdef', ']', 'abcdef' }]])'
'        LcsRowScanRel(table=[[LOCALDB, LBM, SMALLTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$SMALLTABLE$S3, SYS$CLUSTERED_INDEX$SMALLTABLE$S1]], residual columns=[[1]])'
'          FennelValuesRel(tuples=[[{ '[', 'abcdef', ']', 'abcdef' }]])'
> 
> select *
>     from t inner join smalltable s
>     on t.b = s.s3 and s.s1 = 'this is row 1' 
>     order by d;
'B','D','S1','S3'
'abcdef              ','this is row 1','this is row 1','abcdef'
'abcdef              ','this is row 2','this is row 1','abcdef'
'abcdef              ','this is row 3','this is row 1','abcdef'
> 
> select *
>     from t inner join smalltable s
>     on t.d = s.s1 where s.s3 = 'abcdef' order by d;
'B','D','S1','S3'
'abcdef              ','this is row 1','this is row 1','abcdef'
'abcdef              ','this is row 2','this is row 2','abcdef'
'abcdef              ','this is row 3','this is row 3','abcdef'
'','this is row 4','this is row 4','abcdef'
> 
> drop table t cascade;
> drop table smalltable cascade;
> 
> -- Test to make sure index only scans aren't enabled by default.  Earlier, we
> -- verified that when index only scans are enabled, it is used with the
> -- following select query.
> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
> explain plan for
>     select deptno from lbmemps where deptno = 20 order by deptno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[[2]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBMEMPS$DEPTNO]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '[', 20, ']', 20 }]])'
> 
> --------------
> -- Clean up --
> --------------
> drop server test_data cascade;
> drop schema lbm cascade;
> 
> -- End index.sql
> 
> !quit
