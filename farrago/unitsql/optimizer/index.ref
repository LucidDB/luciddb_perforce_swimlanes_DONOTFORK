0: jdbc:farrago:> -- $Id: //open/lu/dev_lcs/farrago/unitsql/optimizer/index.sql#6 $
0: jdbc:farrago:> -- Test queries which make use of indexes
0: jdbc:farrago:> 
0: jdbc:farrago:> create schema oj;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table oj.t1(i int not null primary key, j int unique);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table oj.t2(i int not null primary key, j int unique);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into oj.t1 values (1,null), (2, 2), (3, 3);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into oj.t2 values (1,null), (2, 2), (4, 4);
0: jdbc:farrago:> 
0: jdbc:farrago:> set schema 'sales';
0: jdbc:farrago:> 
0: jdbc:farrago:> -- force usage of Java calculator
0: jdbc:farrago:> alter system set "calcVirtualMachine" = 'CALCVM_JAVA';
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique clustered index
0: jdbc:farrago:> select name from depts where deptno=20;
+------------+
|    NAME    |
+------------+
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno > 20 order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno >= 20 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno < 20 order by name;
+--------+
|  NAME  |
+--------+
| Sales  |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno <= 20 order by name;
+------------+
|    NAME    |
+------------+
| Marketing  |
| Sales      |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno between 20 and 30 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno > 20 and deptno < 30 order by name;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno < 20 or deptno between 30 and 40 
. . . . . . . . > order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
| Sales     |
+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- contradiction:  empty range
0: jdbc:farrago:> select name from depts where deptno=20 and deptno=30;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search beyond end
0: jdbc:farrago:> select name from depts where deptno > 50 order by name;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search before start
0: jdbc:farrago:> select name from depts where deptno < 5 order by name;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique clustered index with a prefix key
0: jdbc:farrago:> select name from emps where deptno=20 order by 1;
+--------+
|  NAME  |
+--------+
| Eric   |
| Wilma  |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique clustered index with a prefix key and a non-indexable condition
0: jdbc:farrago:> select name from emps where deptno=20 and gender='M';
+-------+
| NAME  |
+-------+
| Eric  |
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique unclustered index
0: jdbc:farrago:> select name from emps where empid=3;
+-------+
| NAME  |
+-------+
| Eric  |
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- project columns covered by clustered index
0: jdbc:farrago:> select gender from emps order by 1;
+---------+
| GENDER  |
+---------+
|         |
| F       |
| M       |
| M       |
+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- project columns covered by an unclustered index
0: jdbc:farrago:> select name from emps order by 1;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| John   |
| Wilma  |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- sort multiple columns covered by an unclustered index
0: jdbc:farrago:> select name,gender,deptno,empno from emps order by 3,4;
+--------+---------+---------+--------+
|  NAME  | GENDER  | DEPTNO  | EMPNO  |
+--------+---------+---------+--------+
| Fred   |         | 10      | 100    |
| Eric   | M       | 20      | 110    |
| Wilma  | F       | 20      | 120    |
| John   | M       | 40      | 110    |
+--------+---------+---------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- unique inner join via clustered index
0: jdbc:farrago:> select depts.name as dname,emps.name as ename
. . . . . . . . > from emps inner join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
+------------+--------+
|   DNAME    | ENAME  |
+------------+--------+
| Marketing  | Eric   |
| Marketing  | Wilma  |
| Sales      | Fred   |
+------------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- unique left outer join via clustered index
0: jdbc:farrago:> select depts.name as dname,emps.name as ename
. . . . . . . . > from emps left outer join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
+------------+--------+
|   DNAME    | ENAME  |
+------------+--------+
|            | John   |
| Marketing  | Eric   |
| Marketing  | Wilma  |
| Sales      | Fred   |
+------------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- left outer join via clustered index prefix
0: jdbc:farrago:> select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.deptno
. . . . . . . . > order by 2,1;
+--------+------------+
| ENAME  |   DNAME    |
+--------+------------+
|        | Accounts   |
| Eric   | Marketing  |
| Wilma  | Marketing  |
| Fred   | Sales      |
+--------+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- inner join via unclustered index
0: jdbc:farrago:> select emps.name as ename,depts.name as dname
. . . . . . . . > from depts inner join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
+--------+-----------+
| ENAME  |   DNAME   |
+--------+-----------+
| Fred   | Accounts  |
+--------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- left outer join via unclustered index
0: jdbc:farrago:> select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
+--------+------------+
| ENAME  |   DNAME    |
+--------+------------+
| Fred   | Accounts   |
|        | Marketing  |
|        | Sales      |
+--------+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- inner join on nullable key
0: jdbc:farrago:> select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > inner join depts on e.age = depts.deptno;
+--------+------+-----------+
| ENAME  | AGE  |   DNAME   |
+--------+------+-----------+
| Wilma  | 30   | Accounts  |
+--------+------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join on nullable key
0: jdbc:farrago:> select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > left outer join depts on e.age = depts.deptno;
+--------+------+-----------+
| ENAME  | AGE  |   DNAME   |
+--------+------+-----------+
| Fred   | 5    |           |
| Eric   | 60   |           |
| Wilma  | 30   | Accounts  |
| John   |      |           |
+--------+------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join with keys on both sides nullable
0: jdbc:farrago:> select *
. . . . . . . . > from oj.t1 left outer join oj.t2
. . . . . . . . > on t1.j = t2.j;
+----+----+-----+-----+
| I  | J  | I0  | J0  |
+----+----+-----+-----+
| 1  |    |     |     |
| 2  | 2  | 2   | 2   |
| 3  | 3  |     |     |
+----+----+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index join which requires swapped join inputs
0: jdbc:farrago:> select 
. . . . . . . . >     depts.name as dname,e.name as ename
. . . . . . . . > from 
. . . . . . . . >     depts 
. . . . . . . . > inner join 
. . . . . . . . >     (select name,age - 20 as age from emps) e
. . . . . . . . > on 
. . . . . . . . >     e.age=depts.deptno
. . . . . . . . > order by 1,2;
+-----------+--------+
|   DNAME   | ENAME  |
+-----------+--------+
| Accounts  | Wilma  |
+-----------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- csv format is nicest for query plans
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Note that we explain some queries both with and without order by;
0: jdbc:farrago:> -- with to make sure what we executed above was using the correct plan
0: jdbc:farrago:> -- without to make sure that the order by doesn't affect other
0: jdbc:farrago:> -- aspects of optimization.
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=20;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > 20;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[20], expr#3=['+'], expr#4=[null], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno >= 20;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=['+'], expr#4=[null], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno < 20;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['-'], expr#2=[null], expr#3=[')'], expr#4=[20], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno <= 20;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['-'], expr#2=[null], expr#3=[']'], expr#4=[20], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno between 20 and 30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=[']'], expr#4=[30], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > 20 and deptno < 30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[20], expr#3=[')'], expr#4=[30], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno < 20 or deptno between 30 and 40;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterConcatenateRel(all=[true])'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['-'], expr#2=[null], expr#3=[')'], expr#4=[20], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'            IterOneRowRel'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[30], expr#3=[']'], expr#4=[40], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=20 and deptno=30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[null], expr#3=[')'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps where deptno=20 order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..9=[{inputs}], NAME=[$t1])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'            IteratorToFennelConverter'
'              IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'                IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps where deptno=20 and gender='M';
'column0'
'IterCalcRel(expr#0..9=[{inputs}], expr#10=[_ISO-8859-1'M'], expr#11=[=($t3, $t10)], NAME=[$t1], $condition=[$t11])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps where empid=3;
'column0'
'IterCalcRel(expr#0..9=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$UNIQUE_KEY$EMPID], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[3], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select gender from emps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[3]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select gender from emps order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[3]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps order by 1;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[true])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name,gender,deptno,empno from emps order by 3,4;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 3, 2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[true])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select depts.name as dname,emps.name as ename
. . . . . . . . > from emps inner join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..11=[{inputs}], DNAME=[$t11], ENAME=[$t1])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]], inputDirectiveProj=[[]])'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select depts.name as dname,emps.name as ename
. . . . . . . . > from emps left outer join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..11=[{inputs}], DNAME=[$t11], ENAME=[$t1])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2]], inputJoinProj=[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]], inputDirectiveProj=[[]])'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.deptno
. . . . . . . . > order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..11=[{inputs}], ENAME=[$t3], DNAME=[$t1])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[true], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select emps.name as ename,depts.name as dname
. . . . . . . . > from depts inner join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..11=[{inputs}], ENAME=[$t3], DNAME=[$t1])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2, 3]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'            FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$UNIQUE_KEY$EMPID], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'              FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..11=[{inputs}], ENAME=[$t3], DNAME=[$t1])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2, 3]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'            FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$UNIQUE_KEY$EMPID], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'              FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > inner join depts on e.age = depts.deptno;
'column0'
'IterCalcRel(expr#0..3=[{inputs}], proj#0..1=[{exprs}], DNAME=[$t3])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..9=[{inputs}], expr#10=[20], expr#11=[-($t6, $t10)], expr#12=[IS NOT NULL($t11)], expr#13=[CAST($t11):INTEGER NOT NULL], NAME=[$t1], AGE=[$t11], DEPTNO=[$t13], $condition=[$t12])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > left outer join depts on e.age = depts.deptno;
'column0'
'IterCalcRel(expr#0..3=[{inputs}], proj#0..1=[{exprs}], DNAME=[$t3])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..9=[{inputs}], expr#10=[20], expr#11=[-($t6, $t10)], NAME=[$t1], AGE=[$t11])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select 
. . . . . . . . >     depts.name as dname,e.name as ename
. . . . . . . . > from 
. . . . . . . . >     depts 
. . . . . . . . > inner join 
. . . . . . . . >     (select name,age - 20 as age from emps) e
. . . . . . . . > on 
. . . . . . . . >     e.age=depts.deptno
. . . . . . . . > order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..3=[{inputs}], DNAME=[$t3], ENAME=[$t0])'
'        FennelToIteratorConverter'
'          FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'            IteratorToFennelConverter'
'              IterCalcRel(expr#0..9=[{inputs}], expr#10=[20], expr#11=[-($t6, $t10)], expr#12=[IS NOT NULL($t11)], expr#13=[CAST($t11):INTEGER NOT NULL], NAME=[$t1], AGE=[$t11], DEPTNO=[$t13], $condition=[$t12])'
'                FennelToIteratorConverter'
'                  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select *
. . . . . . . . > from oj.t1 left outer join oj.t2
. . . . . . . . > on t1.j = t2.j;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T2]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T2$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T2]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T2$SYS$UNIQUE_KEY$J], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      FtrsIndexScanRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T1$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- can only explain plan for dynamic parameter search
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=?;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], NAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[?0], expr#3=[']'], expr#4=[IS NOT NULL($t2)], expr#5=[AND($t4, $t4)], $f0=[$t1], $f1=[$t2], $f2=[$t3], $f3=[$t2], $condition=[$t5])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> ----------------------------------------------
0: jdbc:farrago:> -- LucidDB column store bitmap indexes test --
0: jdbc:farrago:> ----------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> drop schema lbm cascade;
Error: DDL validation error near line 1, column 13: Reference to unknown schema "LOCALDB"."LBM" (state=,code=0)
0: jdbc:farrago:> create schema lbm;
0: jdbc:farrago:> set schema 'lbm';
0: jdbc:farrago:> set path 'lbm';
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> -- Some ftrs tests to compare bahevior against --
0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table ftrsemps cascade;
Error: DDL validation error near line 1, column 12: Reference to unknown table "FTRSEMPS" (state=,code=0)
0: jdbc:farrago:> create table ftrsemps(
. . . . . . . . >     empno integer not null constraint empno_pk primary key,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create index deptno_ix on ftrsemps(deptno);
0: jdbc:farrago:> create index ename_ix on ftrsemps(ename);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into ftrsemps 
. . . . . . . . > select empno+deptno*1000, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no sarg pred
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- the most simple case
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[2], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO: this case does not work
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = -2;
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[-($t3)], expr#5=[=($t2, $t4)], proj#0..2=[{exprs}], $condition=[$t5])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- range predicate uses index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno > 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[2], expr#3=['+'], expr#4=[null], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Merge ranges on the same index key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 or deptno = 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterConcatenateRel(all=[true])'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[2], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[10], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Should have only one range
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 10 or deptno > 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[2], expr#3=['+'], expr#4=[null], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- recognize AND on the same key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno > 2 and deptno < 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[2], expr#3=[')'], expr#4=[10], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure NULL range from sarg analysis is working
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 and deptno = 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[null], expr#3=[')'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Index only access:
0: jdbc:farrago:> -- It seems index only access is not used here.
0: jdbc:farrago:> explain plan for
. . . . . . . . > select deptno from ftrsemps where deptno = 2;
'column0'
'IterCalcRel(expr#0..2=[{inputs}], DEPTNO=[$t2])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[2], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- simple comparison predicate
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from ftrsemps where ename = 'ADAM';
'column0'
'IterCalcRel(expr#0..2=[{inputs}], ENAME=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[ENAME_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[_ISO-8859-1'ADAM'], expr#3=[']'], expr#4=[CAST($t2):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- predicate specific to character types
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from ftrsemps where ename like 'ADAM%';
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[_ISO-8859-1'ADAM%'], expr#4=[LIKE($t1, $t3)], ENAME=[$t1], $condition=[$t4])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- AND: does recognize one index, but not two
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 and ename = 'ADAM';
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[_ISO-8859-1'ADAM'], expr#4=[=($t1, $t3)], proj#0..2=[{exprs}], $condition=[$t4])'
'  FennelToIteratorConverter'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[2], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- OR: does not use any index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 or ename = 'ADAM';
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=[_ISO-8859-1'ADAM'], expr#6=[=($t1, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table ftrsemps cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------------------------
0: jdbc:farrago:> -- Part 1. index created on empty column store table --
0: jdbc:farrago:> -------------------------------------------------------
0: jdbc:farrago:> drop table lbmemps cascade;
Error: DDL validation error near line 1, column 12: Reference to unknown table "LBMEMPS" (state=,code=0)
0: jdbc:farrago:> create table lbmemps(
. . . . . . . . >     empno integer,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer)
. . . . . . . . >     server sys_column_store_data_server
. . . . . . . . > create index deptno_ix on lbmemps(deptno)
. . . . . . . . > create index ename_ix on lbmemps(ename)
. . . . . . . . > create index ename_ix on lbmemps(ename)
. . . . . . . . > create index empno_ix2 on lbmemps(empno)
. . . . . . . . > ;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- create index on existing column store table does not work yet
0: jdbc:farrago:> -- create index ename_ix on lbmemps(ename);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- two indexes on the same column
0: jdbc:farrago:> -- create index on exisitng column store table does not work yet
0: jdbc:farrago:> -- create index empno_ix2 on lbmemps(empno);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lbmemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> insert into lbmemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no sarg pred
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- the most simple case
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO: this case does not work
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = -2;
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[-($t3)], expr#5=[=($t2, $t4)], proj#0..2=[{exprs}], $condition=[$t5])'
'  FennelToIteratorConverter'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- range predicate uses index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno > 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[20], expr#3=['+'], expr#4=[null], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Merge ranges on the same index key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 10 or deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[10], expr#4=[=($t2, $t3)], expr#5=[20], expr#6=[=($t2, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Should have only one range
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 20 or deptno > 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[10], expr#3=['+'], expr#4=[null], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- recognize AND on the same key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno > 10 and deptno <= 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[10], expr#3=[']'], expr#4=[20], expr#5=[CAST($t2):INTEGER], expr#6=[CAST($t4):INTEGER], $f0=[$t1], $f1=[$t5], $f2=[$t3], $f3=[$t6])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure NULL range from sarg analysis is working
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 20 and deptno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0=[{inputs}], expr#1=['('], expr#2=[null], expr#3=[')'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'            IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 20 and deptno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO implement index only access.
0: jdbc:farrago:> explain plan for
. . . . . . . . > select deptno from lbmemps where deptno = 20 order by deptno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], DEPTNO=[$t2])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'            LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'              IteratorToFennelConverter'
'                IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[20], expr#3=[']'], expr#4=[CAST($t2):INTEGER], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'                  IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- simple comparison predicate
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from lbmemps where ename = 'ADAM' order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], ENAME=[$t1])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'            LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], index=[ENAME_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'              IteratorToFennelConverter'
'                IterCalcRel(expr#0=[{inputs}], expr#1=['['], expr#2=[_ISO-8859-1'ADAM'], expr#3=[']'], expr#4=[CAST($t2):VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary"], $f0=[$t1], $f1=[$t4], $f2=[$t3], $f3=[$t4])'
'                  IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- predicate specific to character types
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from lbmemps where ename like 'ADAM%' order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[_ISO-8859-1'ADAM%'], expr#4=[LIKE($t1, $t3)], ENAME=[$t1], $condition=[$t4])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO AND: currently does recognize one index, but not two
0: jdbc:farrago:> -- TODO: this is currently not working(not even one index)
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 2 and ename = 'ADAM' order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=[_ISO-8859-1'ADAM'], expr#6=[=($t1, $t5)], expr#7=[AND($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO OR: currently does not use any index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 2 or ename = 'ADAM' order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=[_ISO-8859-1'ADAM'], expr#6=[=($t1, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> -----------------------------------------------------------
0: jdbc:farrago:> -- Part 2. index created on non-empty column store table --
0: jdbc:farrago:> -----------------------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> --------------
0: jdbc:farrago:> -- Clean up --
0: jdbc:farrago:> --------------
0: jdbc:farrago:> drop schema lbm cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> 
0: jdbc:farrago:> -- End index.sql
0: jdbc:farrago:> 
0: jdbc:farrago:> !quit
