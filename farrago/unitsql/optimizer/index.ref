0: jdbc:farrago:> -- $Id$
0: jdbc:farrago:> -- Test queries which make use of indexes
0: jdbc:farrago:> 
0: jdbc:farrago:> -- use Volcano for these because Hep can't do a very good job
0: jdbc:farrago:> -- with many of the patterns, and it's a good workout for Volcano
0: jdbc:farrago:> alter session implementation add jar sys_boot.sys_boot.volcano_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> create schema oj;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table oj.t1(i int not null primary key, j int unique);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table oj.t2(i int not null primary key, j int unique);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into oj.t1 values (1,null), (2, 2), (3, 3);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into oj.t2 values (1,null), (2, 2), (4, 4);
0: jdbc:farrago:> 
0: jdbc:farrago:> create table oj.t3(v varchar(15) not null primary key);
0: jdbc:farrago:> insert into oj.t3 
. . . . . . . . > values ('Mesmer'), ('Houdini'), ('Copperfield'), ('Mandrake');
0: jdbc:farrago:> 
0: jdbc:farrago:> create table oj.t4(i int not null primary key, j boolean unique);
0: jdbc:farrago:> insert into oj.t4 values (1, null), (2, true), (3, false);
0: jdbc:farrago:> 
0: jdbc:farrago:> set schema 'sales';
0: jdbc:farrago:> 
0: jdbc:farrago:> -- force usage of Java calculator
0: jdbc:farrago:> alter system set "calcVirtualMachine" = 'CALCVM_JAVA';
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique clustered index
0: jdbc:farrago:> select name from depts where deptno=20;
+------------+
|    NAME    |
+------------+
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno > 20 order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno >= 20 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno < 20 order by name;
+--------+
|  NAME  |
+--------+
| Sales  |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno <= 20 order by name;
+------------+
|    NAME    |
+------------+
| Marketing  |
| Sales      |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno between 20 and 30 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno > 20 and deptno < 30 order by name;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno < 20 or deptno between 30 and 40 
. . . . . . . . > order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
| Sales     |
+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> select name from depts where deptno in (20,30) order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- scaling
0: jdbc:farrago:> select name from depts where deptno=20.00;
+------------+
|    NAME    |
+------------+
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- scaling with rounding:  strictness change
0: jdbc:farrago:> select name from depts where deptno > 19.6 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- scaling with rounding:  strictness change the other way
0: jdbc:farrago:> select name from depts where deptno >= 20.1 order by name;
+-----------+
|   NAME    |
+-----------+
| Accounts  |
+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no match:  overflow
0: jdbc:farrago:> select name from depts where deptno=20000000000000;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no match:  overflow
0: jdbc:farrago:> select name from depts where deptno>20000000000000;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- all match:  negative overflow
0: jdbc:farrago:> select name from depts where deptno>-20000000000000 order by name;
+------------+
|    NAME    |
+------------+
| Accounts   |
| Marketing  |
| Sales      |
+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no match:  make sure truncation doesn't make it look like one
0: jdbc:farrago:> select v from oj.t3 where v='Houdini                 xyz';
+----+
| V  |
+----+
+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no match for Houdini:  make sure truncation doesn't make it look like one
0: jdbc:farrago:> select v from oj.t3 where v >= 'Houdini                 xyz'
. . . . . . . . > order by v;
+--------------+
|      V       |
+--------------+
| Mandrake     |
| Mesmer       |
+--------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- match for Houdini:  make sure truncation doesn't obscure that
0: jdbc:farrago:> select v from oj.t3 where v <= 'Houdini                 xyz'
. . . . . . . . > order by v;
+--------------+
|      V       |
+--------------+
| Copperfield  |
| Houdini      |
+--------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- contradiction:  empty range
0: jdbc:farrago:> select name from depts where deptno=20 and deptno=30;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search beyond end
0: jdbc:farrago:> select name from depts where deptno > 50 order by name;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search before start
0: jdbc:farrago:> select name from depts where deptno < 5 order by name;
+-------+
| NAME  |
+-------+
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique clustered index with a prefix key
0: jdbc:farrago:> select name from emps where deptno=20 order by 1;
+--------+
|  NAME  |
+--------+
| Eric   |
| Wilma  |
+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique clustered index with a prefix key and a non-indexable condition
0: jdbc:farrago:> select name from emps where deptno=20 and gender='M';
+-------+
| NAME  |
+-------+
| Eric  |
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- search unique unclustered index
0: jdbc:farrago:> select name from emps where empid=3;
+-------+
| NAME  |
+-------+
| Eric  |
+-------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- project columns covered by clustered index
0: jdbc:farrago:> select gender from emps order by 1;
+---------+
| GENDER  |
+---------+
|         |
| F       |
| M       |
| M       |
+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- project columns covered by an unclustered index
0: jdbc:farrago:> select name from emps order by 1;
+--------+
|  NAME  |
+--------+
| Eric   |
| Fred   |
| John   |
| Wilma  |
+--------+
0: jdbc:farrago:> select upper(name) from emps order by 1;
+---------+
| EXPR$0  |
+---------+
| ERIC    |
| FRED    |
| JOHN    |
| WILMA   |
+---------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- sort multiple columns covered by an unclustered index
0: jdbc:farrago:> select name,gender,deptno,empno from emps order by 3,4;
+--------+---------+---------+--------+
|  NAME  | GENDER  | DEPTNO  | EMPNO  |
+--------+---------+---------+--------+
| Fred   |         | 10      | 100    |
| Eric   | M       | 20      | 110    |
| Wilma  | F       | 20      | 120    |
| John   | M       | 40      | 110    |
+--------+---------+---------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- unique inner join via clustered index
0: jdbc:farrago:> select depts.name as dname,emps.name as ename
. . . . . . . . > from emps inner join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
+------------+--------+
|   DNAME    | ENAME  |
+------------+--------+
| Marketing  | Eric   |
| Marketing  | Wilma  |
| Sales      | Fred   |
+------------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- unique left outer join via clustered index
0: jdbc:farrago:> select depts.name as dname,emps.name as ename
. . . . . . . . > from emps left outer join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
+------------+--------+
|   DNAME    | ENAME  |
+------------+--------+
|            | John   |
| Marketing  | Eric   |
| Marketing  | Wilma  |
| Sales      | Fred   |
+------------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- left outer join via clustered index prefix
0: jdbc:farrago:> select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.deptno
. . . . . . . . > order by 2,1;
+--------+------------+
| ENAME  |   DNAME    |
+--------+------------+
|        | Accounts   |
| Eric   | Marketing  |
| Wilma  | Marketing  |
| Fred   | Sales      |
+--------+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- inner join via unclustered index
0: jdbc:farrago:> select emps.name as ename,depts.name as dname
. . . . . . . . > from depts inner join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
+--------+-----------+
| ENAME  |   DNAME   |
+--------+-----------+
| Fred   | Accounts  |
+--------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- left outer join via unclustered index
0: jdbc:farrago:> select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
+--------+------------+
| ENAME  |   DNAME    |
+--------+------------+
| Fred   | Accounts   |
|        | Marketing  |
|        | Sales      |
+--------+------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- inner join on nullable key
0: jdbc:farrago:> select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > inner join depts on e.age = depts.deptno;
+--------+------+-----------+
| ENAME  | AGE  |   DNAME   |
+--------+------+-----------+
| Wilma  | 30   | Accounts  |
+--------+------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join on nullable key
0: jdbc:farrago:> select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > left outer join depts on e.age = depts.deptno;
+--------+------+-----------+
| ENAME  | AGE  |   DNAME   |
+--------+------+-----------+
| Fred   | 5    |           |
| Eric   | 60   |           |
| Wilma  | 30   | Accounts  |
| John   |      |           |
+--------+------+-----------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- outer join with keys on both sides nullable
0: jdbc:farrago:> select *
. . . . . . . . > from oj.t1 left outer join oj.t2
. . . . . . . . > on t1.j = t2.j;
+----+----+-----+-----+
| I  | J  | I0  | J0  |
+----+----+-----+-----+
| 1  |    |     |     |
| 2  | 2  | 2   | 2   |
| 3  | 3  |     |     |
+----+----+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index join which requires swapped join inputs
0: jdbc:farrago:> select 
. . . . . . . . >     depts.name as dname,e.name as ename
. . . . . . . . > from 
. . . . . . . . >     depts 
. . . . . . . . > inner join 
. . . . . . . . >     (select name,age - 20 as age from emps) e
. . . . . . . . > on 
. . . . . . . . >     e.age=depts.deptno
. . . . . . . . > order by 1,2;
+-----------+--------+
|   DNAME   | ENAME  |
+-----------+--------+
| Accounts  | Wilma  |
+-----------+--------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- is null predicate
0: jdbc:farrago:> select * from oj.t1 where j is null;
+----+----+
| I  | J  |
+----+----+
| 1  |    |
+----+----+
0: jdbc:farrago:> select * from oj.t1 where not(j is null);
+----+----+
| I  | J  |
+----+----+
| 2  | 2  |
| 3  | 3  |
+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- predicates on boolean
0: jdbc:farrago:> select * from oj.t4 where j is true;
+----+-------+
| I  |   J   |
+----+-------+
| 2  | true  |
+----+-------+
0: jdbc:farrago:> select * from oj.t4 where j is false;
+----+--------+
| I  |   J    |
+----+--------+
| 3  | false  |
+----+--------+
0: jdbc:farrago:> select * from oj.t4 where j is unknown;
+----+----+
| I  | J  |
+----+----+
| 1  |    |
+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- csv format is nicest for query plans
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Note that we explain some queries both with and without order by;
0: jdbc:farrago:> -- with to make sure what we executed above was using the correct plan
0: jdbc:farrago:> -- without to make sure that the order by doesn't affect other
0: jdbc:farrago:> -- aspects of optimization.
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 20, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno >= 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno < 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'-', null, _ISO-8859-1')', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno <= 20;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'-', null, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno between 20 and 30;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 30 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > 20 and deptno < 30;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 20, _ISO-8859-1')', 30 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno < 20 or deptno between 30 and 40;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'-', null, _ISO-8859-1')', 20 }, { _ISO-8859-1'[', 30, _ISO-8859-1']', 40 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno in (20,30) order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }, { _ISO-8859-1'[', 30, _ISO-8859-1']', 30 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=20.00;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > 19.6 order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno >= 20.1 order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 20, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=20000000000000;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1')', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno>20000000000000;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1')', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno>-20000000000000 order by name;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'-', null, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select v from oj.t3 where v='Houdini                 xyz';
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T3]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T3$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'    FennelValuesRel(tuples=[[{ _ISO-8859-1'(', _ISO-8859-1'Houdini', _ISO-8859-1']', _ISO-8859-1'Houdini' }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select v from oj.t3 where v >= 'Houdini                 xyz'
. . . . . . . . > order by v;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T3]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T3$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', _ISO-8859-1'Houdini', _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select v from oj.t3 where v <= 'Houdini                 xyz'
. . . . . . . . > order by v;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T3]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T3$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'-', null, _ISO-8859-1']', _ISO-8859-1'Houdini' }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=20 and deptno=30;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1')', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps where deptno=20 order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps where deptno=20 and gender='M';
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0]], filterOp=[COMP_EQ], filterOrdinals=[[2]], filterTuple=[[_ISO-8859-1'M']], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2, 3]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps where empid=3;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 5]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$UNIQUE_KEY$EMPID], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 3, _ISO-8859-1']', 3 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select gender from emps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[3]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select gender from emps order by 1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[3]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select upper(name) from emps;
'column0'
'IterCalcRel(expr#0=[{inputs}], expr#1=[UPPER($t0)], EXPR$0=[$t1])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from emps order by 1;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1]], index=[EMPS_UX], preserveOrder=[true])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name,gender,deptno,empno from emps order by 3,4;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 3, 2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[true])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select depts.name as dname,emps.name as ename
. . . . . . . . > from emps inner join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0, 1]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select depts.name as dname,emps.name as ename
. . . . . . . . > from emps left outer join depts
. . . . . . . . > on emps.deptno=depts.deptno
. . . . . . . . > order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" DNAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[[0, 1]], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[EMPS_UX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.deptno
. . . . . . . . > order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 2]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[true], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select emps.name as ename,depts.name as dname
. . . . . . . . > from depts inner join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 5]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2, 3]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$UNIQUE_KEY$EMPID], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select emps.name as ename,depts.name as dname
. . . . . . . . > from depts left outer join emps
. . . . . . . . > on depts.deptno=emps.empid
. . . . . . . . > order by 2,1;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[1, 0]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[2, 1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 5]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2, 3]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        FtrsIndexSearchRel(table=[[LOCALDB, SALES, EMPS]], projection=[[2, 0]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$UNIQUE_KEY$EMPID], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[0]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'          FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > inner join depts on e.age = depts.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 1, 3]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME, INTEGER AGE, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..1=[{inputs}], expr#2=[20], expr#3=[-($t1, $t2)], expr#4=[IS NOT NULL($t3)], expr#5=[CAST($t3):INTEGER NOT NULL], NAME=[$t0], AGE=[$t3], DEPTNO=[$t5], $condition=[$t4])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select e.name as ename,e.age,depts.name as dname
. . . . . . . . > from
. . . . . . . . > (select name,age - 20 as age from emps) e
. . . . . . . . > left outer join depts on e.age = depts.deptno;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 1, 3]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME, INTEGER AGE, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" DNAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0..1=[{inputs}], expr#2=[20], expr#3=[-($t1, $t2)], NAME=[$t0], AGE=[$t3])'
'          FennelToIteratorConverter'
'            FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select 
. . . . . . . . >     depts.name as dname,e.name as ename
. . . . . . . . > from 
. . . . . . . . >     depts 
. . . . . . . . > inner join 
. . . . . . . . >     (select name,age - 20 as age from emps) e
. . . . . . . . > on 
. . . . . . . . >     e.age=depts.deptno
. . . . . . . . > order by 1,2;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0, 1]], discardDuplicates=[false])'
'    FennelReshapeRel(projection=[[3, 0]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL DNAME, VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL ENAME) NOT NULL])'
'      FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'        IteratorToFennelConverter'
'          IterCalcRel(expr#0..1=[{inputs}], expr#2=[20], expr#3=[-($t1, $t2)], expr#4=[IS NOT NULL($t3)], expr#5=[CAST($t3):INTEGER NOT NULL], NAME=[$t0], AGE=[$t3], DEPTNO=[$t5], $condition=[$t4])'
'            FennelToIteratorConverter'
'              FtrsIndexScanRel(table=[[LOCALDB, SALES, EMPS]], projection=[[1, 6]], index=[SYS$CONSTRAINT_INDEX$EMPS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select *
. . . . . . . . > from oj.t1 left outer join oj.t2
. . . . . . . . > on t1.j = t2.j;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T2]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T2$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[2]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T2]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T2$SYS$UNIQUE_KEY$J], uniqueKey=[true], preserveOrder=[false], outer=[true], inputKeyProj=[[1]], inputJoinProj=[[0, 1]], inputDirectiveProj=[[]])'
'      FtrsIndexScanRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T1$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for select * from oj.t1 where j is null;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T1$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T1$SYS$UNIQUE_KEY$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', null, _ISO-8859-1']', null }]])'
0: jdbc:farrago:> explain plan for select * from oj.t1 where not(j is null);
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T1$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T1]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T1$SYS$UNIQUE_KEY$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for select * from oj.t4 where j is true;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T4$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T4$SYS$UNIQUE_KEY$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', true, _ISO-8859-1']', true }]])'
0: jdbc:farrago:> explain plan for select * from oj.t4 where j is false;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T4$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T4$SYS$UNIQUE_KEY$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', false, _ISO-8859-1']', false }]])'
0: jdbc:farrago:> explain plan for select * from oj.t4 where j is unknown;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[*], index=[SYS$CONSTRAINT_INDEX$T4$SYS$PRIMARY_KEY], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, OJ, T4]], projection=[[0]], index=[SYS$CONSTRAINT_INDEX$T4$SYS$UNIQUE_KEY$J], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', null, _ISO-8859-1']', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- can only explain plan for dynamic parameter search
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno=?;
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=[_ISO-8859-1'['], expr#2=[?0], expr#3=[_ISO-8859-1']'], expr#4=[IS NOT NULL($t2)], expr#5=[AND($t4, $t4)], $f0=[$t1], $f1=[$t2], $f2=[$t3], $f3=[$t2], $condition=[$t5])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- can't yet support usage of index when predicate on dynamic param
0: jdbc:farrago:> -- is combined with another predicate on same column;
0: jdbc:farrago:> -- at least make sure we recompose it correctly (FRG-72)
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > ? and deptno < 30;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[?0], expr#3=[>($t0, $t2)], expr#4=[30], expr#5=[<($t0, $t4)], expr#6=[AND($t3, $t5)], NAME=[$t1], $condition=[$t6])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > ? and deptno < ?;
'column0'
'IterCalcRel(expr#0..1=[{inputs}], expr#2=[?0], expr#3=[>($t0, $t2)], expr#4=[?1], expr#5=[<($t0, $t4)], expr#6=[AND($t3, $t5)], NAME=[$t1], $condition=[$t6])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- this one should work because predicates are on different columns
0: jdbc:farrago:> explain plan for
. . . . . . . . > select name from depts where deptno > ? and name='Hysteria';
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[1]], filterOp=[COMP_EQ], filterOrdinals=[[1]], filterTuple=[[_ISO-8859-1'Hysteria']], outputRowType=[RecordType(VARCHAR(128) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" NOT NULL NAME) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, SALES, DEPTS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPTS$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      IteratorToFennelConverter'
'        IterCalcRel(expr#0=[{inputs}], expr#1=[?0], expr#2=[IS NOT NULL($t1)], expr#3=[_ISO-8859-1'('], expr#4=[_ISO-8859-1'+'], expr#5=[null], expr#6=[CAST($t5):INTEGER], $f0=[$t3], $f1=[$t1], $f2=[$t4], $f3=[$t6], $condition=[$t2])'
'          IterOneRowRel'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- FRG-198
0: jdbc:farrago:> create table oj.frg198(a char(5) primary key, b char(5));
0: jdbc:farrago:> insert into oj.frg198 values ('t1a1', 't1a1'), ('t2a2', 't2a2');
0: jdbc:farrago:> select * from oj.frg198 where a > 't1a1';
'A','B'
't2a2 ','t2a2 '
0: jdbc:farrago:> 
0: jdbc:farrago:> ----------------------------------------------
0: jdbc:farrago:> -- LucidDB column store bitmap indexes test --
0: jdbc:farrago:> ----------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> create schema lbm;
0: jdbc:farrago:> set schema 'lbm';
0: jdbc:farrago:> set path 'lbm';
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> -- Some ftrs tests to compare behavior against --
0: jdbc:farrago:> -------------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> create table ftrsemps(
. . . . . . . . >     empno integer not null constraint empno_pk primary key,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer);
0: jdbc:farrago:> 
0: jdbc:farrago:> create index deptno_ix on ftrsemps(deptno);
0: jdbc:farrago:> create index ename_ix on ftrsemps(ename);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into ftrsemps 
. . . . . . . . > select empno+deptno*1000, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no sarg pred
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- the most simple case
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- negative number in index search
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = -2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', -2, _ISO-8859-1']', -2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- range predicate uses index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno > 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 2, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Merge ranges on the same index key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 or deptno = 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }, { _ISO-8859-1'[', 10, _ISO-8859-1']', 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Should have only one range
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 10 or deptno > 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 2, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- recognize AND on the same key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno > 2 and deptno < 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 2, _ISO-8859-1')', 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure NULL range from sarg analysis is working
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 and deptno = 10;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1')', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Index only access:
0: jdbc:farrago:> -- It seems index only access is not used here.
0: jdbc:farrago:> explain plan for
. . . . . . . . > select deptno from ftrsemps where deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[2]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'    FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- simple comparison predicate
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from ftrsemps where ename = 'ADAM';
'column0'
'FennelToIteratorConverter'
'  FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[1]], index=[ENAME_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'    FennelValuesRel(tuples=[[{ _ISO-8859-1'[', _ISO-8859-1'ADAM', _ISO-8859-1']', _ISO-8859-1'ADAM' }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- predicate specific to character types
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from ftrsemps where ename like 'ADAM%';
'column0'
'IterCalcRel(expr#0=[{inputs}], expr#1=[_ISO-8859-1'ADAM%'], expr#2=[LIKE($t0, $t1)], ENAME=[$t0], $condition=[$t2])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[1]], index=[ENAME_IX], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- AND: does recognize one index, but not two
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 and ename = 'ADAM';
'column0'
'FennelToIteratorConverter'
'  FennelReshapeRel(projection=[[0, 1, 2]], filterOp=[COMP_EQ], filterOrdinals=[[1]], filterTuple=[[_ISO-8859-1'ADAM']], outputRowType=[RecordType(INTEGER NOT NULL EMPNO, VARCHAR(40) CHARACTER SET "ISO-8859-1" COLLATE "ISO-8859-1$en_US$primary" ENAME, INTEGER DEPTNO) NOT NULL])'
'    FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]])'
'      FtrsIndexSearchRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[[0]], index=[DEPTNO_IX], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- OR: does not use any index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from ftrsemps where deptno = 2 or ename = 'ADAM';
'column0'
'IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=[_ISO-8859-1'ADAM'], expr#6=[=($t1, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'  FennelToIteratorConverter'
'    FtrsIndexScanRel(table=[[LOCALDB, LBM, FTRSEMPS]], projection=[*], index=[SYS$CONSTRAINT_INDEX$FTRSEMPS$EMPNO_PK], preserveOrder=[false])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table ftrsemps cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> -------------------------------------------------------
0: jdbc:farrago:> -- Part 1. index created on empty column store table --
0: jdbc:farrago:> -------------------------------------------------------
0: jdbc:farrago:> -- Use LucidDB personality
0: jdbc:farrago:> alter session implementation set jar sys_boot.sys_boot.luciddb_plugin;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lbmemps(
. . . . . . . . >     empno integer not null,
. . . . . . . . >     ename varchar(40),
. . . . . . . . >     deptno integer)
. . . . . . . . >     server sys_column_store_data_server
. . . . . . . . > create index empno_ix on lbmemps(empno, deptno)
. . . . . . . . > create index ename_ix on lbmemps(ename)
. . . . . . . . > create index deptno_ix on lbmemps(deptno)
. . . . . . . . > ;
0: jdbc:farrago:> 
0: jdbc:farrago:> create table lbmdepts(
. . . . . . . . >     deptno integer)
. . . . . . . . > server sys_column_store_data_server;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- create index on existing column store table does not work yet
0: jdbc:farrago:> -- create index ename_ix on lbmemps(ename);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- two indexes on the same column
0: jdbc:farrago:> -- create index on exisitng column store table does not work yet
0: jdbc:farrago:> -- create index empno_ix2 on lbmemps(empno);
0: jdbc:farrago:> 
0: jdbc:farrago:> insert into lbmemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> insert into lbmemps select empno, name, deptno from sales.emps;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> 
0: jdbc:farrago:> -- no sarg pred
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','John','40'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- the most simple case
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- negative number in index search
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = -2;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'    LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', -2, _ISO-8859-1']', -2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = -2;
'EMPNO','ENAME','DEPTNO'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- range predicate uses index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno > 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 20, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno > 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','John','40'
'110','John','40'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Merge ranges on the same index key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 10 or deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 10, _ISO-8859-1']', 10 }, { _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 10 or deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Should have only one range
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 20 or deptno > 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 10, _ISO-8859-1'+', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 20 or deptno > 10 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','John','40'
'110','Eric','20'
'110','John','40'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- recognize AND on the same key
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno > 10 and deptno <= 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 10, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno > 10 and deptno <= 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure NULL range from sarg analysis is working
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 20 and deptno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1')', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 20 and deptno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- make sure Merge is allocated on top of index search if 
0: jdbc:farrago:> -- partial key is used in search
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where empno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 10, _ISO-8859-1']', 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where empno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where empno = 10 and empno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'(', null, _ISO-8859-1')', null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where empno = 10 and empno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- IN on small values list
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from lbmemps where deptno in (20, 30)
. . . . . . . . > order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }, { _ISO-8859-1'[', 30, _ISO-8859-1']', 30 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select ename from lbmemps where deptno in (20, 30)
. . . . . . . . > order by ename;
'ENAME'
'Eric'
'Eric'
'Wilma'
'Wilma'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- OR on same column is supported
0: jdbc:farrago:> explain plan for
. . . . . . . . > select *
. . . . . . . . > from lbmemps
. . . . . . . . > where (empno = 110 or empno = 120) and (deptno = 10 or deptno = 20)
. . . . . . . . > order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'        LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[3])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 10, _ISO-8859-1']', 10 }, { _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
'        LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[4])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 110, _ISO-8859-1']', 110 }, { _ISO-8859-1'[', 120, _ISO-8859-1']', 120 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select *
. . . . . . . . > from lbmemps
. . . . . . . . > where (empno = 110 or empno = 120) and (deptno = 10 or deptno = 20)
. . . . . . . . > order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index only access.
0: jdbc:farrago:> explain plan for
. . . . . . . . > select deptno from lbmemps where deptno = 20 order by deptno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsNormalizerRel'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select deptno from lbmemps where deptno = 20 order by deptno;
'DEPTNO'
'20'
'20'
'20'
'20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- simple comparison predicate
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from lbmemps where ename = 'ADAM' order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsNormalizerRel'
'      LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[ENAME_IX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', _ISO-8859-1'ADAM', _ISO-8859-1']', _ISO-8859-1'ADAM' }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select ename from lbmemps where ename = 'ADAM' order by ename;
'ENAME'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index on char types:
0: jdbc:farrago:> -- predicate specific to character types
0: jdbc:farrago:> explain plan for
. . . . . . . . > select ename from lbmemps where ename like 'ADAM%' order by ename;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0=[{inputs}], expr#1=[_ISO-8859-1'ADAM%'], expr#2=[LIKE($t0, $t1)], ENAME=[$t0], $condition=[$t2])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select ename from lbmemps where ename like 'ADAM%' order by ename;
'ENAME'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 10 and ename = 'Fred' order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[ENAME_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', _ISO-8859-1'Fred', _ISO-8859-1']', _ISO-8859-1'Fred' }]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 10, _ISO-8859-1']', 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 10 and ename = 'Fred' order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- test composite key indexes
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where empno = 100 and deptno = 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 100, 10, _ISO-8859-1']', 100, 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where empno = 100 and deptno = 10 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 10 and empno = 100 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 100, 10, _ISO-8859-1']', 100, 10 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 10 and empno = 100 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where empno = 100 and deptno >= 10 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 100, 10, _ISO-8859-1'+', 100, null }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where empno = 100 and deptno >= 10 order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- test "not null" data type
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where empno between 100 and 200 and deptno = 20 order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
'        LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[3])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 100, _ISO-8859-1']', 200 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where empno between 100 and 200 and deptno = 20 order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
'120','Wilma','20'
'120','Wilma','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- test multiple inputs to Intersect
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * 
. . . . . . . . > from lbmemps
. . . . . . . . > where empno between 100 and 200 and deptno = 20 and ename = 'Eric'
. . . . . . . . > order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[ENAME_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', _ISO-8859-1'Eric', _ISO-8859-1']', _ISO-8859-1'Eric' }]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 20, _ISO-8859-1']', 20 }]])'
'        LcsIndexMergeRel(consumerSridParamId=[2], segmentLimitParamId=[1], ridLimitParamId=[3])'
'          LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[EMPNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 100, _ISO-8859-1']', 200 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * 
. . . . . . . . > from lbmemps
. . . . . . . . > where empno between 100 and 200 and deptno = 20 and ename = 'Eric'
. . . . . . . . > order by empno;
'EMPNO','ENAME','DEPTNO'
'110','Eric','20'
'110','Eric','20'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO OR: currently does not use any index access
0: jdbc:farrago:> explain plan for
. . . . . . . . > select * from lbmemps where deptno = 2 or ename = 'Fred' order by empno;
'column0'
'FennelToIteratorConverter'
'  FennelSortRel(key=[[0]], discardDuplicates=[false])'
'    IteratorToFennelConverter'
'      IterCalcRel(expr#0..2=[{inputs}], expr#3=[2], expr#4=[=($t2, $t3)], expr#5=[_ISO-8859-1'Fred'], expr#6=[=($t1, $t5)], expr#7=[OR($t4, $t6)], proj#0..2=[{exprs}], $condition=[$t7])'
'        FennelToIteratorConverter'
'          LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmemps where deptno = 2 or ename = 'Fred' order by empno;
'EMPNO','ENAME','DEPTNO'
'100','Fred','10'
'100','Fred','10'
0: jdbc:farrago:> 
0: jdbc:farrago:> ----------------------------------------------------------------------
0: jdbc:farrago:> -- Tests using multiple index keys with range searches on the last key
0: jdbc:farrago:> ----------------------------------------------------------------------
0: jdbc:farrago:> create table multikey(a int, b int) server sys_column_store_data_server;
0: jdbc:farrago:> insert into multikey values (0, 0);
0: jdbc:farrago:> insert into multikey values (1, 1);
0: jdbc:farrago:> insert into multikey values (1, 2);
0: jdbc:farrago:> insert into multikey values (1, 3);
0: jdbc:farrago:> insert into multikey values (1, 4);
0: jdbc:farrago:> insert into multikey values (2, 2);
0: jdbc:farrago:> create index imultikey on multikey(a, b);
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for select * from multikey where a = 1 and b > 1;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 1, 1, _ISO-8859-1'+', 1, null }]])'
0: jdbc:farrago:> explain plan for select * from multikey where a = 1 and b <= 3;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 1, null, _ISO-8859-1']', 1, 3 }]])'
0: jdbc:farrago:> explain plan for select * from multikey where a = 1 and b >= 2 and b < 4;
'column0'
'FennelToIteratorConverter'
'  LcsNormalizerRel'
'    LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])'
'      FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, 2, _ISO-8859-1')', 1, 4 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> select * from multikey where a = 1 and b > 1;
+----+----+
| A  | B  |
+----+----+
| 1  | 2  |
| 1  | 3  |
| 1  | 4  |
+----+----+
0: jdbc:farrago:> select * from multikey where a = 1 and b <= 3;
+----+----+
| A  | B  |
+----+----+
| 1  | 1  |
| 1  | 2  |
| 1  | 3  |
+----+----+
0: jdbc:farrago:> select * from multikey where a = 1 and b >= 2 and b < 4;
+----+----+
| A  | B  |
+----+----+
| 1  | 2  |
| 1  | 3  |
+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> ----------------------------
0: jdbc:farrago:> -- Tests of index only scans
0: jdbc:farrago:> ----------------------------
0: jdbc:farrago:> create table person(
. . . . . . . . >     id int primary key,
. . . . . . . . >     age int)
. . . . . . . . > server sys_column_store_data_server
. . . . . . . . > create index age_idx on person(age);
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index search
0: jdbc:farrago:> explain plan for
. . . . . . . . > select id from person where id = 30;
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                           column0                                                                                            |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                                                    |
|   LcsNormalizerRel                                                                                                                                                                           |
|     LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[SYS$CONSTRAINT_INDEX$PERSON$SYS$PRIMARY_KEY], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|       FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 30, _ISO-8859-1']', 30 }]])                                                                                                                 |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- index search with merge
0: jdbc:farrago:> explain plan for
. . . . . . . . > select id from person where id > 30;
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                           column0                                                                                            |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                                                    |
|   LcsNormalizerRel                                                                                                                                                                           |
|     LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[SYS$CONSTRAINT_INDEX$PERSON$SYS$PRIMARY_KEY], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|       FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 30, _ISO-8859-1'+', null }]])                                                                                                               |
+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- histogram type aggregate
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select age, count(*) from person group by age order by age;
+------------------------------------------------------------------------------------------------------------+
|                                                  column0                                                   |
+------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                  |
|   FennelSortRel(key=[[0]], discardDuplicates=[false])                                                      |
|     FennelRenameRel(fieldNames=[[AGE, EXPR$1]])                                                            |
|       LcsIndexAggRel(groupCount=[1], agg#0=[COUNT()])                                                      |
|         FennelRenameRel(fieldNames=[[$f0, SRID, SegmentDesc, Segment]])                                    |
|           LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]])  |
+------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- cardinality type aggregate
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select count(distinct(age)) from person;
+------------------------------------------------------------------------------------------------------------+
|                                                  column0                                                   |
+------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                  |
|   FennelRenameRel(fieldNames=[[EXPR$0]])                                                                   |
|     FennelAggRel(groupCount=[0], agg#0=[COUNT(0)])                                                         |
|       LcsIndexAggRel(groupCount=[1])                                                                       |
|         FennelRenameRel(fieldNames=[[$f0, SRID, SegmentDesc, Segment]])                                    |
|           LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]])  |
+------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- agg with index search
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select avg(age) from person where age > 30;
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                              column0                                                                               |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                          |
|   FennelRenameRel(fieldNames=[[EXPR$0]])                                                                                                                           |
|     IteratorToFennelConverter                                                                                                                                      |
|       IterCalcRel(expr#0..1=[{inputs}], expr#2=[/($t0, $t1)], expr#3=[CAST($t2):INTEGER], $f0=[$t3])                                                               |
|         FennelToIteratorConverter                                                                                                                                  |
|           LcsIndexAggRel(groupCount=[0], agg#0=[SUM(0)], agg#1=[COUNT(0)])                                                                                         |
|             FennelRenameRel(fieldNames=[[$f0, SRID, SegmentDesc, Segment]])                                                                                        |
|               LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|                 FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 30, _ISO-8859-1'+', null }]])                                                                           |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- multikey
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select a from multikey where a = 1 and b > 1 group by a;
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                column0                                                                                 |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                              |
|   FennelRenameRel(fieldNames=[[A]])                                                                                                                                    |
|     LcsIndexAggRel(groupCount=[1])                                                                                                                                     |
|       FennelRenameRel(fieldNames=[[$f0, SRID, SegmentDesc, Segment]])                                                                                                  |
|         LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])  |
|           FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 1, 1, _ISO-8859-1'+', 1, null }]])                                                                                |
+------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select b from multikey where a = 1;
+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                           column0                                                                            |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                    |
|   LcsNormalizerRel                                                                                                                                           |
|     LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[1, 2, 3, 4]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|       FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]])                                                                                   |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select b from multikey where a = 1 group by b;
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                              column0                                                                               |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                          |
|   FennelRenameRel(fieldNames=[[B]])                                                                                                                                |
|     LhxAggRel(groupCount=[1])                                                                                                                                      |
|       FennelRenameRel(fieldNames=[[$f0]])                                                                                                                          |
|         LcsNormalizerRel                                                                                                                                           |
|           LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[1, 2, 3, 4]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|             FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]])                                                                                   |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- widening of an index search 
0: jdbc:farrago:> create index multikey_a on multikey(a);
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for
. . . . . . . . > select a, b from multikey where a = 1;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                             column0                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                       |
|   LcsNormalizerRel                                                                                                                                              |
|     LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[0, 1, 2, 3, 4]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|       FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]])                                                                                      |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- negative test: row scan with child can't be converted
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select age, count(*) from person where id > 5 group by age;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                                              column0                                                                                                              |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                                                                                         |
|   FennelRenameRel(fieldNames=[[AGE, EXPR$1]])                                                                                                                                                                                     |
|     LhxAggRel(groupCount=[1], agg#0=[COUNT()])                                                                                                                                                                                    |
|       FennelRenameRel(fieldNames=[[$f0]])                                                                                                                                                                                         |
|         LcsRowScanRel(table=[[LOCALDB, LBM, PERSON]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$PERSON$AGE]])                                                                                                 |
|           LcsIndexMergeRel(consumerSridParamId=[0], segmentLimitParamId=[0], ridLimitParamId=[1])                                                                                                                                 |
|             LcsIndexSearchRel(table=[[LOCALDB, LBM, PERSON]], index=[SYS$CONSTRAINT_INDEX$PERSON$SYS$PRIMARY_KEY], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])  |
|               FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 5, _ISO-8859-1'+', null }]])                                                                                                                                             |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- negative test: index only scan produces wrong sort order for agg
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select a, b from multikey where a = 1 and b > 1 group by b, a;
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                   column0                                                                                   |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                                   |
|   FennelReshapeRel(projection=[[1, 0]], outputRowType=[RecordType(INTEGER A, INTEGER B) NOT NULL])                                                                          |
|     LhxAggRel(groupCount=[2])                                                                                                                                               |
|       FennelRenameRel(fieldNames=[[$f0, $f1]])                                                                                                                              |
|         LcsNormalizerRel                                                                                                                                                    |
|           LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, MULTIKEY]], index=[IMULTIKEY], projection=[[1, 0, 2, 3, 4]], inputKeyProj=[[1, 2, 4, 5]], inputDirectiveProj=[[0, 3]])  |
|             FennelValuesRel(tuples=[[{ _ISO-8859-1'(', 1, 1, _ISO-8859-1'+', 1, null }]])                                                                                   |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- TODO: implement interposed calc when we have sort order propagation
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select avg(age+1) from person;
+----------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                   column0                                                                    |
+----------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                    |
|   FennelRenameRel(fieldNames=[[EXPR$0]])                                                                                                     |
|     IteratorToFennelConverter                                                                                                                |
|       IterCalcRel(expr#0..1=[{inputs}], expr#2=[/($t0, $t1)], expr#3=[CAST($t2):INTEGER], $f0=[$t3])                                         |
|         FennelToIteratorConverter                                                                                                            |
|           FennelAggRel(groupCount=[0], agg#0=[SUM(0)], agg#1=[COUNT(0)])                                                                     |
|             IteratorToFennelConverter                                                                                                        |
|               IterCalcRel(expr#0=[{inputs}], expr#1=[1], expr#2=[+($t0, $t1)], $f0=[$t2])                                                    |
|                 FennelToIteratorConverter                                                                                                    |
|                   LcsRowScanRel(table=[[LOCALDB, LBM, PERSON]], projection=[[1]], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$PERSON$AGE]])  |
+----------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select avg(age+1) from person where age = 30;
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                                                                                 column0                                                                                  |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| FennelToIteratorConverter                                                                                                                                                |
|   FennelRenameRel(fieldNames=[[EXPR$0]])                                                                                                                                 |
|     IteratorToFennelConverter                                                                                                                                            |
|       IterCalcRel(expr#0..1=[{inputs}], expr#2=[/($t0, $t1)], expr#3=[CAST($t2):INTEGER], $f0=[$t3])                                                                     |
|         FennelToIteratorConverter                                                                                                                                        |
|           FennelAggRel(groupCount=[0], agg#0=[SUM(0)], agg#1=[COUNT(0)])                                                                                                 |
|             IteratorToFennelConverter                                                                                                                                    |
|               IterCalcRel(expr#0=[{inputs}], expr#1=[1], expr#2=[+($t0, $t1)], $f0=[$t2])                                                                                |
|                 FennelToIteratorConverter                                                                                                                                |
|                   LcsNormalizerRel                                                                                                                                       |
|                     LcsIndexOnlyScanRel(table=[[LOCALDB, LBM, PERSON]], index=[AGE_IDX], projection=[[0, 1, 2, 3]], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]])  |
|                       FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 30, _ISO-8859-1']', 30 }]])                                                                             |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
0: jdbc:farrago:> 
0: jdbc:farrago:> ----------------------------------------------------------
0: jdbc:farrago:> -- Tests to exercise using startrid in bitmap index search
0: jdbc:farrago:> ----------------------------------------------------------
0: jdbc:farrago:> 
0: jdbc:farrago:> create server test_data
. . . . . . . . > foreign data wrapper sys_file_wrapper
. . . . . . . . > options (
. . . . . . . . >     directory 'unitsql/optimizer/data',
. . . . . . . . >     file_extension 'csv',
. . . . . . . . >     with_header 'yes',
. . . . . . . . >     log_directory 'testlog');
0: jdbc:farrago:> 
0: jdbc:farrago:> create foreign table ridsearchdata(a int, b int, c int)
. . . . . . . . >     server test_data
. . . . . . . . >     options (filename 'ridsearchdata');
0: jdbc:farrago:> 
0: jdbc:farrago:> create table ridsearchtable(fakerid int, a int, b int)
. . . . . . . . >     server sys_column_store_data_server;
0: jdbc:farrago:> create index i_a on ridsearchtable(a);
0: jdbc:farrago:> create index i_b on ridsearchtable(b);
0: jdbc:farrago:> insert into ridsearchtable select * from ridsearchdata;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for select * from ridsearchtable where b = 0 and a = 2;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 0, _ISO-8859-1']', 0 }]])'
0: jdbc:farrago:> explain plan for select * from ridsearchtable where b = 0 and a = 3;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 3, _ISO-8859-1']', 3 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 0, _ISO-8859-1']', 0 }]])'
0: jdbc:farrago:> explain plan for select * from ridsearchtable where b = 0 and a = 1;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 0, _ISO-8859-1']', 0 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> select * from ridsearchtable order by fakerid;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
| 1        | 3  | 1  |
| 2        | 3  | 2  |
| 3        | 3  | 3  |
| 4        | 3  | 4  |
| 5        | 3  | 5  |
| 6        | 3  | 6  |
| 7        | 3  | 7  |
| 8        | 2  | 0  |
| 9        | 2  | 1  |
| 10       | 2  | 2  |
| 11       | 2  | 3  |
| 12       | 2  | 4  |
| 13       | 2  | 5  |
| 14       | 2  | 6  |
| 15       | 2  | 7  |
| 16       | 0  | 0  |
+----------+----+----+
0: jdbc:farrago:> select * from ridsearchtable where b = 0 and a = 2;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 8        | 2  | 0  |
+----------+----+----+
0: jdbc:farrago:> select * from ridsearchtable where b = 0 and a = 3;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
+----------+----+----+
0: jdbc:farrago:> -- no rows
0: jdbc:farrago:> select * from ridsearchtable where b = 0 and a = 1;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
+----------+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> -- reverse the order of the index creation and repeat
0: jdbc:farrago:> 
0: jdbc:farrago:> drop table ridsearchtable;
0: jdbc:farrago:> create table ridsearchtable(fakerid int, a int, b int)
. . . . . . . . >     server sys_column_store_data_server;
0: jdbc:farrago:> create index i_b on ridsearchtable(b);
0: jdbc:farrago:> create index i_a on ridsearchtable(a);
0: jdbc:farrago:> insert into ridsearchtable select * from ridsearchdata;
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for select * from ridsearchtable where b = 0 and a = 2;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 0, _ISO-8859-1']', 0 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
0: jdbc:farrago:> explain plan for select * from ridsearchtable where b = 0 and a = 3;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 0, _ISO-8859-1']', 0 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 3, _ISO-8859-1']', 3 }]])'
0: jdbc:farrago:> explain plan for select * from ridsearchtable where b = 0 and a = 1;
'column0'
'FennelToIteratorConverter'
'  LcsRowScanRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$A, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$B, SYS$CLUSTERED_INDEX$LBM$RIDSEARCHTABLE$FAKERID]])'
'    LcsIndexIntersectRel(startRidParamId=[2], rowLimitParamId=[1])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_B], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 0, _ISO-8859-1']', 0 }]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, RIDSEARCHTABLE]], index=[I_A], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[2], rowLimitParamId=[1])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> select * from ridsearchtable order by fakerid;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
| 1        | 3  | 1  |
| 2        | 3  | 2  |
| 3        | 3  | 3  |
| 4        | 3  | 4  |
| 5        | 3  | 5  |
| 6        | 3  | 6  |
| 7        | 3  | 7  |
| 8        | 2  | 0  |
| 9        | 2  | 1  |
| 10       | 2  | 2  |
| 11       | 2  | 3  |
| 12       | 2  | 4  |
| 13       | 2  | 5  |
| 14       | 2  | 6  |
| 15       | 2  | 7  |
| 16       | 0  | 0  |
+----------+----+----+
0: jdbc:farrago:> select * from ridsearchtable where b = 0 and a = 2;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 8        | 2  | 0  |
+----------+----+----+
0: jdbc:farrago:> select * from ridsearchtable where b = 0 and a = 3;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
| 0        | 3  | 0  |
+----------+----+----+
0: jdbc:farrago:> -- no rows
0: jdbc:farrago:> select * from ridsearchtable where b = 0 and a = 1;
+----------+----+----+
| FAKERID  | A  | B  |
+----------+----+----+
+----------+----+----+
0: jdbc:farrago:> 
0: jdbc:farrago:> ---------------------
0: jdbc:farrago:> -- Some join tests --
0: jdbc:farrago:> ---------------------
0: jdbc:farrago:> -- Filter above join gets pushed down so index can be used.
0: jdbc:farrago:> !set outputformat csv
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lbmdepts, lbmemps where lbmemps.deptno = 2;
'column0'
'FennelToIteratorConverter'
'  FennelCartesianProductRel(leftouterjoin=[false])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMDEPTS$DEPTNO]])'
'    LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'      LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmdepts, lbmemps where lbmemps.deptno = 2;
'DEPTNO','EMPNO','ENAME','DEPTNO0'
0: jdbc:farrago:> 
0: jdbc:farrago:> -- Filter in an inline view is already in the right place for indexing.
0: jdbc:farrago:> explain plan for 
. . . . . . . . > select * from lbmdepts, 
. . . . . . . . >               (select * from lbmemps where lbmemps.deptno = 2) view;
'column0'
'FennelToIteratorConverter'
'  FennelRenameRel(fieldNames=[[DEPTNO, EMPNO, ENAME, DEPTNO]])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, LBM, LBMDEPTS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMDEPTS$DEPTNO]])'
'      LcsRowScanRel(table=[[LOCALDB, LBM, LBMEMPS]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$LBM$LBMEMPS$DEPTNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$EMPNO, SYS$CLUSTERED_INDEX$LBM$LBMEMPS$ENAME]])'
'        LcsIndexSearchRel(table=[[LOCALDB, LBM, LBMEMPS]], index=[DEPTNO_IX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 2, _ISO-8859-1']', 2 }]])'
0: jdbc:farrago:> 
0: jdbc:farrago:> select * from lbmdepts, 
. . . . . . . . >               (select * from lbmemps where lbmemps.deptno = 2) view;
'DEPTNO','EMPNO','ENAME','DEPTNO0'
0: jdbc:farrago:> 
0: jdbc:farrago:> !set outputformat table
0: jdbc:farrago:> 
0: jdbc:farrago:> ------------
0: jdbc:farrago:> -- Misc bugs
0: jdbc:farrago:> ------------
0: jdbc:farrago:> -- FRG-83
0: jdbc:farrago:> create table t(a int, b int, c int) server sys_column_store_data_server;
0: jdbc:farrago:> create index ita on t(a);
0: jdbc:farrago:> create index itb on t(b);
0: jdbc:farrago:> insert into t values(1, 2, 3);
0: jdbc:farrago:> create view v as select * from t where a = 1 and b = 2;
0: jdbc:farrago:> select * from v v1, v v2; 
+----+----+----+-----+-----+-----+
| A  | B  | C  | A0  | B0  | C0  |
+----+----+----+-----+-----+-----+
| 1  | 2  | 3  | 1   | 2   | 3   |
+----+----+----+-----+-----+-----+
0: jdbc:farrago:> 
0: jdbc:farrago:> --------------
0: jdbc:farrago:> -- Clean up --
0: jdbc:farrago:> --------------
0: jdbc:farrago:> drop server test_data cascade;
0: jdbc:farrago:> drop schema lbm cascade;
0: jdbc:farrago:> 
0: jdbc:farrago:> -- End index.sql
0: jdbc:farrago:> 
0: jdbc:farrago:> !quit
