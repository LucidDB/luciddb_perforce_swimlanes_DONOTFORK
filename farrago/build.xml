<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id$ -->
<!-- Farrago ant build script -->

<!-- These XML ENTITY "macros" help avoid redundancy in property -->
<!-- settings. They can be used with <jvmarg> or <arg> as the line -->
<!-- attribute. -->
<!DOCTYPE project [

<!ENTITY FarragoProps
"
-Dnet.sf.farrago.home=${farrago.dir}
-Djava.util.logging.config.file=${FarragoTrace.properties}
">

]>

<project name="farrago" basedir="." default="all">

  <!-- assume common parent of farrago, saffron, and fennel  -->
  <property name="open.dir" location=".."/>

  <!-- Farrago project root  -->
  <property name="farrago.dir" location="."/>

  <!-- Saffron project root -->
  <property name="saffron.dir" location="${open.dir}/saffron"/>

  <!-- import the fennel.disabled setting; this takes highest precedence -->
  <property file="initBuild.properties"/>

  <!-- import local property overrides; these take precedence over
       later definitions in this file -->
  <property file="customBuild.properties"/>

  <!-- Override these locations in customBuild.properties -->
  <property name="thirdparty.dir" value="${open.dir}/thirdparty"/>
  <property name="fennel.dir" location="${open.dir}/fennel"/>

  <!-- import thirdparty library settings -->
  <property file="${thirdparty.dir}/build.properties"/>

  <!-- import environment variables as properties -->
  <property environment="env"/>


  <!-- Directories -->

  <!-- directory for non-generated source code -->
  <property name="src.dir" location="${farrago.dir}/src"/>

  <!-- directory for Farrago compiled class files (other than plugins) -->
  <property name="classes.dir" location="${farrago.dir}/classes"/>

  <!-- directory for Farrago compiled plugin .jars -->
  <property name="plugin.dir" location="${farrago.dir}/plugin"/>

  <!-- directory for Farrago compiled classes which go into plugin .jars -->
  <property name="plugin.classes.dir" location="${plugin.dir}/classes"/>

  <!-- directory for JUnit run output -->
  <property name="testlog.dir" location="${farrago.dir}/testlog"/>

  <!-- directory in which javadoc should be generated -->
  <property name="javadoc.dir" location="${farrago.dir}/doc/api"/>

  <!-- directory in which catalog data is stored -->
  <property name="catalog.dir" location="${farrago.dir}/catalog"/>

  <!-- directory for initialization scripts -->
  <property name="initsql.dir" location="${farrago.dir}/initsql"/>

  <!-- directory for unit test SQL scripts -->
  <property name="unitsql.dir" location="${farrago.dir}/unitsql"/>

  <!-- directory for regression test SQL scripts -->
  <property name="regressionsql.dir" location="${farrago.dir}/regressionsql"/>

  <!-- directory in which SQL parser source code is stored -->
  <property name="parser.sql.dir"
    location="${src.dir}/org/eigenbase/sql/parser"/>

  <!-- directory in which Farrago parser source code is stored -->
  <property name="parser.farrago.dir"
    location="${src.dir}/net/sf/farrago/parser"/>

  <!-- directory in which Farrago resources are stored -->
  <property name="farrago.resource.dir"
    location="${src.dir}/net/sf/farrago/resource"/>

  <!-- directory in which Eigenbase resources are stored -->
  <property name="eigenbase.resource.dir"
    location="${src.dir}/org/eigenbase/resource"/>

  <!-- directory in which catalog data is backed up -->
  <property name="catalog.backup.dir" location="${catalog.dir}/backup"/>

  <!-- directory in which catalog sources are generated -->
  <property name="catalog.src.dir" location="${catalog.dir}/java"/>

  <!-- directory in which catalog-related XMI files are stored -->
  <property name="xmi.dir" location="${catalog.dir}/xmi"/>

  <!-- directory in which trace files are configured and generated -->
  <property name="trace.dir" location="${farrago.dir}/trace"/>

  <!-- netbeans project root -->
  <property name="netbeans.dir" location="${open.dir}/netbeans"/>

  <!-- MDR project root -->
  <property name="mdr.dir" location="${netbeans.dir}/mdr"/>

  <!-- MDRANT project root -->
  <property name="mdrant.dir" location="${mdr.dir}/extras/mdrant"/>

  <!-- ANT installation root -->
  <property name="ant.dir" location="${env.ANT_HOME}"/>

  <!-- Java installation root -->
  <property name="javahome.dir" location="${env.JAVA_HOME}"/>

  <fail unless="javacc.dir"/>
  <fail unless="junit.dir"/>
  <fail unless="macker.dir"/>
  <fail unless="jalopy.dir"/>
  <fail unless="janino.dir"/>
  <fail unless="isql.dir"/>
  <fail unless="jswat.dir"/>
  <fail unless="fennel.dir"/>
  <fail unless="sqlline.dir"/>
  <fail unless="sqlline.lib.dir"/>
  <fail unless="mdrlibs.dir"/>
  <fail unless="rmijdbc.dir"/>

  <!-- The version of ANT we require. -->
  <property name="required.ant.version" value="1.6.0"/>

  <condition property="is.correct.ant.version">
    <contains string="${ant.version}" substring="${required.ant.version}"/>
  </condition>
  <fail unless="is.correct.ant.version"
      message="Incorrect ant version '${ant.version}';
require version '${required.ant.version}'."/>

  <!-- Files -->

  <!-- XMI file containing CWM defintion  -->
  <property name="CwmMetamodel.xmi" location="${xmi.dir}/cwm-1.1.xml"/>

  <!-- XMI file contains Farrago final metamodel  -->
  <property name="FarragoMetamodel.xmi"
    location="${xmi.dir}/FarragoMetamodel.xmi"/>

  <!-- Farrago metamodel XMI file before CWM references are resolved -->
  <property name="FarragoMetamodelUnresolved.xmi"
    location="${xmi.dir}/FarragoMetamodelUnresolved.xmi"/>

  <!-- XMI file in which Farrago metamodel is generated from CWM -->
  <property name="FarragoMetamodelCWM.xmi"
    location="${xmi.dir}/FarragoMetamodelCWM.xmi"/>

  <!-- XMI file in which Farrago metamodel combined with extension model -->
  <property name="FarragoMetamodelExt.xmi"
    location="${xmi.dir}/FarragoMetamodelExt.xmi"/>

  <!-- XMI file containing Farrago extension metamodel -->
  <property name="FarragoExtMetamodel.xmi"
    location="${xmi.dir}/FarragoExtMetamodel.xmi"/>

  <!-- XMI file containing renumbered Farrago extension metamodel -->
  <property name="FarragoExtMetamodelTransformed.xmi"
    location="${xmi.dir}/FarragoExtMetamodelTransformed.xmi"/>

  <!-- XMI file containing UML representation of Farrago extension metamodel -->
  <property name="FarragoExtMetamodelUML.xmi"
    location="${xmi.dir}/FarragoExtMetamodelUML.xmi"/>

  <!-- Same as FarragoExtMetamodelUML, but with diagams deleted -->
  <property name="FarragoExtMetamodelUMLSansDiagrams.xmi"
    location="${xmi.dir}/FarragoExtMetamodelUMLSansDiagrams.xmi"/>

  <!-- Zipfile containing Poseidon UML XMI representation of -->
  <!-- Farrago extension metamodel -->
  <property name="FarragoExtMetamodelUML.zuml"
    location="${xmi.dir}/FarragoExtMetamodelUML.zuml"/>

  <!-- File for farrago extension model. START -->
  <!-- XMI file containing Farrago extension model -->
  <property name="ExtModel.xmi"
    location="${xmi.dir}/ExtModel.xmi"/>

  <!-- XMI file containing renumbered Farrago extension model -->
  <property name="ExtModelTransformed.xmi"
    location="${xmi.dir}/ExtModelTransformed.xmi"/>

  <!-- Extension model file name without path -->
  <basename property="ExtModelFileName" file="${ext.model.file}" suffix=".zuml"/>

  <!-- XMI file containing UML representation of Farrago extension model -->
  <property name="ExtModelUML.xmi"
    location="${xmi.dir}/${ExtModelFileName}.xmi"/>

  <!-- Same as ExtModelUML, but with diagams deleted -->
  <property name="ExtModelUMLSansDiagrams.xmi"
    location="${xmi.dir}/ExtModelUMLSansDiagrams.xmi"/>

  <!-- File for farrago extension model. END -->

  <!-- Template developer configuration file. -->
  <property name="FarragoConfTemplate.xmi"
    location="${xmi.dir}/FarragoConfTemplate.xmi"/>

  <!-- Developer configuration file generated from template. -->
  <property name="FarragoConf.xmi"
    location="${xmi.dir}/FarragoConf.xmi"/>

  <!-- file prefix for catalog storage -->
  <property name="catalog.mdrStorage"
    location="${catalog.dir}/FarragoCatalog"/>

  <!-- Directories and filenames for distribution jar file. -->
  <property name="dist.dir" location="${farrago.dir}/dist"/>
  <property name="dist.plugin.dir" location="${farrago.dir}/dist/plugin"/>

  <property name="dist.jar.file" location="${dist.dir}/farrago.jar"/>

  <property name="FarragoTrace.properties"
    location="${trace.dir}/FarragoTrace.properties"/>

  <property name="FarragoTrace.log"
    location="${trace.dir}/FarragoTrace.log"/>

  <!-- NOTE:  this has to use true/false (not 1/0) for MDR import -->
  <property name="fennel.disabled" value="false"/>
  <condition property="fennel.disabled.istrue">
    <istrue value="${fennel.disabled}"/>
  </condition>

  <property name="assertions.jvmarg" value="-ea -esa"/>

  <!-- NOTE:  it would be nice if we could combine parser filesets below, -->
  <!-- and use filelist instead; however, filesets/filelists have to share -->
  <!-- a common root, and the uptodate task doesn't like filelists -->

  <!-- a fileset of the common SQL parser -->
  <fileset dir="${parser.sql.dir}" id="fileset.parser.common.sql"
    includes="CommonParser.jj"/>

  <!-- a fileset of the Farrago-specific DDL parser -->
  <fileset dir="${parser.farrago.dir}" id="fileset.parser.farrago.ddl"
    includes="DdlParser.jj"/>

  <!-- a fileset of the Farrago common DDL parser -->
  <fileset dir="${parser.farrago.dir}" id="fileset.parser.farrago.ddl.common"
    includes="CommonDdlParser.jj"/>

  <!-- a fileset of all files for which tags should be built -->
  <fileset dir="${open.dir}" id="fileset.taggable">
    <include name="farrago/catalog/java/**/*.java"/>
    <include name="farrago/src/**/*.java"/>
    <include name="farrago/src/**/package.html"/>
    <exclude name="**/Dummy*.java"/>
  </fileset>

  <!-- a fileset of all SQL unit tests -->
  <fileset dir="${unitsql.dir}" id="fileset.unitsql">
    <include name="**/*.sql"/>
  </fileset>
  <pathconvert property="fileset.unitsql" refid="fileset.unitsql"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- a fileset of all SQL regression tests -->
  <fileset dir="${regressionsql.dir}" id="fileset.regressionsql">
    <include name="**/*.sql"/>
  </fileset>
  <pathconvert property="fileset.regressionsql" refid="fileset.regressionsql"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- name for a temp file used during tags generation -->
  <property name="file.taggable.tmp"
    location="${farrago.dir}/taggedfiles"/>

  <!-- newline for use in constructing strings -->
  <property name="nl" value="${line.separator}"/>

  <!-- Classpaths -->

  <!-- third-party libraries -->
  <path id="farrago.3p.classpath">
    <pathelement location="${mdrlibs.dir}/mdrant.jar"/>
    <pathelement location="${mdrlibs.dir}/nbmdr.jar"/>
    <pathelement location="${mdrlibs.dir}/mdrapi.jar"/>
    <pathelement location="${mdrlibs.dir}/jmiutils.jar"/>
    <pathelement location="${mdrlibs.dir}/mof.jar"/>
    <pathelement location="${mdrlibs.dir}/jmi.jar"/>
    <pathelement location="${mdrlibs.dir}/openide-util.jar"/>
    <pathelement location="${thirdparty.dir}/mondrian-resource.jar"/>
    <pathelement location="${thirdparty.dir}/mondrian-xom.jar"/>
    <pathelement location="${mdrlibs.dir}/mdrjdbc.jar"/>
    <pathelement location="${junit.dir}/junit.jar"/>
    <pathelement location="${ant.dir}/lib/xml-apis.jar"/>
    <pathelement location="${ant.dir}/lib/xercesImpl.jar"/>
    <pathelement location="${javahome.dir}/lib/tools.jar"/>
    <pathelement location="${rmijdbc.dir}/dist/lib/RmiJdbc.jar"/>
    <pathelement location="${csvjdbc.dir}/csvjdbc.jar"/>
    <pathelement location="${janino.dir}/lib/janino.jar"/>
  </path>
  <property name="farrago.3p.classpath" refid="farrago.3p.classpath"/>

  <!-- classpath for main build (after catalog codegen) -->
  <path id="farrago.build.classpath">
    <pathelement path="${farrago.3p.classpath}"/>
    <pathelement location="${catalog.src.dir}"/>
    <pathelement location="${sqlline.lib.dir}/sqlline.jar"/>
    <pathelement location="${sqlline.lib.dir}/jline.jar"/>
  </path>
  <property name="farrago.build.classpath" refid="farrago.build.classpath"/>

  <!-- classpath for plugin build) -->
  <path id="plugin.build.classpath">
    <pathelement path="${farrago.build.classpath}"/>
    <pathelement location="${classes.dir}"/>
  </path>
  <property name="plugin.build.classpath" refid="plugin.build.classpath"/>

  <!-- classpath for execution.  It's very important for classes.dir
       to come BEFORE catalog.src.dir so that MDR will make our Impl
       classes override their generated counterparts.  The reason
       src.dir is here is so that resource .xml files can be found at
       runtime without copying.  -->
  <path id="farrago.run.classpath">
    <pathelement path="${farrago.3p.classpath}"/>
    <pathelement location="${classes.dir}"/>
    <pathelement location="${catalog.src.dir}"/>
    <pathelement location="${src.dir}"/>
        <!-- TODO:  move hsqldb to thirdparty -->
    <pathelement location="${saffron.dir}/lib/hsqldb.jar"/>
  </path>
  <property name="farrago.run.classpath" refid="farrago.run.classpath"/>

  <!-- sourcepath for debugging -->
  <path id="farrago.sourcepath">
    <pathelement location="${janino.dir}/src"/>
    <pathelement location="${catalog.src.dir}"/>
    <pathelement location="${src.dir}"/>
  </path>
  <property name="farrago.sourcepath" refid="farrago.sourcepath"/>


  <!-- classpath for running from sqlline -->
  <path id="sqlline.classpath">
    <pathelement location="${sqlline.lib.dir}/sqlline.jar"/>
    <pathelement location="${sqlline.lib.dir}/jline.jar"/>
    <pathelement path="${farrago.run.classpath}"/>
  </path>
  <property name="sqlline.classpath" refid="sqlline.classpath"/>

  <!-- classpath for reentrantly invoking ant -->
  <path id="ant.classpath">
    <pathelement location="${ant.dir}/lib/ant.jar"/>
    <pathelement location="${ant.dir}/lib/ant-launcher.jar"/>
    <pathelement location="${ant.dir}/lib/junit.jar"/>
    <pathelement location="${ant.dir}/lib/xercesImpl.jar"/>
    <pathelement location="${ant.dir}/lib/xml-apis.jar"/>
  </path>
  <property name="ant.classpath" refid="ant.classpath"/>

  <!-- classpath for reentrantly invoking ant from createUserRepository -->
  <path id="createUserRepository.classpath">
    <pathelement path="${farrago.run.classpath}"/>
    <pathelement path="${ant.classpath}"/>
  </path>
  <property name="createUserRepository.classpath"
    refid="createUserRepository.classpath"/>

  <!-- sourcepath for debugging iSQL -->
  <path id="jswat.isql.sourcepath">
    <pathelement location="${isql.dir}/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="jswat.isql.sourcepath" refid="jswat.isql.sourcepath"/>

  <!-- sourcepath for debugging sqlline -->
  <path id="jswat.sqlline.sourcepath">
    <pathelement location="${sqlline.dir}/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="jswat.sqlline.sourcepath" refid="jswat.sqlline.sourcepath"/>

  <!-- sourcepath for debugging via JUnit -->
  <path id="jswat.junit.sourcepath">
    <pathelement location="${junit.dir}/src.jar"/>
    <pathelement path="${jswat.sqlline.sourcepath}"/>
  </path>
  <property name="jswat.junit.sourcepath" refid="jswat.junit.sourcepath"/>

  <!-- sourcepath for debugging MDR -->
  <path id="mdr.sourcepath">
    <pathelement location="${open.dir}/netbeans/mdr/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="mdr.sourcepath" refid="mdr.sourcepath"/>

  <!-- sourcepath for debugging server -->
  <path id="server.sourcepath">
    <pathelement location="${rmijdbc.dir}/src"/>
    <pathelement path="${farrago.sourcepath}"/>
  </path>
  <property name="farrago.sourcepath" refid="farrago.sourcepath"/>


  <!-- Macro Definitions -->
  <import file="buildMacros.xml"/>

  <!-- classpath for running from iSQL -->
  <path id="isql.run.classpath">
    <pathelement path="${isql.classpath}"/>
    <pathelement path="${farrago.run.classpath}"/>
  </path>
  <property name="isql.run.classpath" refid="isql.run.classpath"/>

  <!-- Targets -->

  <!--

  Declare mdr task used for catalog manipulation.  Note that in order
  to use this task, we always fork an ant subprocess using java (not
  ant or antcall).  There are two reasons for this.  Most importantly,
  it makes sure that the repository is shut down properly.  Without
  this, invocations of mdr sometimes interfere with our own java tasks
  (e.g. populateCatalog).  Another reason is that it gives us a chance
  to set Java properties, most importantly the one that controls the
  mdr logging level, so we can suppress some spurious exception
  reports.

  -->

  <target name="mdr_taskdef">
    <taskdef name="mdr" classname="org.netbeans.mdrant.MdrTask"
      classpathref="farrago.run.classpath"/>
  </target>

  <!-- default target:  assumes catalog has already been created -->
  <target name="all"
    depends="compile, buildJdbcPlugin"/>

  <target name="compile" depends="generateResources,sqlParser,ddlParser">
    <javaCompile
      deprecation="off"
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/*.java" />
      <exclude name="**/namespace/jdbc/**/*.java" />
    </javaCompile>
  </target>

  <!-- compile only packages needed by Saffron -->
  <target name="compile.saffron.deps" depends="generateResources,sqlParser">
    <javaCompile
      deprecation="off"
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="openjava/**/*.java" />
      <include name="org/eigenbase/**/*.java" />
      <include name="com/disruptivetech/farrago/volcano/**/*.java" />
    </javaCompile>
  </target>

  <!-- create classes directory -->
  <target name="mkdir.classes">
    <mkdir dir="${classes.dir}"/>
  </target>

  <!-- test only packages needed by Saffron -->
  <target name="test.saffron.deps" depends="compile.saffron.deps">
    <mkdir dir="${testlog.dir}"/>
    <junit printsummary="yes" fork="yes" failureproperty="junit.failure"
      tempdir="${testlog.dir}">
      <classpath refid="farrago.run.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <formatter type="plain"/>
      <batchtest todir="${testlog.dir}" unless="junit.class">
        <fileset dir="${classes.dir}">
          <include name="org/eigenbase/**/*Test.class"/>
          <include name="com/disruptivetech/farrago/volcano/**/*Test.class"/>
        </fileset>
      </batchtest>
      <test todir="${testlog.dir}" if="junit.class"
        name="${junit.class}" />
    </junit>
    <delete file="${FarragoTrace.log}.lck"/>
    <fail message="Test failure(s)" if="junit.failure"/>
  </target>

  <target name="buildJdbcPlugin"
    depends="checkJdbcPluginUptodate" unless="plugin.jdbc.uptodate">
    <javaCompile
      srcdir="${src.dir}"
      destdir="${plugin.classes.dir}"
      classpathref="plugin.build.classpath">
      <include name="**/namespace/jdbc/**/*.java" />
    </javaCompile>
    <jar jarfile="${plugin.dir}/FarragoMedJdbc.jar">
      <fileset dir="${plugin.classes.dir}">
        <include name="**/namespace/jdbc/**/*.class" />
      </fileset>
      <manifest>
        <attribute
          name="DataWrapperClassName"
          value="net.sf.farrago.namespace.jdbc.MedJdbcForeignDataWrapper" />
      </manifest>
    </jar>
  </target>

  <target name="checkJdbcPluginUptodate">
    <uptodate property="plugin.jdbc.uptodate"
      targetfile="${plugin.dir}/FarragoMedJdbc.jar">
      <srcfiles dir="${src.dir}"
        includes="**/namespace/jdbc/**/*.java"/>
    </uptodate>
  </target>

  <!-- cleans for non-generated code only; does not touch catalog -->
  <target name="clean" depends="cleanTestLogs">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${classes.dir}" includes="**/*.class"/>
      <fileset dir="${plugin.classes.dir}" includes="**/*.class"/>
      <fileset dir="${plugin.dir}" includes="**/*.jar"/>
      <fileset dir="${classes.dir}"
        includes="net/sf/farrago/dynamic/**"/>
      <fileset dir="${farrago.dir}" includes="junit*.properties"/>
      <fileset dir="${farrago.dir}" includes="hs_err_pid*.log"/>
      <fileset dir="${src.dir}/net/sf/farrago/resource">
        <include name="*.java"/>
        <include name="FarragoResource_en_US.properties"/>
        <include name="FarragoResource.properties"/>
      </fileset>
      <fileset dir="${src.dir}/org/eigenbase/resource">
        <include name="*.java"/>
        <include name="EigenbaseResource_en_US.properties"/>
        <include name="EigenbaseResource.properties"/>
      </fileset>
      <fileset dir="${parser.farrago.dir}">
        <include name="CombinedParser.jj"/>
        <include name="FarragoParserImpl.java"/>
        <include name="FarragoParserImplConstants.java"/>
        <include name="FarragoParserImplTokenManager.java"/>
        <include name="TokenMgrError.java"/>
        <include name="ParseException.java"/>
        <include name="JavaCharStream.java"/>
        <include name="Token.java"/>
      </fileset>
      <fileset dir="${parser.sql.dir}">
        <include name="CombinedParser.jj"/>
        <include name="Parser.java"/>
        <include name="TokenMgrError.java"/>
        <include name="ParseException.java"/>
        <include name="JavaCharStream.java"/>
        <include name="Token.java"/>
        <include name="SqlParseImpConstants.java"/>
        <include name="ASCII_UCodeESC_CharStream.java"/>
      </fileset>
    </delete>
  </target>

  <target name="cleanTestLogs">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${testlog.dir}" includes="*.xml"/>
      <fileset dir="${testlog.dir}" includes="*.txt"/>
      <fileset dir="${testlog.dir}" includes="*.log"/>
      <fileset dir="${testlog.dir}" includes="*.dif"/>
      <fileset dir="${unitsql.dir}" includes="**/*.log"/>
      <fileset dir="${regressionsql.dir}" includes="**/*.log"/>
    </delete>
    <delete quiet="true" file="${FarragoTrace.log}"/>
  </target>

  <!-- creates catalog and populates with initial metadata -->
  <target name="createCatalog" depends ="mkdir.classes">
    <mkdir dir="${classes.dir}"/>
    <mkdir dir="${plugin.dir}"/>
    <mkdir dir="${plugin.classes.dir}"/>
    <antcall target="createClasspathFile"/>
    <antcall target="compileCatalog"/>
    <antcall target="createMdrTestData"/>
    <antcall target="importConfig"/>
    <antcall target="backupCatalog"/>
    <antcall target="populateTestData"/>
    <!-- NOTE:  redundant backup is an intentional checkpoint; in case
    populateTestData fails, it can be debugged from restored empty catalog -->
    <antcall target="backupCatalog"/>
  </target>

  <target name="compileCatalog"
    depends="cleanCatalog,createRepository"/>

  <!-- initialize catalog repository -->
  <target name="createRepository" depends="configureTrace,convertExtMetamodel, convertExtModel">
    <mkdir dir="${catalog.dir}"/>
    <mkdir dir="${catalog.src.dir}"/>
    <antcall target="transformMetamodel"/>
    <antFork target="forked_importMetamodel"/>
    <javaCompile
      srcdir="${catalog.src.dir}"
      destdir="${catalog.src.dir}"
      classpathref="farrago.3p.classpath">
      <include name="**/*.java"/>
    </javaCompile>
    <antcall target="backupCatalog"/>
    <antFork target="forked_createTempCatalogRepository"/>
    <antcall target="compile.saffron.deps"/>
    <antcall target="generateMetadataFactory"/>
    <antcall target="restoreCatalog"/>
    <antcall target="all"/>
    <antFork target="forked_createCatalogRepository"/>
  </target>

  <!-- NOTE:  don't use mapClass below to make sure all generated
  .java files can actually be compiled -->

  <target name="forked_importMetamodel" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <instantiate name="FarragoMetamodel"/>
      <readXMI
        file="${FarragoMetamodel.xmi}"
        extent="FarragoMetamodel"/>
      <mapJava
        dir="${catalog.src.dir}"
        extent="FarragoMetamodel"/>
    </mdr>
  </target>

  <target name="forked_createCatalogRepository" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <instantiate
        name="FarragoCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
      <writeDTD
        file="${xmi.dir}/FarragoCatalog.dtd"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <target name="forked_createTempCatalogRepository" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <instantiate
        name="FarragoTempCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
    </mdr>
  </target>

  <!-- combine transformed CWM with FarragoExt to create final XMI for
  Farrago metamodel -->
  <target name="transformMetamodel">
	 <xslt style="${xmi.dir}/transformFEM.xsl"
		in="${FarragoExtMetamodel.xmi}"
		out="${FarragoExtMetamodelTransformed.xmi}" />
	 <replace file="${FarragoExtMetamodelTransformed.xmi}"
		token="org.omg.xmi.namespace.Model" value="omg.org/mof.Model/1.3" />
    <antcall target="transformExtModel"/>
    <xslt style="${xmi.dir}/transformCWM.xsl"
      in="${CwmMetamodel.xmi}"
      out="${FarragoMetamodelUnresolved.xmi}">
      <param name="femXmiFilename"
        expression="${FarragoExtMetamodelTransformed.xmi}"/>
      <param name="extXmiFilename"
        expression="${ExtModelTransformed.xmi}"/>
    </xslt>
    <xslt style="${xmi.dir}/resolveCwmRefs.xsl"
      in="${FarragoMetamodelUnresolved.xmi}"
      out="${FarragoMetamodel.xmi}"/>
  </target>

  <target name="transformExtModel"  if="ext.model.file">
	 <xslt style="${xmi.dir}/transformFEME.xsl"
		in="${ExtModel.xmi}"
		out="${ExtModelTransformed.xmi}" >
     <param name="modelPrefix"
        expression="${ext.model.prefix}"/>
     </xslt>
	 <replace file="${ExtModelTransformed.xmi}"
		token="org.omg.xmi.namespace.Model" value="omg.org/mof.Model/1.3" />
  </target>

  <target name="combineExtModel"  if="ext.model.file">
	 <xslt style="${xmi.dir}/combineExtModel.xsl"
		in="${FarragoMetamodelCWM.xmi}"
		out="${FarragoMetamodelExt.xmi}">
      <param name="extXmiFilename"
        expression="${ExtModelTransformed.xmi}"/>
      <param name="pkgName"
        expression="${ext.package.name}"/>
      <param name="pkgPrefix"
        expression="${ext.package.prefix}"/>
     </xslt>
     <copy file="${FarragoMetamodelExt.xmi}" tofile="${FarragoMetamodelCWM.xmi}" overwrite="yes"/>
  </target>

  <!-- generate developer configuration file and import it -->
  <target name="importConfig">
    <copy file="${FarragoConfTemplate.xmi}"
      tofile="${FarragoConf.xmi}" overwrite="true"/>

    <mkdir dir="${catalog.dir}/fennel"/>
    <copy todir="${catalog.dir}/fennel">
      <fileset dir="${fennel.dir}/common" includes="*.properties"/>
    </copy>

    <replace file="${FarragoConf.xmi}">
      <replacefilter token="@fennel.disabled@" value="${fennel.disabled}"/>
      <replacefilter token="@resourceDir@" value="$${FARRAGO_HOME}/catalog/fennel"/>
    </replace>
    <antFork target="forked_importConfig"/>
  </target>

  <!-- set up the default trace configuration file -->
  <target name="configureTrace">
    <mkdir dir="${trace.dir}"/>
    <touch file="${FarragoTrace.properties}"/>
    <propertyfile file="${FarragoTrace.properties}"
      comment="Farrago developer tracing configuration (do not add comments)">
      <entry key="handlers" default="java.util.logging.FileHandler"/>
      <entry key="java.util.logging.FileHandler.formatter"
        default="java.util.logging.SimpleFormatter"/>
      <entry key=".level" default="CONFIG"/>
      <entry key="java.util.logging.FileHandler.pattern"
        default="${FarragoTrace.log}"/>
      <entry key="java.util.logging.FileHandler.append" default="true"/>
      <entry key="net.sf.farrago.jdbc.level" default="FINER"/>
    </propertyfile>
  </target>

  <target name="forked_importConfig" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <readXMI
        file="${FarragoConf.xmi}"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <!-- write initial metadata to catalog -->
  <target name="populateCatalog">
    <javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.db.FarragoDatabase"/>
  </target>

  <!-- write sample schema to catalog -->
  <target name="populateTestData" depends="populateCatalog,populateTestSchema"/>

  <!-- determine list of all SQL scripts to run during catalog init -->
  <target name="determineInitSql" 
    depends="initSqlWithFennel,initSqlWithoutFennel">
    <pathconvert property="filelist.initsql" refid="filelist.initsql"
      pathsep="${line.separator}" dirsep="${file.separator}" />
  </target>

  <target name="initSqlWithFennel" unless="fennel.disabled.istrue">
    <filelist dir="${initsql.dir}" id="filelist.initsql"
      files="createStorageWrappers.sql,createJdbcViews.sql,createSalesSchema.sql"/>
  </target>

  <target name="initSqlWithoutFennel" if="fennel.disabled.istrue">
    <filelist dir="${initsql.dir}" id="filelist.initsql"
      files="createStorageWrappers.sql,disableFennelStorage.sql,createJdbcViews.sql,createSalesSchema.sql"/>
  </target>

  <target name="populateTestSchema" depends="determineInitSql">
    <junit printsummary="yes" fork="yes" haltonerror="yes" haltonfailure="yes"
      tempdir="${testlog.dir}">
      <classpath refid="sqlline.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <sysproperty key="java.ext.dirs" value="${sqlline.dir}"/>
      <sysproperty key="net.sf.farrago.fileset.unitsql"
        value="${filelist.initsql}"/>
      <formatter type="plain"/>
      <formatter type="xml"/> <!-- for integration builds -->
      <test todir="${testlog.dir}" name="net.sf.farrago.test.FarragoSqlTest" />
    </junit>
  </target>

  <!-- back up the current catalog contents -->
  <target name="backupCatalog">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${catalog.backup.dir}" includes="*"/>
    </delete>
    <mkdir dir="${catalog.backup.dir}"/>
    <copy todir="${catalog.backup.dir}">
      <fileset dir="${catalog.dir}" includes="FarragoCatalog.bt?"/>
      <fileset dir="${catalog.dir}" includes="db.dat"/>
    </copy>
  </target>

  <!-- restore catalog from backup -->
  <target name="restoreCatalog" depends="cleanCatalogData">
    <copy todir="${catalog.dir}">
      <fileset dir="${catalog.backup.dir}"/>
    </copy>
  </target>

  <!-- NOTE:  doesn't work yet -->
  <target name="importCatalog" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <readXMI
        file="${xmi.dir}/FarragoCatalogInit.xml"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <!-- delete the catalog and everything generated for it -->
  <target name="cleanCatalog" depends="clean,cleanCatalogData">
    <delete file="${FarragoExtMetamodel.xmi}"/>
    <delete file="${FarragoExtMetamodelUML.xmi}"/>
    <delete file="${FarragoExtMetamodelUMLSansDiagrams.xmi}"/>
    <delete file="${FarragoExtMetamodelTransformed.xmi}"/>
    <delete file="${FarragoMetamodel.xmi}"/>
    <delete file="${FarragoMetamodelUnresolved.xmi}"/>
    <delete file="${xmi.dir}/FarragoCatalog.dtd"/>
    <delete file="${ExtModel.xmi}"/>
    <delete file="${ExtModelTransformed.xmi}"/>
    <delete file="${ExtModelUML.xmi}"/>
	<delete file="${ExtModelUMLSansDiagrams.xmi}"/>
	<delete file="${xmi.dir}/UnResolvedExtModel.xmi" />
  	<delete file="${FarragoMetamodelCWM.xmi}" />
  	<delete file="${FarragoMetamodelExt.xmi}" />
    <delete
      file="${src.dir}/net/sf/farrago/FarragoMetadataFactory.java"/>
    <delete dir="${catalog.src.dir}"/>
  </target>

  <!-- delete catalog data only -->
  <target name="cleanCatalogData">
    <delete>
      <fileset dir="${catalog.dir}" includes="*.dat"/>
      <fileset dir="${catalog.dir}" includes="FarragoCatalog.bt?"/>
    </delete>
  </target>

  <target name="exportCatalog" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <writeXMI
        file="${xmi.dir}/FarragoCatalogExport.xmi"
        extent="FarragoCatalog"
        xmiVersion = "1.2"/>
    </mdr>
  </target>

  <target name="exportMetamodel" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <writeXMI
        file="${xmi.dir}/FarragoMetamodelExport.xmi"
        extent="FarragoMetamodel"
        xmiVersion = "1.2"/>
    </mdr>
  </target>

  <target name="unzipExtMetamodel">
    <unzip src="${FarragoExtMetamodelUML.zuml}" dest="${xmi.dir}">
      <patternset>
        <include name="FarragoExtMetamodelUML.xmi"/>
      </patternset>
    </unzip>
  </target>

  <!-- unzip farrago extension model -->
  <target name="unzipExtModel" if="ext.model.file">
    <unzip src="${ext.model.file}" dest="${xmi.dir}">
      <patternset>
        <include name="${ExtModelFileName}.xmi"/>
      </patternset>
    </unzip>
  </target>

  <!-- NOTE:  Logger setting squelches unwanted INFORMATIONAL messages -->
  <target name="convertExtMetamodel" depends="unzipExtMetamodel">
    <uml2mof umlmodelname="${FarragoExtMetamodelUML.xmi}"
	  outputfilename="${FarragoExtMetamodel.xmi}"
	  umlsansdiagrams="${FarragoExtMetamodelUMLSansDiagrams.xmi}"/>
  </target>

  <target name="convertExtModel" depends="unzipExtModel"  if="ext.model.file">
    <uml2mof umlmodelname="${ExtModelUML.xmi}"
	  outputfilename="${ExtModel.xmi}"
	  umlsansdiagrams="${ExtModelUMLSansDiagrams.xmi}"/>
  </target>

  <target name="delPrim">
	 <xslt style="${xmi.dir}/delPrim.xsl"
		in="${ExtModel.xmi}"
		out="${xmi.dir}/UnResolvedExtModel.xmi" />
  </target>

  <target name="checkResourceUptodate">
    <uptodate property="resource.uptodate"
      srcfile="${farrago.resource.dir}/FarragoResource.xml"
      targetfile="${farrago.resource.dir}/FarragoResource.java"/>
    <uptodate property="resource.uptodate"
      srcfile="${eigenbase.resource.dir}/EigenbaseResource.xml"
      targetfile="${eigenbase.resource.dir}/EigenbaseResource.java"/>
  </target>

  <target name="generateResources" depends="mkdir.classes,checkResourceUptodate"
    unless="resource.uptodate">
    <!-- FarragoException.class needs to exist for reflection -->
    <javaCompile
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.3p.classpath">
      <include name="**/FarragoException.java" />
    </javaCompile>
    <taskdef name="resgen" classname="mondrian.resource.ResourceGenTask">
      <classpath refid="farrago.run.classpath"/>
    </taskdef>
    <resgen srcdir="${src.dir}" locales="en_US">
      <include name="net/sf/farrago/resource/FarragoResource.xml"/>
    </resgen>
    <resgen srcdir="${src.dir}" locales="en_US">
      <include name="org/eigenbase/resource/EigenbaseResource.xml"/>
    </resgen>
  </target>

  <target name="checkParserUptodate">
    <uptodate property="sqlParser.uptodate"
      targetfile="${parser.sql.dir}/Parser.java">
      <srcfiles dir="${parser.sql.dir}">
        <include name="Parser.jj"/>
        <include name="CommonParser.jj"/>
      </srcfiles>
    </uptodate>
    <uptodate property="parser.uptodate"
      targetfile="${parser.farrago.dir}/FarragoParserImpl.java">
      <srcfiles refid="fileset.parser.farrago.ddl"/>
      <srcfiles refid="fileset.parser.farrago.ddl.common"/>
      <srcfiles refid="fileset.parser.common.sql"/>
    </uptodate>
  </target>

  <!-- Generate the DDL parser. Generated files are:
       TokenMgrError.java, ParseException.java,
       JavaCharStream.java, Token.java -->
  <target name="ddlParser" depends="checkParserUptodate"
    unless="parser.uptodate">
    <generateParser combined="${parser.farrago.dir}/CombinedParser.jj">
      <components>
        <fileset refid="fileset.parser.farrago.ddl"/>
        <fileset refid="fileset.parser.farrago.ddl.common"/>
        <fileset refid="fileset.parser.common.sql"/>
      </components>
    </generateParser>
  </target>

  <!-- Generate the SQL parser. Generated files are:
       TokenMgrError.java, ParseException.java,
       JavaCharStream.java, Token.java, ASCII_UCodeESC_CharStream.java -->
  <target name="sqlParser" depends="checkParserUptodate"
    unless="sqlParser.uptodate">
    <generateParser combined="${parser.sql.dir}/CombinedParser.jj">
      <components>
        <filelist dir="${parser.sql.dir}" files="Parser.jj"/>
        <fileset refid="fileset.parser.common.sql"/>
      </components>
    </generateParser>
  </target>

  <!-- run all JUnit test cases (or a single test case chosen with -->
  <!-- property junit.class, normally from script junitSingle) -->
  <target name="junit" depends="all,cleanTestLogs">
    <mkdir dir="${testlog.dir}"/>
    <junit printsummary="yes" fork="yes" failureproperty="junit.failure"
      tempdir="${testlog.dir}">
      <classpath refid="sqlline.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <sysproperty key="java.ext.dirs" value="${sqlline.dir}"/>
      <sysproperty key="net.sf.farrago.fileset.unitsql"
        value="${fileset.unitsql}"/>
      <formatter type="plain"/>
      <formatter type="xml"/> <!-- for integration builds -->
      <batchtest todir="${testlog.dir}" unless="junit.class">
        <fileset dir="${classes.dir}">
          <exclude name="**/test/regression/*Test.class"/>
          <include name="**/*Test.class"/>
        </fileset>
      </batchtest>
      <test todir="${testlog.dir}" if="junit.class"
        name="${junit.class}" />
    </junit>
    <delete file="${FarragoTrace.log}.lck"/>
    <fail message="Test failure(s)" if="junit.failure"/>
  </target>

  <target name="test">
    <antcall target="createCatalog"/>
    <antcall target="junit"/>
    <antcall target="regressionWithoutBuild"/>
  </target>

  <!-- run all regression test cases -->
  <target name="regression" depends="all,cleanTestLogs">
    <antcall target="regressionWithoutBuild"/>
  </target>

  <!-- run all regression test cases; -->
  <!-- for use only as a subtarget to avoid destroying test logs from junit -->
  <target name="regressionWithoutBuild">
    <mkdir dir="${testlog.dir}"/>
    <junit printsummary="yes" fork="yes" failureproperty="junit.failure"
      tempdir="${testlog.dir}">
      <classpath refid="sqlline.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <sysproperty key="java.ext.dirs" value="${sqlline.dir}"/>
      <sysproperty key="net.sf.farrago.fileset.regressionsql"
        value="${fileset.regressionsql}"/>
      <formatter type="plain"/>
      <formatter type="xml"/> <!-- for integration builds -->
      <batchtest todir="${testlog.dir}" unless="junit.class">
        <fileset dir="${classes.dir}">
          <include name="**/regression/*Test.class"/>
        </fileset>
      </batchtest>
      <test todir="${testlog.dir}" if="junit.class"
        name="${junit.class}" />
    </junit>
    <delete file="${FarragoTrace.log}.lck"/>
    <fail message="Test failure(s)" if="junit.failure"/>
  </target>

  <!-- create the mdrlibs distribution; -->
  <!-- only use after building netbeans -->
  <target name="distLib3p">
    <mkdir dir="${mdrlibs.dir}"/>
    <copy
      file="${mdrant.dir}/release/mdrant.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/external/mof.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/external/jmi.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/netbeans/modules/autoload/mdrapi.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/netbeans/modules/ext/nbmdr.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/extras/jdbcstorage/release/mdrjdbc.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/netbeans/modules/autoload/ext/jmiutils.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/extras/uml2mof/release/uml2mof.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${mdr.dir}/extras/uml2mof/release/uml-1.4.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${netbeans.dir}/openide/util/netbeans/lib/openide-util.jar"
      todir="${mdrlibs.dir}"/>
    <copy
      file="${farrago.dir}/lib3p/LICENSE.src"
      tofile="${mdrlibs.dir}/LICENSE"/>
  </target>

  <!-- debug a JUnit test case; called from script junitDebug -->
  <target name="jswat.junit" depends="all">
    <fail message="property junit.class not defined" unless="junit.class"/>
    <jswatDebug
      classpath="${sqlline.classpath}"
      sourcepath="${jswat.junit.sourcepath}"
      classname="junit.textui.TestRunner">
      <jvmargs>
        <arg value="-Dnet.sf.farrago.fileset.unitsql=${fileset.unitsql}"/>
        <arg value="-Djava.ext.dirs=${sqlline.dir}"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="${junit.class}"/>
      </programargs>
    </jswatDebug>
  </target>

  <!-- Generate the Fennel C++ proxy classes for FEM -->
  <target name="generateFemCpp" depends="compile">
    <ant antfile="p4fem.xml"/>
    <javah
      classpathref="farrago.run.classpath"
      class="net.sf.farrago.fennel.FennelStorage"
      outputFile="${open.dir}/fennel/farrago/NativeMethods.h"/>
    <javaExec
      classname="net.sf.farrago.catalog.codegen.ProxyGen"
      classpathref="farrago.run.classpath">
      <arg value="${fennel.dir}/farrago/FemGeneratedClasses.h"/>
      <arg value="${fennel.dir}/farrago/FemGeneratedMethods.h"/>
      <arg value="${fennel.dir}/common/FemGeneratedEnums.h"/>
      <arg value="FEM.Fennel"/>
      <arg value="Fem"/>
    </javaExec>
  </target>

  <!-- Generate FarragoMetadataFactory -->
  <target name="generateMetadataFactory">
    <!-- FactoryGen.class needed for code generation -->
    <javaCompile
      srcdir="${src.dir}"
      destdir="${classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/FactoryGen.java" />
    </javaCompile>
    <javaExec
      classname="net.sf.farrago.catalog.codegen.FactoryGen"
      classpathref="farrago.run.classpath">
      <arg
        value="${src.dir}/net/sf/farrago/FarragoMetadataFactory.java"/>
      <arg value="net.sf.farrago"/>
      <arg value="FarragoMetadataFactory"/>
      <arg value="net.sf.farrago.FarragoPackage"/>
      <arg value="FarragoTempCatalog"/>
    </javaExec>
  </target>


  <!-- Debugging target for listing repository extents -->
  <target name="printRepositoryExtents" depends="mdr_taskdef">
    <mdr storageFile="${catalog.mdrStorage}">
      <printExtentNames/>
    </mdr>
  </target>

  <!-- Utility target for dumping the value of fileset.taggable into
  file.taggable.tmp in a form suitable for consumption by ctags,
  which always expects a Unix file format -->
  <target name="tags.find_taggable_files">
    <concat destfile="${file.taggable.tmp}">replaceme</concat>
    <pathconvert property="files.taggable"
      pathsep="${line.separator}"
      dirsep="/" refid="fileset.taggable" >
      <map from="${farrago.dir}" to="." />
    </pathconvert>
    <replace file="${file.taggable.tmp}"
      token="replaceme" value="${files.taggable}" />
    <fixcrlf srcDir="${farrago.dir}" includes="taggedfiles"
      eol="lf" eof="remove" />
  </target>

  <target name="macker">
    <path id="macker.classpath">
      <fileset dir="${macker.dir}/lib" includes="*.jar"/>
      <fileset dir="${macker.dir}/build" includes="macker.jar"/>
    </path>
    <taskdef name="macker"
      classname="net.innig.macker.ant.MackerAntTask"
      classpathref="macker.classpath"/>

    <macker maxMessages="10">
      <rules dir="${src.dir}" includes="**/*macker*.xml" />
      <classes dir="${classes.dir}">
        <include name="**/*.class" />
      </classes>
    </macker>
  </target>

  <!-- Beautify Farrago source code.  This forks a separate ant process using
       the server JVM to work around a problem documented at
       http://jalopy.sourceforge.net/javadoc.html. -->
  <target name="jalopy" depends="clean">
    <antFork target="forked_jalopy">
      <jvmargs>
        <jvmarg value="-server"/>
      </jvmargs>
    </antFork>
  </target>

  <target name="forked_jalopy">
    <taskdef name="jalopy"
      classname="de.hunsicker.jalopy.plugin.ant.AntPlugin">
      <classpath>
        <fileset dir="${jalopy.dir}/lib">
          <include name="*.jar"/>
        </fileset>
      </classpath>
    </taskdef>
    <!-- NOTE: may want to turn force off once rules stabilize -->
    <jalopy backup="true" convention="${src.dir}/jalopy.xml"
      classpathref="farrago.run.classpath" history="FILE" force="true">
      <fileset dir="${src.dir}">
        <include name="**/*.java"/>
        <exclude name="openjava/**/*.java"/>
      </fileset>
    </jalopy>
  </target>

  <!-- generate Emacs tags -->
  <target name="etags">
    <antcall target="tags.find_taggable_files"/>
    <exec dir="${farrago.dir}" executable="ctags">
      <arg line="-e"/>
      <arg line="-L taggedfiles"/>
    </exec>
    <delete file="${file.taggable.tmp}" quiet="true"/>
  </target>

  <!-- generate Farrago javadoc (clean first to get rid of dummy classes) -->
  <target name="javadoc" depends="clean, compile">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${javadoc.dir}" includes="*"/>
    </delete>
    <mkdir dir="${javadoc.dir}"/>
    <javadoc
      private="true"
      destdir="${javadoc.dir}"
      source="1.4"
      classpathref="farrago.run.classpath">
      <packageset dir="${catalog.src.dir}">
        <include name="**"/>
      </packageset>
      <packageset dir="${src.dir}">
        <include name="**"/>
      </packageset>
      <link href="http://www.netbeans.org/download/dev/javadoc/MdrAPIs"/>
      <link href="http://java.sun.com/products/jmi/jmi-1_0-fr-doc"/>
	  <link href="http://java.sun.com/j2se/1.4.2/docs/api"/>
	  <link href="http://java.sun.com/j2ee/1.4/docs/api"/>
      <link href="http://www.junit.org/junit/javadoc/3.8.1"/>
      <tag name="pre" description="Pre-condition:"
           scope="constructors,methods"/>
      <tag name="post" description="Post-condition:"
           scope="constructors,methods"/>
    </javadoc>
  </target>

  <!-- create the documentation tarball -->
  <target name="buildDoc" depends="javadoc">
    <delete file="${farrago.dir}/doc.tar" />
    <delete file="${farrago.dir}/doc.tar.gz" />
    <tar tarfile="${farrago.dir}/doc.tar">
      <tarfileset dir="${farrago.dir}" includes="doc/**" excludes="**/*.vsd"/>
    </tar>
    <gzip zipfile="${farrago.dir}/doc.tar.gz"
              src="${farrago.dir}/doc.tar" />
    <delete file="${farrago.dir}/doc.tar" />
  </target>

  <!-- run iSQL -->
  <target name="isql" depends="all">
    <iSQL
      classpath="isql.run.classpath"
      propertieshome="${farrago.dir}/isql">
    </iSQL>
  </target>

  <!-- NOTE:  To debug iSQL itself, you have to get its source and
  compile a debug build.
  -->

  <!-- run JSwat on iSQL -->
  <target name="jswat.isql" depends="all">
    <jswatDebug
      classpath="${isql.run.classpath}"
      sourcepath="${jswat.isql.sourcepath}"
      classname="org.isqlviewer.core.Launcher">
      <jvmargs>
        <arg value="-Disql.home=${farrago.dir}/isql"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
    </jswatDebug>
  </target>

  <!-- run JSwat on sqlline in interactive mode -->
  <target name="jswat.sqlline" depends="all">
    <jswatDebug
      classpath="${sqlline.classpath}"
      sourcepath="${jswat.sqlline.sourcepath}"
      classname="sqlline.SqlLine">
      <jvmargs>
        <arg value="-Djava.ext.dirs=${sqlline.dir}"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="-u jdbc:farrago: -d net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver -n guest"/>
      </programargs>
    </jswatDebug>
  </target>

  <!-- Dump the file classpath.gen for use outside of ant -->
  <target name="createClasspathFile">
    <delete file="${file.classpath}" quiet="true"/>
    <concat destfile="${file.classpath}">cccp</concat>
    <replace file="${file.classpath}" token="cccp"
      value="${sqlline.classpath}"/>
  </target>
  <property name="file.classpath"
    location="${farrago.dir}/classpath.gen"/>

  <!-- Create an MDR repository for use by SQL/MED tests -->
  <target name="createMdrTestData" depends="mdr_taskdef">
    <delete quiet="true">
      <fileset dir="unitsql/ddl" includes="mdr.bt?"/>
    </delete>
    <mdr storageFile="unitsql/ddl/mdr">
      <instantiate name="TestMof"/>
    </mdr>
  </target>

  <target name="testLeaks" depends="all,cleanTestLogs" >
    <javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.test.TestLeaks">
    </javaExec>
  </target>

  <target name="testLeaksJmp" depends="all,cleanTestLogs" >
    <javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.test.TestLeaks">
      <jvmarg line="-Xrunjmp:nomonitors"/>
      <arg value="jmp"/>
    </javaExec>
  </target>

  <!-- run JSwat on Farrago as an RmiJdbc server -->
  <target name="jswat.server" depends="all">
    <jswatDebug
      classpath="${farrago.run.classpath}"
      sourcepath="${server.sourcepath}"
      classname="net.sf.farrago.server.FarragoServer">
      <jvmargs>
        <arg line="&FarragoProps;"/>
      </jvmargs>
    </jswatDebug>
  </target>

  <!-- Below is all experimental stuff for the user repository -->

  <property name="JdbcStorage.prefix"
    value="MDRStorageProperty.org.netbeans.mdr.persistence.jdbcimpl"/>

  <target name="createUserRepository">
    <antFork target="forked_createUserRepository"
      classpathref="createUserRepository.classpath">
      <jvmargs>
        <jvmarg line="${assertions.jvmarg}"/>
        <jvmarg line="&FarragoProps;"/>
        <sysproperty
          key="org.netbeans.mdr.storagemodel.StorageFactoryClassName"
          value="org.netbeans.mdr.persistence.jdbcimpl.JdbcStorageFactory"/>
        <sysproperty
          key="${JdbcStorage.prefix}.url"
          value="jdbc:farrago:"/>
        <sysproperty
          key="${JdbcStorage.prefix}.schemaName"
          value="MDR"/>
        <sysproperty
          key="${JdbcStorage.prefix}.userName"
          value="MDR"/>
        <sysproperty
          key="${JdbcStorage.prefix}.driverClassName"
          value="net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver"/>
        <sysproperty
          key="${JdbcStorage.prefix}.datatype.streamable"
          value="VARBINARY(10000)"/>
      </jvmargs>
    </antFork>
  </target>

  <target name="jswat.createUserRepository" depends="all">
    <jswatDebug
      classpath="${createUserRepository.classpath}"
      sourcepath="${mdr.sourcepath}"
      classname="org.apache.tools.ant.Main">
      <jvmargs>
        <arg value="-Dorg.netbeans.mdr.storagemodel.StorageFactoryClassName=org.netbeans.mdr.persistence.jdbcimpl.JdbcStorageFactory"/>
        <arg value="-D${JdbcStorage.prefix}.url=jdbc:farrago:"/>
        <arg value="-D${JdbcStorage.prefix}.userName=MDR"/>
        <arg value="-D${JdbcStorage.prefix}.schemaName=MDR"/>
        <arg value="-D${JdbcStorage.prefix}.driverClassName=net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver"/>
        <arg value="-D${JdbcStorage.prefix}.datatype.streamable=VARBINARY(10000)"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="forked_createUserRepository"/>
      </programargs>
    </jswatDebug>
  </target>

  <target name="forked_createUserRepository" depends="mdr_taskdef">
    <mdr>
      <instantiate name="FarragoMetamodel"/>
      <printExtentNames/>
      <readXMI
        file="${FarragoMetamodel.xmi}"
        extent="FarragoMetamodel"/>
      <printExtentNames/>
      <instantiate
        name="FarragoCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
      <printExtentNames/>
      <readXMI
        file="${FarragoConf.xmi}"
        extent="FarragoCatalog"/>
    </mdr>
  </target>


  <target name="jar">
    <jar destfile="${dist.jar.file}" update="true" compress="true">
      <fileset dir="${farrago.dir}">
        <include name="README"/>
        <include name="COPYING"/>
      </fileset>
      <fileset dir="${classes.dir}">
        <include name="**/*.class"/>
      </fileset>
      <fileset dir="${src.dir}">
        <include name="**/*.properties"/>
      </fileset>
      <fileset dir="${catalog.src.dir}">
        <include name="**/*.class"/>
      </fileset>
    </jar>

    <copy file="${plugin.dir}/FarragoMedJdbc.jar" todir="${dist.plugin.dir}"/>
    <jar destfile="${dist.plugin.dir}/FarragoMedJdbc.jar" update="true">
      <fileset dir="${farrago.dir}">
        <include name="README"/>
        <include name="COPYING"/>
      </fileset>
    </jar>
  </target>
</project>
