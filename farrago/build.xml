<?xml version="1.0" encoding="UTF-8"?>
<!-- 
// $Id$
// Farrago is an extensible data management system.
// Copyright (C) 2005-2005 The Eigenbase Project
// Copyright (C) 2005-2005 Disruptive Tech
// Copyright (C) 2005-2005 Red Square, Inc.
// Portions Copyright (C) 2003-2005 John V. Sichi
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later Eigenbase-approved version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//  
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307  USA
-->

<!-- Farrago ant build script -->

<!-- These XML ENTITY "macros" help avoid redundancy in property -->
<!-- settings. They can be used with <jvmarg> or <arg> as the line -->
<!-- attribute. -->
<!DOCTYPE project [

<!ENTITY FarragoProps
"
-Dnet.sf.farrago.home=${farrago.dir}
-Djava.util.logging.config.file=${FarragoTrace.properties}
">

]>

<project name="farrago" basedir="." default="all">

  <!-- import the fennel.disabled setting; this takes highest precedence -->
  <property file="initBuild.properties"/>

  <!-- import local property overrides; these take precedence over
       later definitions in this file -->
  <property file="customBuild.properties"/>

  <!-- Definitions for Farrago build properties and macros -->
  <import file="buildMacros.xml"/>



  <!-- Directories -->

  <!-- directory for Farrago compiled classes which go into plugin .jars -->
  <property name="plugin.classes.dir" location="${farrago.plugin.dir}/classes"/>

  <!-- directory for JUnit run output -->
  <property name="testlog.dir" location="${farrago.dir}/testlog"/>

  <!-- directory in which javadoc should be generated -->
  <property name="javadoc.dir" location="${farrago.dir}/doc/api"/>

  <!-- directory for initialization scripts -->
  <property name="initsql.dir" location="${farrago.dir}/initsql"/>

  <!-- directory for unit test SQL scripts -->
  <property name="unitsql.dir" location="${farrago.dir}/unitsql"/>

  <!-- directory for regression test SQL scripts -->
  <property name="regressionsql.dir" location="${farrago.dir}/regressionsql"/>

  <!-- directory in which trace files are configured and generated -->
  <property name="trace.dir" location="${farrago.dir}/trace"/>


  <!-- The version of ANT we require. -->
  <property name="required.ant.version" value="1.6.2"/>

  <condition property="is.correct.ant.version">
    <contains string="${ant.version}" substring="${required.ant.version}"/>
  </condition>
  <fail unless="is.correct.ant.version"
      message="Incorrect ant version '${ant.version}';
require version '${required.ant.version}'."/>

  <!-- Files -->

  <!-- File for user-defined extension model. -->
  <!-- XMI file containing Farrago extension model -->
  <property name="ExtModel.xmi"
    location="${farrago.xmi.dir}/ExtModel.xmi"/>

  <!-- XMI file containing renumbered user-defined extension model -->
  <property name="ExtModelTransformed.xmi"
    location="${farrago.xmi.dir}/ExtModelTransformed.xmi"/>

  <!-- User-defined extension model file name without path -->
  <basename property="ExtModelFileName" file="${ext.model.file}" 
    suffix=".zuml"/>

  <!-- XMI file containing UML representation of user-defined extension model -->
  <property name="ExtModelUML.xmi"
    location="${farrago.xmi.dir}/${ExtModelFileName}.xmi"/>

  <!-- Same as ExtModelUML, but with diagrams deleted -->
  <property name="ExtModelUMLSansDiagrams.xmi"
    location="${farrago.xmi.dir}/ExtModelUMLSansDiagrams.xmi"/>

  <!-- File for user-defined extension model. -->



  <!-- Template developer configuration file. -->
  <property name="FarragoConfTemplate.xmi"
    location="${farrago.xmi.dir}/FarragoConfTemplate.xmi"/>

  <!-- Developer configuration file generated from template. -->
  <property name="FarragoConf.xmi"
    location="${farrago.xmi.dir}/FarragoConf.xmi"/>

  <!-- file prefix for catalog storage -->
  <property name="catalog.mdrStorage"
    location="${farrago.catalog.dir}/FarragoCatalog"/>

  <!-- Directories and filenames for distribution jar file. -->
  <property name="dist.dir" location="${farrago.dir}/dist"/>
  <property name="dist.plugin.dir" location="${farrago.dir}/dist/plugin"/>

  <property name="dist.jar.file" location="${dist.dir}/farrago.jar"/>

  <property name="FarragoTrace.properties"
    location="${trace.dir}/FarragoTrace.properties"/>

  <property name="FarragoTrace.log"
    location="${trace.dir}/FarragoTrace.log"/>

  <!-- NOTE:  this has to use true/false (not 1/0) for MDR import -->
  <property name="fennel.disabled" value="false"/>
  <condition property="fennel.disabled.istrue">
    <istrue value="${fennel.disabled}"/>
  </condition>

  <!-- a fileset of all files for which tags should be built -->
  <fileset dir="${farrago.dir}" id="fileset.taggable">
    <include name="catalog/java/**/*.java"/>
    <include name="src/**/*.java"/>
    <include name="examples/**/*.java"/>
    <include name="examples/**/package.java"/>
    <include name="src/**/package.html"/>
  </fileset>

  <!-- a fileset of all SQL unit tests -->
  <fileset dir="${unitsql.dir}" id="fileset.unitsql">
    <include name="**/*.sql"/>
  </fileset>
  <pathconvert property="fileset.unitsql" refid="fileset.unitsql"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- a fileset of all SQL regression tests -->
  <fileset dir="${regressionsql.dir}" id="fileset.regressionsql.std">
    <include name="**/*.sql"/>
  </fileset>
  <pathconvert property="fileset.regressionsql.std" 
    refid="fileset.regressionsql.std"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- TODO jvs 19-Sept-2004:  temporary hack -->
  <!-- a fileset of all SQL regression tests to run on Windows -->
  <fileset dir="${regressionsql.dir}" id="fileset.regressionsql.win">
    <include name="**/*.sql"/>
    <exclude name="**/numericStrCasts.sql"/>
    <exclude name="**/literalTests/real.sql"/>
    <exclude name="**/literalTests/string.sql"/>
  </fileset>
  <pathconvert property="fileset.regressionsql.win" 
    refid="fileset.regressionsql.win"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <condition property="fileset.regressionsql" 
    value="${fileset.regressionsql.std}">
    <not>
      <os family="windows"/>
    </not>
  </condition>

  <condition property="fileset.regressionsql" 
    value="${fileset.regressionsql.win}">
    <os family="windows"/>
  </condition>

  <!-- a fileset of all SQL concurrency tests -->
  <fileset dir="${unitsql.dir}" id="fileset.concurrentsql">
    <include name="**/*.mtsql"/>
  </fileset>
  <pathconvert property="fileset.concurrentsql" refid="fileset.concurrentsql"
    pathsep="${line.separator}" dirsep="${file.separator}" />

  <!-- name for a temp file used during tags generation -->
  <property name="file.taggable.tmp"
    location="${farrago.dir}/taggedfiles"/>

  <!-- newline for use in constructing strings -->
  <property name="nl" value="${line.separator}"/>


  <!-- Classpaths -->

  <!-- classpath for main build (after catalog codegen) -->
  <path id="farrago.build.classpath">
    <pathelement path="${farrago.3p.classpath}"/>
    <pathelement location="${farrago.catalog.src.dir}"/>
    <pathelement location="${sqlline.lib.dir}/sqlline.jar"/>
    <pathelement location="${sqlline.lib.dir}/jline.jar"/>
  </path>
  <property name="farrago.build.classpath" refid="farrago.build.classpath"/>

  <!-- classpath for plugin build) -->
  <path id="plugin.build.classpath">
    <pathelement path="${farrago.build.classpath}"/>
    <pathelement location="${farrago.classes.dir}"/>
  </path>
  <property name="plugin.build.classpath" refid="plugin.build.classpath"/>

  <!-- sourcepath for debugging -->
  <path id="farrago.sourcepath">
    <pathelement location="${farrago.catalog.src.dir}"/>
    <pathelement location="${farrago.src.dir}"/>
    <pathelement location="${isql.dir}/src"/>
    <pathelement location="${sqlline.dir}/src"/>
    <pathelement location="${junit.dir}/src.jar"/>
    <pathelement location="${rmijdbc.dir}/src"/>
    <pathelement location="${open.dir}/thirdparty/netbeans/mdr/src"/>
    <pathelement 
      location="${open.dir}/thirdparty/netbeans/mdr/extras/jdbcstorage/src"/>
  </path>
  <property name="farrago.sourcepath" refid="farrago.sourcepath"/>

  <!-- classpath for running from sqlline -->
  <path id="sqlline.classpath">
    <pathelement location="${sqlline.lib.dir}/sqlline.jar"/>
    <pathelement location="${sqlline.lib.dir}/jline.jar"/>
    <pathelement path="${farrago.run.classpath}"/>
  </path>
  <property name="sqlline.classpath" refid="sqlline.classpath"/>

  <!-- classpath for running tests via ant -->
  <path id="test.classpath">
    <pathelement path="${sqlline.classpath}"/>
    <pathelement path="${ant.classpath}"/>
  </path>
  <property name="test.classpath" refid="test.classpath"/>

  <!-- classpath for reentrantly invoking ant from createUserRepository -->
  <path id="createUserRepository.classpath">
    <pathelement path="${farrago.run.classpath}"/>
    <pathelement path="${ant.classpath}"/>
  </path>
  <property name="createUserRepository.classpath"
    refid="createUserRepository.classpath"/>


  <!-- classpath for running from iSQL -->
  <path id="isql.run.classpath">
    <pathelement path="${isql.classpath}"/>
    <pathelement path="${farrago.run.classpath}"/>
  </path>
  <property name="isql.run.classpath" refid="isql.run.classpath"/>


  <!-- Targets -->

  <!--

  Declare mdr task used for catalog manipulation.  Note that in order
  to use this task, we always fork an ant subprocess using java (not
  ant or antcall).  There are two reasons for this.  Most importantly,
  it makes sure that the repository is shut down properly.  Without
  this, invocations of mdr sometimes interfere with our own java tasks
  (e.g. populateCatalog).  Another reason is that it gives us a chance
  to set Java properties, most importantly the one that controls the
  mdr logging level, so we can suppress some spurious exception
  reports.

  -->

  <target name="mdr_taskdef">
    <taskdef name="mdr" classname="org.netbeans.mdrant.MdrTask"
      classpathref="farrago.run.classpath"/>
  </target>

  <!-- default target:  assumes catalog has already been created -->
  <target name="all"
    depends="compile, rmi, buildJdbcPlugin"/>

  <!-- create rmi stubs and skeletons -->
  <target name="rmi" depends="compile">
    <rmic base="${farrago.classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/server/FarragoRJConnectionServer.class" />
      <include name="**/server/FarragoRJMedDataWrapperServer.class" />
      <include name="**/server/FarragoRJDriverServer.class" />
    </rmic>
  </target>

  <target name="compile" depends="generateResources,sqlParser,ddlParser">
    <farrago.javaCompile
      deprecation="off"
      srcdir="${farrago.src.dir}"
      destdir="${farrago.classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/*.java" />
      <exclude name="**/namespace/jdbc/**/*.java" />
    </farrago.javaCompile>
  </target>

  <!-- compile only packages needed by Saffron -->
  <target name="compile.saffron.deps" depends="generateResources,sqlParser">
    <farrago.javaCompile
      deprecation="off"
      srcdir="${farrago.src.dir}"
      destdir="${farrago.classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="openjava/**/*.java" />
      <include name="org/eigenbase/**/*.java" />
      <include name="com/disruptivetech/farrago/volcano/**/*.java" />
    </farrago.javaCompile>
  </target>

  <!-- create classes directory -->
  <target name="mkdir.classes">
    <mkdir dir="${farrago.classes.dir}"/>
    <mkdir dir="${plugin.classes.dir}"/>
  </target>

  <!-- test only packages needed by Saffron -->
  <target name="test.saffron.deps" depends="compile.saffron.deps">
    <mkdir dir="${testlog.dir}"/>
    <junit printsummary="yes" fork="yes" failureproperty="junit.failure"
      tempdir="${testlog.dir}">
      <classpath refid="farrago.run.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <formatter type="plain"/>
      <batchtest todir="${testlog.dir}" unless="junit.class">
        <fileset dir="${farrago.classes.dir}">
          <include name="org/eigenbase/**/*Test.class"/>
          <include name="com/disruptivetech/farrago/volcano/**/*Test.class"/>
        </fileset>
      </batchtest>
      <test todir="${testlog.dir}" if="junit.class"
        name="${junit.class}" />
    </junit>
    <delete file="${FarragoTrace.log}.lck"/>
    <fail message="Test failure(s)" if="junit.failure"/>
  </target>

  <target name="buildJdbcPlugin"
    depends="checkJdbcPluginUptodate" unless="plugin.jdbc.uptodate">
    <farrago.javaCompile
      srcdir="${farrago.src.dir}"
      destdir="${plugin.classes.dir}"
      classpathref="plugin.build.classpath">
      <include name="**/namespace/jdbc/**/*.java" />
    </farrago.javaCompile>
    <jar jarfile="${farrago.plugin.dir}/FarragoMedJdbc.jar">
      <fileset dir="${plugin.classes.dir}">
        <include name="**/namespace/jdbc/**/*.class" />
      </fileset>
      <manifest>
        <attribute
          name="DataWrapperClassName"
          value="net.sf.farrago.namespace.jdbc.MedJdbcForeignDataWrapper" />
      </manifest>
    </jar>
  </target>

  <target name="checkJdbcPluginUptodate">
    <uptodate property="plugin.jdbc.uptodate"
      targetfile="${farrago.plugin.dir}/FarragoMedJdbc.jar">
      <srcfiles dir="${farrago.src.dir}"
        includes="**/namespace/jdbc/**/*.java"/>
    </uptodate>
  </target>

  <!-- cleans for non-catalog-generated code -->
  <target name="clean" depends="cleanTestLogs">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${farrago.classes.dir}" includes="**/*.class"/>
      <fileset dir="${plugin.classes.dir}" includes="**/*.class"/>
      <fileset dir="${farrago.plugin.dir}" includes="**/*.jar"/>
      <fileset dir="${farrago.classes.dir}"
        includes="net/sf/farrago/dynamic/**"/>
      <fileset dir="${farrago.dir}" includes="junit*.properties"/>
      <fileset dir="${farrago.dir}" includes="hs_err_pid*.log"/>
      <fileset dir="${farrago.src.dir}/net/sf/farrago/resource">
        <include name="*.java"/>
        <include name="FarragoResource_en_US.properties"/>
        <include name="FarragoResource.properties"/>
      </fileset>
      <fileset dir="${farrago.src.dir}/org/eigenbase/resource">
        <include name="*.java"/>
        <include name="EigenbaseResource_en_US.properties"/>
        <include name="EigenbaseResource.properties"/>
      </fileset>
      <fileset dir="${farrago.parser.ddl.dir}/impl" includes="*.java,*.jj"/>
      <fileset dir="${farrago.parser.sql.dir}/impl" includes="*.java,*.jj"/>
      <!-- TODO jvs 25-Jan-2005:  delete these after a while -->
      <fileset dir="${farrago.parser.ddl.dir}">
        <include name="CombinedParser.jj"/>
        <include name="FarragoParserImpl.java"/>
        <include name="FarragoParserImplConstants.java"/>
        <include name="FarragoParserImplTokenManager.java"/>
        <include name="TokenMgrError.java"/>
        <include name="ParseException.java"/>
        <include name="JavaCharStream.java"/>
        <include name="Token.java"/>
      </fileset>
      <fileset dir="${farrago.parser.sql.dir}">
        <include name="CombinedParser.jj"/>
        <include name="Parser.java"/>
        <include name="ParserConstants.java"/>
        <include name="ParserTokenManager.java"/>
        <include name="TokenMgrError.java"/>
        <include name="ParseException.java"/>
        <include name="JavaCharStream.java"/>
        <include name="Token.java"/>
        <include name="ASCII_UCodeESC_CharStream.java"/>
      </fileset>
      <fileset dir="${dist.plugin.dir}">
        <include name="*.jar"/>
      </fileset>
      <fileset dir="${dist.dir}">
        <include name="*.jar"/>
        <include name="*.tar.bz2"/>
      </fileset>
    </delete>
  </target>

  <target name="cleanTestLogs">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${testlog.dir}" includes="*.xml"/>
      <fileset dir="${testlog.dir}" includes="*.txt"/>
      <fileset dir="${testlog.dir}" includes="*.log"/>
      <fileset dir="${testlog.dir}" includes="*.dif"/>
      <fileset dir="${unitsql.dir}" includes="**/*.log"/>
      <fileset dir="${regressionsql.dir}" includes="**/*.log"/>
    </delete>
    <delete quiet="true" file="${FarragoTrace.log}"/>
    <!-- Some IDEs create duplicate copies of Resource.properties files under
         classes/. These override the uptodate properties files under src/
         and cause test exceptions.  Remove the duplicates. -->
    <delete quiet="true">
      <fileset dir="${farrago.classes.dir}"
          includes="**/*Resource*.properties"/>
    </delete>
  </target>

  <!-- creates catalog and populates with initial metadata -->
  <target name="createCatalog" depends="mkdir.classes,configureReposStorage">
    <antcall target="createClasspathFile"/>
    <antcall target="compileCatalog"/>
    <antcall target="createMdrTestData"/>
    <antcall target="importConfig"/>
    <antcall target="backupCatalog"/>
    <antcall target="populateTestData"/>
    <!-- NOTE:  redundant backup is an intentional checkpoint; in case
    populateTestData fails, it can be debugged from restored empty catalog -->
    <antcall target="backupCatalog"/>
  </target>

  <target name="createCatalogIfNotUptodate" depends="checkCatalogUptodate"
      unless="catalog.uptodate">
    <antcall target="createCatalog"/>
  </target>

  <!-- sets property ReposStorage.configured if ReposStorage.properties
       already exists-->
  <target name="checkReposStorage">
    <available property="ReposStorage.configured" 
      file="${farrago.ReposStorage.propfile}"/>
  </target>

  <!-- creates ReposStorage.properties from a default template unless
       it already exists -->
  <target name="configureReposStorage" depends="checkReposStorage"
    unless="ReposStorage.configured">
    <copy file="${farrago.catalog.dir}/templates/HsqldbRepos.properties" 
      tofile="${farrago.ReposStorage.propfile}"/>
  </target>

  <target name="compileCatalog"
    depends="cleanCatalog,createRepository"/>

  <!-- initialize catalog repository -->
  <target name="createRepository" 
    depends="configureTrace, convertExtMetamodel, convertExtModel">
    <mkdir dir="${farrago.catalog.dir}"/>
    <mkdir dir="${farrago.catalog.src.dir}"/>
    <farrago.synthesizeMetamodel
      extMofBasename="ExtModel"
      xmiDir="${farrago.xmi.dir}"/>
    <farrago.mdrFork target="forked_importMetamodel"/>
    <farrago.javaCompile
      srcdir="${farrago.catalog.src.dir}"
      destdir="${farrago.catalog.src.dir}"
      classpathref="farrago.3p.classpath">
      <include name="**/*.java"/>
    </farrago.javaCompile>
    <farrago.mdrFork target="forked_createCatalogRepository"/>
    <antcall target="compile.saffron.deps"/>
    <antcall target="generateMetadataFactory"/>
    <antcall target="all"/>
  </target>

  <!-- NOTE:  don't use mapClass below; we want to make sure all generated
  .java files can actually be compiled the old-fashioned way -->

  <target name="importMetamodel">
    <farrago.mdrFork target="forked_importMetamodel"/>
  </target>

  <target name="forked_importMetamodel" depends="mdr_taskdef">
    <mdr>
      <instantiate name="FarragoMetamodel"/>
      <readXMI
        file="${FarragoMetamodel.xmi}"
        extent="FarragoMetamodel"/>
      <mapJava
        dir="${farrago.catalog.src.dir}"
        extent="FarragoMetamodel"/>
    </mdr>
  </target>

  <target name="forked_createCatalogRepository" depends="mdr_taskdef">
    <mdr>
      <instantiate
        name="FarragoCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
      <writeDTD
        file="${farrago.xmi.dir}/FarragoCatalog.dtd"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <!-- generate developer configuration file and import it -->
  <target name="importConfig">
    <copy file="${FarragoConfTemplate.xmi}"
      tofile="${FarragoConf.xmi}" overwrite="true"/>

    <mkdir dir="${farrago.catalog.dir}/fennel"/>
    <copy todir="${farrago.catalog.dir}/fennel">
      <fileset dir="${fennel.dir}/common" includes="*.properties"/>
    </copy>

    <replace file="${FarragoConf.xmi}">
      <replacefilter token="@fennel.disabled@" value="${fennel.disabled}"/>
      <replacefilter token="@resourceDir@" value="$${FARRAGO_HOME}/catalog/fennel"/>
    </replace>
    <farrago.mdrFork target="forked_importConfig"/>
  </target>

  <!-- set up the default trace configuration file -->
  <target name="configureTrace">
    <mkdir dir="${trace.dir}"/>
    <touch file="${FarragoTrace.properties}"/>
    <propertyfile file="${FarragoTrace.properties}"
      comment="Farrago developer tracing configuration (do not add comments)">
      <entry key="handlers" default="java.util.logging.FileHandler"/>
      <entry key="java.util.logging.FileHandler.formatter"
        default="java.util.logging.SimpleFormatter"/>
      <entry key=".level" default="CONFIG"/>
      <entry key="java.util.logging.FileHandler.pattern"
        default="${FarragoTrace.log}"/>
      <entry key="java.util.logging.FileHandler.append" default="true"/>
      <entry key="net.sf.farrago.jdbc.level" default="FINER"/>
    </propertyfile>
  </target>

  <target name="forked_importConfig" depends="mdr_taskdef">
    <mdr>
      <readXMI
        file="${FarragoConf.xmi}"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <!-- write initial metadata to catalog -->
  <target name="populateCatalog">
    <farrago.javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.db.FarragoDatabase"/>
  </target>

  <!-- write sample schema to catalog -->
  <target name="populateTestData" depends="populateCatalog,populateTestSchema"/>

  <!-- determine list of all SQL scripts to run during catalog init -->
  <target name="determineInitSql" >
    <filelist dir="${initsql.dir}" id="filelist.initsql"
      files="createStorageWrappers.sql,createSqljSchema.sql,createJdbcViews.sql,createSalesSchema.sql"/>
    <pathconvert property="filelist.initsql" refid="filelist.initsql"
      pathsep="${line.separator}" dirsep="${file.separator}" />
  </target>

  <target name="populateTestSchema" depends="determineInitSql">
    <junit printsummary="yes" fork="yes" haltonerror="yes" haltonfailure="yes"
      tempdir="${testlog.dir}">
      <classpath refid="sqlline.classpath"/>
      <jvmarg line="${assertions.jvmarg}"/>
      <jvmarg line="&FarragoProps;"/>
      <sysproperty key="java.ext.dirs" value="${sqlline.dir}"/>
      <sysproperty key="net.sf.farrago.fileset.unitsql"
        value="${filelist.initsql}"/>
      <formatter type="plain"/>
      <formatter type="xml"/> <!-- for integration builds -->
      <test todir="${testlog.dir}" name="net.sf.farrago.test.FarragoSqlTest" />
    </junit>
  </target>

  <!-- back up the current catalog contents -->
  <target name="backupCatalog">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${farrago.catalog.backup.dir}" includes="*"/>
    </delete>
    <mkdir dir="${farrago.catalog.backup.dir}"/>
    <copy todir="${farrago.catalog.backup.dir}">
      <fileset dir="${farrago.catalog.dir}" includes="FarragoCatalog.*"/>
      <fileset dir="${farrago.catalog.dir}" includes="db.dat"/>
    </copy>
  </target>

  <!-- restore catalog from backup -->
  <target name="restoreCatalog" depends="cleanCatalogData">
    <copy todir="${farrago.catalog.dir}">
      <fileset dir="${farrago.catalog.backup.dir}"/>
    </copy>
  </target>

  <!-- delete the catalog and everything generated for it -->
  <target name="cleanCatalog" depends="clean,cleanCatalogData">
    <delete file="${FarragoExtMetamodel.xmi}"/>
    <delete file="${FarragoExtMetamodelUML.xmi}"/>
    <delete file="${FarragoExtMetamodelUMLSansDiagrams.xmi}"/>
    <delete file="${FarragoExtMetamodelTransformed.xmi}"/>
    <delete file="${FarragoMetamodel.xmi}"/>
    <delete file="${FarragoMetamodelUnresolved.xmi}"/>
    <delete file="${farrago.xmi.dir}/FarragoCatalog.dtd"/>
    <delete file="${ExtModel.xmi}"/>
    <delete file="${ExtModelTransformed.xmi}"/>
    <delete file="${ExtModelUML.xmi}"/>
    <delete file="${ExtModelUMLSansDiagrams.xmi}"/>
    <delete
      file="${farrago.src.dir}/net/sf/farrago/FarragoMetadataFactory.java"/>
    <delete dir="${farrago.catalog.src.dir}"/>
  </target>

  <!-- delete catalog data only -->
  <target name="cleanCatalogData">
    <delete>
      <fileset dir="${farrago.catalog.dir}" includes="*.dat"/>
      <fileset dir="${farrago.catalog.dir}" includes="FarragoCatalog.*"/>
    </delete>
  </target>

  <target name="exportCatalog">
    <farrago.mdrFork target="forked_exportCatalog"/>
  </target>

  <target name="forked_exportCatalog" depends="mdr_taskdef">
    <mdr>
      <writeXMI
        file="${farrago.xmi.dir}/FarragoCatalogExport.xmi"
        extent="FarragoCatalog"
        xmiVersion = "1.2"/>
    </mdr>
  </target>

  <target name="exportMetamodel" depends="mdr_taskdef">
    <mdr>
      <writeXMI
        file="${farrago.xmi.dir}/FarragoMetamodelExport.xmi"
        extent="FarragoMetamodel"
        xmiVersion = "1.2"/>
    </mdr>
  </target>

  <target name="convertExtMetamodel">
    <farrago.extractPoseidonModel 
      zumlFile="${FarragoExtMetamodelUML.zuml}"
      umlBasename="FarragoExtMetamodelUML"
      mofBasename="FarragoExtMetamodel"
      xmiDir="${farrago.xmi.dir}"/>
    <xslt style="${farrago.xmi.dir}/transformFEM.xsl"
      in="${FarragoExtMetamodel.xmi}"
      out="${FarragoExtMetamodelTransformed.xmi}" />
    <replace file="${FarragoExtMetamodelTransformed.xmi}"
      token="org.omg.xmi.namespace.Model" value="omg.org/mof.Model/1.3" />
  </target>

  <target name="convertExtModel" if="ext.model.file">
    <farrago.extractPoseidonModel 
      zumlFile="${ext.model.file}"
      umlBasename="${ExtModelFileName}"
      mofBasename="ExtModel"
      xmiDir="${farrago.xmi.dir}"/>
    <farrago.transformExtensionModel
      mofBasename="ExtModel"
      xmiDir="${farrago.xmi.dir}"
      modelPrefix="${ext.model.prefix}"/>
  </target>

  <target name="checkResourceUptodate">
    <condition property="resource.uptodate">
      <and>
        <uptodate
          srcfile="${farrago.resource.dir}/FarragoResource.xml"
          targetfile="${farrago.resource.dir}/FarragoResource.java"/>
        <uptodate property="resource.uptodate"
          srcfile="${eigenbase.resource.dir}/EigenbaseResource.xml"
          targetfile="${eigenbase.resource.dir}/EigenbaseResource.java"/>
      </and>
    </condition>
  </target>

  <target name="generateResources" depends="mkdir.classes,checkResourceUptodate"
    unless="resource.uptodate">
    <!-- Exception classes need to exist for reflection -->
    <farrago.javaCompile
      srcdir="${farrago.src.dir}"
      destdir="${farrago.classes.dir}"
      classpathref="farrago.3p.classpath">
      <include name="**/FarragoException.java" />
      <include name="**/SqlValidatorException.java" />
    </farrago.javaCompile>
    <taskdef name="resgen" classname="mondrian.resource.ResourceGenTask">
      <classpath refid="farrago.run.classpath"/>
    </taskdef>
    <resgen srcdir="${farrago.src.dir}" locales="en_US">
      <include name="net/sf/farrago/resource/FarragoResource.xml"/>
    </resgen>
    <resgen srcdir="${farrago.src.dir}" locales="en_US">
      <include name="org/eigenbase/resource/EigenbaseResource.xml"/>
    </resgen>
  </target>

  <target name="checkParserUptodate">
    <uptodate property="sqlParser.uptodate"
      targetfile="${farrago.parser.sql.dir}/impl/SqlParserImpl.java">
      <srcfiles dir="${farrago.parser.sql.dir}">
        <include name="Parser.jj"/>
        <include name="CommonParser.jj"/>
      </srcfiles>
    </uptodate>
    <uptodate property="parser.uptodate"
      targetfile="${farrago.parser.ddl.dir}/impl/FarragoParserImpl.java">
      <srcfiles refid="farrago.parser.ddl"/>
      <srcfiles refid="farrago.parser.common.ddl"/>
      <srcfiles refid="farrago.parser.common.sql"/>
    </uptodate>
  </target>

  <target name="checkCatalogUptodate">
    <uptodate property="catalog.uptodate"
      targetfile="${farrago.dir}/catalog/java/net/sf/farrago/FarragoPackage.java">
      <srcfiles dir="${farrago.dir}/catalog/xmi">
        <include name="FarragoExtMetamodelUML.zuml"/>
        <include name="${ext.model.file}"/>
        <include name="*.xsl"/>
      </srcfiles>
    </uptodate>
  </target>

  <!-- Generate the DDL parser. Generated files are:
       TokenMgrError.java, ParseException.java,
       JavaCharStream.java, Token.java -->
  <target name="ddlParser" depends="checkParserUptodate"
    unless="parser.uptodate">
    <farrago.generateParser 
      combined="${farrago.parser.ddl.dir}/impl/CombinedParser.jj">
      <components>
        <fileset refid="farrago.parser.ddl"/>
        <fileset refid="farrago.parser.common.ddl"/>
        <fileset refid="farrago.parser.common.sql"/>
      </components>
    </farrago.generateParser>
  </target>

  <!-- Generate the SQL parser. Generated files are:
       TokenMgrError.java, ParseException.java,
       JavaCharStream.java, Token.java, ASCII_UCodeESC_CharStream.java -->
  <target name="sqlParser" depends="checkParserUptodate"
    unless="sqlParser.uptodate">
    <farrago.generateParser 
      combined="${farrago.parser.sql.dir}/impl/CombinedParser.jj">
      <components>
        <filelist dir="${farrago.parser.sql.dir}" files="Parser.jj"/>
        <fileset refid="farrago.parser.common.sql"/>
      </components>
    </farrago.generateParser>
  </target>

  <!-- run all JUnit test cases (or a single test case chosen with -->
  <!-- property junit.class, normally from script junitSingle) -->
  <target name="junit" depends="all,cleanTestLogs">
    <farrago.antFork target="forked_junit" classpathref="test.classpath">
      <jvmargs>
        <jvmarg line="${assertions.jvmarg}"/>
        <jvmarg line="&FarragoProps;"/>
        <syspropertyset>
          <propertyref builtin="commandline"/>
        </syspropertyset>
      </jvmargs>
    </farrago.antFork>
    <delete file="${FarragoTrace.log}.lck"/>
  </target>

  <target name="forked_junit" depends="all,cleanTestLogs">
    <farrago.runTests>
      <testfileset>
        <fileset dir="${farrago.classes.dir}">
          <exclude name="**/test/regression/*Test.class"/>
          <exclude name="**/test/concurrent/*Test.class"/>
          <include name="**/*Test.class"/>
        </fileset>
      </testfileset>
      <junitargs>
        <sysproperty key="net.sf.farrago.fileset.unitsql"
          value="${fileset.unitsql}"/>
      </junitargs>
    </farrago.runTests>
  </target>

  <target name="test">
    <antcall target="createCatalog"/>
    <antcall target="buildExamples"/>
    <antcall target="junit"/>
    <antcall target="regressionWithoutBuild"/>
    <antcall target="macker"/>
    <antcall target="checkSourceFilePreambles"/>
  </target>

  <!-- run all regression test cases -->
  <target name="regression" depends="all,cleanTestLogs">
    <antcall target="regressionWithoutBuild"/>
  </target>

  <!-- run all regression test cases; -->
  <!-- for use only as a subtarget to avoid destroying test logs from junit -->
  <target name="regressionWithoutBuild">
    <farrago.antFork target="forked_regressionWithoutBuild" 
      classpathref="test.classpath">
      <jvmargs>
        <jvmarg line="${assertions.jvmarg}"/>
        <jvmarg line="&FarragoProps;"/>
        <syspropertyset>
          <propertyref builtin="commandline"/>
        </syspropertyset>
      </jvmargs>
    </farrago.antFork>
    <delete file="${FarragoTrace.log}.lck"/>
  </target>

  <target name="forked_regressionWithoutBuild">
    <farrago.runTests>
      <testfileset>
        <fileset dir="${farrago.classes.dir}">
          <include name="**/regression/*Test.class"/>
          <include name="**/concurrent/*Test.class"/>
        </fileset>
      </testfileset>
      <junitargs>
        <sysproperty key="net.sf.farrago.fileset.regressionsql"
          value="${fileset.regressionsql}"/>
        <sysproperty key="net.sf.farrago.fileset.concurrentsql"
          value="${fileset.concurrentsql}"/>
      </junitargs>
    </farrago.runTests>
  </target>

  <target name="generateTestSql" depends="compile">
    <farrago.javaExec classpathref="farrago.run.classpath"
      classname="org.eigenbase.test.SqlTestGen"/>
  </target>

  <!-- debug a JUnit test case; called from script junitDebug -->
  <target name="jswat.junit" depends="all">
    <fail message="property junit.class not defined" unless="junit.class"/>
    <farrago.jswatDebug
      classpath="${sqlline.classpath}"
      sourcepath="${farrago.sourcepath}"
      classname="junit.textui.TestRunner">
      <jvmargs>
        <arg value="-Dnet.sf.farrago.fileset.unitsql=${fileset.unitsql}"/>
        <arg value="-Djava.ext.dirs=${sqlline.dir}"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="${junit.class}"/>
      </programargs>
    </farrago.jswatDebug>
  </target>

  <!-- Generate the Fennel C++ proxy classes for FEM -->
  <target name="generateFemCpp" depends="compile">
    <ant antfile="p4fem.xml"/>
    <javah
      classpathref="farrago.run.classpath"
      class="net.sf.farrago.fennel.FennelStorage"
      outputFile="${open.dir}/fennel/farrago/NativeMethods.h"/>
    <farrago.javaExec
      classname="net.sf.farrago.catalog.codegen.ProxyGen"
      classpathref="farrago.run.classpath">
      <arg value="${fennel.dir}/farrago/FemGeneratedClasses.h"/>
      <arg value="${fennel.dir}/farrago/FemGeneratedMethods.h"/>
      <arg value="${fennel.dir}/common/FemGeneratedEnums.h"/>
      <arg value="FEM.Fennel"/>
      <arg value="Fem"/>
    </farrago.javaExec>


    <!-- not strictly part of fem, but it is JNI code -->
    <javah
      classpathref="farrago.run.classpath"
      class="net.sf.farrago.fennel.FennelPseudoUuidGenerator"
      outputFile="${open.dir}/fennel/farrago/JniPseudoUuid.h"/>
  </target>

  <!-- Generate FarragoMetadataFactory -->
  <target name="generateMetadataFactory">
    <!-- FactoryGen.class needed for code generation -->
    <farrago.javaCompile
      srcdir="${farrago.src.dir}"
      destdir="${farrago.classes.dir}"
      classpathref="farrago.build.classpath">
      <include name="**/FactoryGen.java" />
    </farrago.javaCompile>
    <farrago.javaExec
      classname="net.sf.farrago.catalog.codegen.FactoryGen"
      classpathref="farrago.run.classpath">
      <arg
        value="${farrago.src.dir}/net/sf/farrago/FarragoMetadataFactory.java"/>
      <arg value="net.sf.farrago"/>
      <arg value="FarragoMetadataFactory"/>
      <arg value="net.sf.farrago.FarragoPackage"/>
      <arg value="FarragoCatalog"/>
    </farrago.javaExec>
  </target>


  <!-- Debugging target for listing repository extents -->
  <target name="printRepositoryExtents" depends="mdr_taskdef">
    <mdr>
      <printExtentNames/>
    </mdr>
  </target>

  <!-- Utility target for dumping the value of fileset.taggable into
  file.taggable.tmp in a form suitable for consumption by ctags,
  which always expects a Unix file format -->
  <target name="tags.find_taggable_files">
    <concat destfile="${file.taggable.tmp}">replaceme</concat>
    <pathconvert property="files.taggable"
      pathsep="${line.separator}"
      dirsep="/" refid="fileset.taggable" >
      <map from="${farrago.dir}" to="." />
    </pathconvert>
    <replace file="${file.taggable.tmp}"
      token="replaceme" value="${files.taggable}" />
    <fixcrlf srcDir="${farrago.dir}" includes="taggedfiles"
      eol="lf" eof="remove" />
  </target>

  <target name="macker">
    <path id="macker.classpath">
      <fileset dir="${macker.dir}/lib" includes="*.jar"/>
      <fileset dir="${macker.dir}/build" includes="macker.jar"/>
    </path>
    <taskdef name="macker"
      classname="net.innig.macker.ant.MackerAntTask"
      classpathref="macker.classpath"/>

    <macker maxMessages="10">
      <rules dir="${farrago.src.dir}" includes="**/*macker*.xml" />
      <classes dir="${farrago.classes.dir}">
        <include name="**/*.class" />
      </classes>
    </macker>
  </target>

  <!-- Verify that all source files have the required headers -->
  <!-- TODO:  see if this works in non-Linux environments -->
  <target name="checkSourceFilePreambles">
    <exec os="Linux" dir="${farrago.dir}" failonerror="true"
      executable="${fennel.dir}/build/checkPreambleFarrago.sh">
    </exec>
  </target>

  <!-- Beautify Farrago source code.  This forks a separate ant process using
       the server JVM to work around a problem documented at
       http://jalopy.sourceforge.net/javadoc.html. -->
  <target name="jalopy" depends="clean">
    <farrago.antFork target="forked_jalopy">
      <jvmargs>
        <jvmarg value="-server"/>
      </jvmargs>
    </farrago.antFork>
  </target>

  <target name="forked_jalopy">
    <taskdef name="jalopy"
      classname="de.hunsicker.jalopy.plugin.ant.AntPlugin">
      <classpath>
        <fileset dir="${jalopy.dir}/lib">
          <include name="*.jar"/>
        </fileset>
      </classpath>
    </taskdef>
    <!-- NOTE: may want to turn force off once rules stabilize -->
    <jalopy backup="true" convention="${farrago.src.dir}/jalopy.xml"
      classpathref="farrago.run.classpath" history="FILE" force="true">
      <fileset dir="${farrago.src.dir}">
        <include name="**/*.java"/>
        <exclude name="openjava/**/*.java"/>
      </fileset>
    </jalopy>
  </target>

  <!-- generate Emacs tags -->
  <target name="etags">
    <antcall target="tags.find_taggable_files"/>
    <exec dir="${farrago.dir}" executable="ctags">
      <arg line="-e"/>
      <arg line="-L taggedfiles"/>
    </exec>
    <delete file="${file.taggable.tmp}" quiet="true"/>
  </target>

  <!-- generate Farrago javadoc (clean first to get rid of dummy classes) -->
  <target name="javadoc" depends="clean, compile">
    <delete includeEmptyDirs="true" quiet="true">
      <fileset dir="${javadoc.dir}" includes="*"/>
    </delete>
    <mkdir dir="${javadoc.dir}"/>
    <javadoc
      private="true"
      destdir="${javadoc.dir}"
      source="1.4"
      classpathref="farrago.run.classpath">
      <tag dir="src" includes="customJavadocTags.txt"/>
      <packageset dir="${farrago.catalog.src.dir}">
        <include name="**"/>
      </packageset>
      <packageset dir="${farrago.src.dir}">
        <include name="**"/>
      </packageset>
      <link href="http://www.netbeans.org/download/dev/javadoc/MdrAPIs"/>
      <link href="http://java.sun.com/products/jmi/jmi-1_0-fr-doc"/>
	  <link href="http://java.sun.com/j2se/1.4.2/docs/api"/>
	  <link href="http://java.sun.com/j2ee/1.4/docs/api"/>
      <link href="http://www.junit.org/junit/javadoc/3.8.1"/>
    </javadoc>
  </target>

  <!-- create the documentation tarball -->
  <target name="buildDoc" depends="javadoc">
    <delete file="${farrago.dir}/doc.tar" />
    <delete file="${farrago.dir}/doc.tar.gz" />
    <tar tarfile="${farrago.dir}/doc.tar">
      <tarfileset dir="${farrago.dir}" includes="doc/**" excludes="**/*.vsd"/>
    </tar>
    <gzip zipfile="${farrago.dir}/doc.tar.gz"
              src="${farrago.dir}/doc.tar" />
    <delete file="${farrago.dir}/doc.tar" />
  </target>

  <!-- run iSQL -->
  <target name="isql" depends="all">
    <farrago.iSQL
      classpath="isql.run.classpath"
      propertieshome="${farrago.dir}/isql">
    </farrago.iSQL>
  </target>

  <!-- NOTE:  To debug iSQL itself, you have to get its source and
  compile a debug build.
  -->

  <!-- run JSwat on iSQL -->
  <target name="jswat.isql" depends="all">
    <farrago.jswatDebug
      classpath="${isql.run.classpath}"
      sourcepath="${farrago.sourcepath}"
      classname="org.isqlviewer.core.Launcher">
      <jvmargs>
        <arg value="-Disql.home=${farrago.dir}/isql"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
    </farrago.jswatDebug>
  </target>

  <!-- run JSwat on sqlline in interactive mode -->
  <target name="jswat.sqlline" depends="all">
    <farrago.jswatDebug
      classpath="${sqlline.classpath}"
      sourcepath="${farrago.sourcepath}"
      classname="sqlline.SqlLine">
      <jvmargs>
        <arg value="-Djava.ext.dirs=${sqlline.dir}"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="-u jdbc:farrago: -d net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver -n guest"/>
      </programargs>
    </farrago.jswatDebug>
  </target>

  <!-- Dump the file classpath.gen for use outside of ant -->
  <target name="createClasspathFile">
    <delete file="${file.classpath}" quiet="true"/>
    <concat destfile="${file.classpath}">cccp</concat>
    <replace file="${file.classpath}" token="cccp"
      value="${sqlline.classpath}"/>
  </target>
  <property name="file.classpath"
    location="${farrago.dir}/classpath.gen"/>

  <!-- Create an MDR repository for use by SQL/MED tests -->
  <target name="createMdrTestData" depends="mdr_taskdef">
    <delete quiet="true">
      <fileset dir="unitsql/ddl" includes="mdr.bt?"/>
    </delete>
    <mdr storageFile="unitsql/ddl/mdr">
      <instantiate name="TestMof"/>
    </mdr>
  </target>

  <target name="testLeaks" depends="all,cleanTestLogs" >
    <farrago.javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.test.TestLeaks">
    </farrago.javaExec>
  </target>

  <target name="testLeaksJmp" depends="all,cleanTestLogs" >
    <farrago.javaExec classpathref="farrago.run.classpath"
      classname="net.sf.farrago.test.TestLeaks">
      <jvmarg line="-Xrunjmp:nomonitors"/>
      <arg value="jmp"/>
    </farrago.javaExec>
  </target>

  <!-- run JSwat on Farrago as an RmiJdbc server -->
  <target name="jswat.server" depends="all">
    <farrago.jswatDebug
      classpath="${farrago.run.classpath}"
      sourcepath="${farrago.sourcepath}"
      classname="net.sf.farrago.server.FarragoServer">
      <jvmargs>
        <arg line="&FarragoProps;"/>
      </jvmargs>
    </farrago.jswatDebug>
  </target>

  <!-- verify that ReposStorage.properties is correctly configured 
       for storage via JDBC -->
  <target name="verifyReposSqlStorage" depends="configureReposStorage">
    <loadproperties srcFile="${farrago.ReposStorage.propfile}">
      <filterchain>
        <tokenfilter>
          <replacestring 
            from="MDRStorageProperty.org.netbeans.mdr.persistence."
            to=""/>
        </tokenfilter>
      </filterchain>
    </loadproperties>
    <sql 
      driver="${jdbcimpl.driverClassName}"
      url="${jdbcimpl.url}"
      userid="${jdbcimpl.userName}"
      password="${jdbcimpl.password}"
      classpath="${farrago.3p.classpath}"
      rdbms="nonexistentSQL">
      <![CDATA[bogus]]>
    </sql>
    <echo message="Successfully connected to ${jdbcimpl.url}"/>
  </target>

  <target name="buildExamples" depends="compile">
    <ant antfile="examples/plannerviz/build.xml" inheritAll="false"/>
  </target>

  <!-- Below is all experimental stuff for the user repository -->

  <property name="JdbcStorage.prefix"
    value="MDRStorageProperty.org.netbeans.mdr.persistence.jdbcimpl"/>

  <target name="createUserRepository">
    <farrago.antFork target="forked_createUserRepository"
      classpathref="createUserRepository.classpath">
      <jvmargs>
        <jvmarg line="${assertions.jvmarg}"/>
        <jvmarg line="&FarragoProps;"/>
        <sysproperty
          key="org.netbeans.mdr.storagemodel.StorageFactoryClassName"
          value="org.netbeans.mdr.persistence.jdbcimpl.JdbcStorageFactory"/>
        <sysproperty
          key="${JdbcStorage.prefix}.url"
          value="jdbc:farrago:"/>
        <sysproperty
          key="${JdbcStorage.prefix}.schemaName"
          value="MDR"/>
        <sysproperty
          key="${JdbcStorage.prefix}.userName"
          value="MDR"/>
        <sysproperty
          key="${JdbcStorage.prefix}.driverClassName"
          value="net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver"/>
        <sysproperty
          key="${JdbcStorage.prefix}.datatype.streamable"
          value="VARBINARY(10000)"/>
      </jvmargs>
    </farrago.antFork>
  </target>

  <target name="jswat.createUserRepository" depends="all">
    <farrago.jswatDebug
      classpath="${createUserRepository.classpath}"
      sourcepath="${farrago.sourcepath}"
      classname="org.apache.tools.ant.Main">
      <jvmargs>
        <arg value="-Dorg.netbeans.mdr.storagemodel.StorageFactoryClassName=org.netbeans.mdr.persistence.jdbcimpl.JdbcStorageFactory"/>
        <arg value="-D${JdbcStorage.prefix}.url=jdbc:farrago:"/>
        <arg value="-D${JdbcStorage.prefix}.userName=MDR"/>
        <arg value="-D${JdbcStorage.prefix}.schemaName=MDR"/>
        <arg value="-D${JdbcStorage.prefix}.driverClassName=net.sf.farrago.jdbc.engine.FarragoJdbcEngineDriver"/>
        <arg value="-D${JdbcStorage.prefix}.datatype.streamable=VARBINARY(10000)"/>
        <arg line="&FarragoProps;"/>
      </jvmargs>
      <programargs>
        <arg value="forked_createUserRepository"/>
      </programargs>
    </farrago.jswatDebug>
  </target>

  <target name="forked_createUserRepository" depends="mdr_taskdef">
    <mdr>
      <instantiate name="FarragoMetamodel"/>
      <printExtentNames/>
      <readXMI
        file="${FarragoMetamodel.xmi}"
        extent="FarragoMetamodel"/>
      <printExtentNames/>
      <instantiate
        name="FarragoCatalog"
        extent="FarragoMetamodel"
        package="Farrago"/>
      <printExtentNames/>
      <readXMI
        file="${FarragoConf.xmi}"
        extent="FarragoCatalog"/>
    </mdr>
  </target>

  <target name="jar">
    <jar destfile="${dist.jar.file}" update="true" compress="true">
      <fileset dir="${farrago.dir}">
        <include name="README"/>
        <include name="COPYING"/>
      </fileset>
      <fileset dir="${farrago.classes.dir}">
        <include name="**/*.class"/>
      </fileset>
      <fileset dir="${farrago.src.dir}">
        <include name="**/*.properties"/>
      </fileset>
      <fileset dir="${farrago.catalog.src.dir}">
        <include name="**/*.class"/>
      </fileset>
    </jar>

    <copy file="${farrago.plugin.dir}/FarragoMedJdbc.jar" 
      todir="${dist.plugin.dir}"/>
    <jar destfile="${dist.plugin.dir}/FarragoMedJdbc.jar" update="true">
      <fileset dir="${farrago.dir}">
        <include name="README"/>
        <include name="COPYING"/>
      </fileset>
    </jar>
  </target>
</project>
