<html>

<head>
<title>Farrago SQL/MED Plugin for JDBC</title>
<link rel="stylesheet" type="text/css" href="../stylesheet.css" />

</head>

<body>

<h1>Farrago SQL/MED Plugin for JDBC</h1>

Farrago provides a plugin implementing <a href="sqlmed.html">SQL/MED access</a>
to any foreign DBMS for which a JDBC driver is available.  

<p>

Farrago supports the SQL standard three-level qualifier scheme for the
names of tables: <code>catalog.schema.table</code>.  When using the
SQL/MED plugin for JDBC to make foreign data namespaces accessible
from Farrago SQL queries, it is important to keep a number of points
in mind:

<ul>

<li>Different JDBC drivers support different qualifier schemes.  Some
support catalogs and schemas; others only support schemas; and still
others support neither catalogs nor schemas.  Default values may or may
not be in effect depending on the server connection URL.  For this
reason, the user must be careful when defining the foreign server
in Farrago to get the desired mapping.

<li>When referencing foreign tables directly via a virtual catalog (without
importing their metadata into a local schema), use the foreign schema
and table name.  In this case, the catalog name will be the name given
the foreign server via CREATE SERVER.

<li>When referencing foreign table via locally defined or imported
metadata, use the local schema and table name.  In this case, the
catalog name will be LOCALDB.

</ul>

<h2>JDBC Foreign Data Wrapper Definition</h2>

Because this plugin is included as part of the standard Farrago
distribution, a corresponding foreign data wrapper instance named
<code>SYS_JDBC</code> is predefined by Farrago's initialization
scripts.  Normally, there is no need to define additional instances.

<p>

However, it may be useful to define additional wrapper instances
corresponding to specific DBMS types.  For the JDBC plugin, all
SQL/MED options declared on the wrapper are propagated to the server,
allowing common option settings to be factored out of individual
server definitions.  (Note that this is not necessarily true for other
plugins.)  Option settings on a server always take precedence over
settings inherited from a wrapper.

<h2>JDBC Foreign Server Definition</h2>

In order to access a particular JDBC data source, a corresponding
foreign server must be defined.  The following server-level options
can be specified:

<p>
<table border="1">
<tr>
<td><b>Name</b></td>
<td><b>Description</b></td>
</tr>
<tr>
<td>DRIVER_CLASS</td>
<td>Fully qualified name of the JDBC driver class to load; this must be 
available on the classpath.  Currently this requires either changing
the classpath used to invoke Farrago, or rolling the JDBC driver classes
into a new plugin jar combined with the default Farrago plugin contents.
(We plan to eventually support the SQL:2003 jar dependencies feature
to eliminate this repackaging burden.)</td>
</tr>
<tr>
<td>URL</td>
<td>JDBC URL specifying the data source to access</td>
</tr>
<tr>
<td>USER_NAME</td>
<td>User name for login to foreign server</td>
</tr>
<tr>
<td>PASSWORD</td>
<td>Password for login to foreign server</td>
</tr>
<tr>
<td>USE_SCHEMA_NAME_AS_FOREIGN_QUALIFIER</td> 
<td>If set to 'TRUE', then for tables without a table-level SCHEMA_NAME
specified, the server-level SCHEMA_NAME is used. The default is 'FALSE'.
</td>
</tr>
<tr>
<tr>
<td>SCHEMA_NAME</td> 
<td> If USE_SCHEMA_NAME_AS_FOREIGN_QUALIFIER is set to 'FALSE':<br>
Artificial foreign schema name.  This option is only required for
servers which don't support schemas.  When specified, the plugin will
accept this schema name as a foreign qualifier when importing foreign tables
or accessing them directly, but will omit all schema references when
sending SQL to the foreign server.  For servers that support schemas,
this option should never be specified; reference the real foreign schema names 
instead. <br>
If USE_SCHEMA_NAME_AS_FOREIGN_QUALIFIER is set to 'TRUE':<br>
Server must support schemas. This SCHEMA_NAME will be used if the table-level
SCHEMA_NAME is not set.
</td>
</tr>
<tr>
<td>SCHEMA_MAPPING</td>
<td>
Semicolon-separated list of schema_name:mapped_schema_name pairs.  This
option is only valid for servers which support schemas.  This allows for
a single schema view of tables spanning multiple schemas. If set, TABLE_MAPPING
must not be set. A schema or table name may be quoted by the double quote character.  
The double quote character can be used in a name, if escaped by itself 
(the double quote character). A single quote character can be used,
if escaped by itself (the single quote character). 
</td>
</tr>
<tr>
<td>TABLE_MAPPING</td>
<td>
Semicolon-separated list of source_schema.source_table:mapped_schema.mapped_table pairs.
This option is only valid for servers which support schemas.  This allows for
a single schema view of the specified tables spanning multiple schemas. 
If set, SCHEMA_MAPPING must not be set.  A schema or table
name may be quoted by the double quote character.  The double quote character 
can be used in a name, if escaped by itself (the double quote character). 
A single quote character can be used, if escaped by itself (the single quote character). 
</td>
</tr>
<td>QUALIFYING_CATALOG_NAME</td> 
<td>Foreign catalog name to which this server should correspond.  This
option should only be used for servers which support multiple
catalogs.  Normally, a default catalog is always defined for a
connection, so this option isn't usually required.  To access multiple
catalogs from the same physical server, create multiple logical
servers, each with a different value for this option.
</td>
</tr>
<tr>
<td>TABLE_TYPES</td>
<td>Comma-separated list of table types used to restrict metadata
results for operations such as IMPORT FOREIGN SCHEMA.  For example,
some servers mix system tables into the same schema with user tables
and views.  To hide them, specify a value like 'TABLE,VIEW' for this
option.  To retrieve only tables and system tables, but no views, use
'TABLE,SYSTEM TABLE'.  In general, table type names may vary across
JDBC drivers, so check your driver's documentation or call your
driver's DatabaseMetaData.getTableTypes() method to list the available
types.  This option is never required; if not specified, metadata for
all table types is returned.  No spaces are allowed in the list
unless they make up part of the type name, e.g. 'SYSTEM TABLE'. 
</td>
</tr>
<tr>
<td>EXTENDED_OPTIONS</td>
<td>
If set to 'TRUE', unrecognized options are passed through to the JDBC
driver as properties; otherwise, they are ignored.  The default is 'FALSE'.
</td>
</tr>
<tr>
<td>TYPE_SUBSTITUTION</td>
<td>
If set to 'TRUE' (the default), datatypes which are not supported
by Farrago are replaced with the best available substitute.  If set to
'FALSE', unsupported datatypes result in errors.  Note that any 
TYPE_MAPPING specified is executed before TYPE_SUBSTITUTION is run.
</td>
</tr>
<tr>
<td>TYPE_MAPPING</td>
<td>
Semicolon-separated list of orig_datatype:subst_datatype pairs.  If
set, Farrago will replace the type of foreign columns matching
orig_datatype with the corresponding subst_datatype.  The format for
both datatype strings is DATATYPE_NAME[(PRECISION[,SCALE])] with no
spaces allowed.  On orig_datatype, precision and scale (if specified)
are used to more precisely limit the matching datatype.  In other
words, "DECIMAL" will match any decimal type, but "DECIMAL(10,2)" will
only match that specific precision and scale.  If precision and scale
are not specified on subst_datatype, the original precision and scale
are kept.  If the 'subst_datatype' is not a supported Farrago
datatype, the mapping is ignored.  Note that TYPE_MAPPING is run
before TYPE_SUBSTITUTION and does not depend on TYPE_SUBSTITUTION.
</td>
</tr>
<tr>
<td>LENIENT</td>
<td>
If set to 'TRUE', match target columns specified in the foreign table
definition with data source columns using case-sensitive string
comparison on column name.  Specified target columns which are missing
in the source are filled in with null. Likewise, specified target
columns with types that are cast-incompatible from matching source
columns are filled in with null.  Other matching columns are cast to
the target type (either the type specified explicitly, or the type
stored in the catalog when the foreign table descriptor is created
with implicit column types).  The default is 'FALSE', meaning columns
are mapped by position rather than name, and mismatches in the mapping
may lead to runtime errors.
<p>
Lenience makes the foreign table definition resilient to changes
in the data source; strictness ensures that data is not accidentally
lost or fabricated due to a mismapping.
</td>
<tr>
<td>LOGIN_TIMEOUT</td>
<td>
The maximum time in seconds to wait while attempting to connect to
foreign server.
</td>
</tr>
<tr>
<td>VALIDATION_QUERY</td>
<td>
The SQL query to use to validate connections in the JDBC wrapper
cache. If not specified, no connection validation will be done.  If
specified, must be a query (in a dialect understood by the foreign
JDBC driver being used) which will return at least one row without
error.
</td>
</tr>
<tr>
<td>DISABLED_PUSHDOWN_REL_PATTERN</td>
<td>
A regular expression matching the names of logical relational expressions
for which pushdown to data source should be disabled.  To enable all
pushdown, the value can be left as empty string (the default).  To
disable all pushdown, the value can be set to a match-anything regular
expression ('.*').  To disable a particular expression, the value can be
set to the corresponding optimizer RelNode class name, e.g. 'FilterRel'.
</td>
</tr>
<tr>
<td>FETCH_SIZE</td>
<td>
An integer fetch size to set on cursors via Statement.setFetchSize.  Default
is -1 (don't call setFetchSize at all).
</td>
</tr>
<tr>
<td>AUTOCOMMIT</td>
<td>
If set to 'TRUE' (the default), leave connection in autocommit mode.
Otherwise, request transaction mode.  For read-only usage, this normally
doesn't matter, since the wrapper closes cursors as soon as it is done
with them, but some JDBC drivers are sensitive (e.g. the PostgreSQL driver,
which requires an explicit FETCH_SIZE and non-autocommit to avoid
exhausting memory for large result sets).
</td>
</tr>
</table>
<p>

For example:

<pre><code>
create server ora_sales_server
foreign data wrapper sys_jdbc
options(
    driver_class 'oracle.jdbc.driver.OracleDriver',
    url 'jdbc:oracle:thin:@localhost:1521:ora1',
    user_name 'scott',
    password 'tiger',
    type_mapping 'DATE:TIMESTAMP;DECIMAL(22,0):DOUBLE',
    validation_query 'select 1 from dual');
</code></pre>

(The Oracle JDBC driver incorrectly exposes datetime types without
nanoseconds as DATE, and exposes floating-point numerics as DECIMAL(22,0),
so the mappings above are usually required.)

<p>

The following JDBC API calls are made in order to validate a foreign server
definition:

<ul>
<li>DriverManager.getConnection
<li>Connection.getMetaData (if supported)
<li>Connection.setAutoCommit (only if <code>AUTOCOMMIT</code> is set to false)
<li>DatabaseMetaData.XXX (various calls to test for supported features)
</ul>

<h2>JDBC Foreign Table Definition</h2>

The only option always required when defining a JDBC foreign
table is <code>TABLE_NAME</code> (or <code>OBJECT</code>):

<pre><code>
create schema ora_sales;

create foreign table ora_sales.dept
server ora_sales_server
options(table_name 'DEPT');
</code></pre>

<p>

For servers which support multiple schemas, the <code>SCHEMA_NAME</code>
option can be specified at the table level to choose a schema other
than the default:

<pre><code>
create schema sqlsrvr_sales;

create foreign table sqlsrvr_sales.dept
server sqlsrvr_sales_server
options(schema_name 'DBO', table_name 'DEPT');
</code></pre>

The following JDBC API calls are made in order to validate a foreign table
definition:

<ul>
<li>Connection.getMetaData
<li>Connection.prepareStatement (if supported)
<li>PreparedStatement.getMetaData (if supported)
<li>PreparedStatement.executeQuery (if supported)
<li>Connection.createStatement (only if PreparedStatement not supported)
<li>Statement.executeQuery (only if PreparedStatement not supported)
<li>ResultSet.getMetaData (only if PreparedStatement not supported)
<li>ResultSetMetaData.getColumnCount
<li>ResultSetMetaData.getColumnName
<li>ResultSetMetaData.getColumnType
<li>ResultSetMetaData.getPrecision
<li>ResultSetMetaData.getScale
<li>ResultSetMetaData.isNullable
</ul>

<h2>Querying JDBC Foreign Tables</h2>

Once defined, JDBC foreign tables may be queried just like local
tables.  The following two queries are equivalent (the first one
references the virtual catalog, while the second one references the
local metadata copy):

<pre><code>
select * from ora_sales_server.scott.dept;

select * from ora_sales.dept;
</code></pre>

Currently, relational operators such as filters, projections,
aggregations, and joins are not pushed down into the SQL query used to
access the foreign server.  For example, to implement the following
query, all <code>dept</code> rows are fetched from Oracle, and then
the filter is applied locally inside of Farrago:

<pre><code>
select * from ora_sales.dept
where deptno=10;
</code></pre>

True distributed query optimization will be implemented in a future
Farrago release.

<p>

The following JDBC API calls are made in order to execute a query against
a foreign table:

<ul>
<li>Connection.createStatement
<li>Statement.executeQuery
<li>Statement.setFetchSize (only if FETCH_SIZE is set)
<li>ResultSet.getXXX (where XXX depends on datatype of column queried)
</ul>

By default, connections to JDBC data sources are in autocommit mode,
meaning that each foreign query runs in its own read-only transaction
which ends automatically when the top-level Farrago query is closed.
(If a single Farrago query accesses multiple foreign tables, then
multiple foreign queries may be issued, even if all of the foreign
tables are from the same data source.)  The default isolation level is
DBMS-dependent, and so the effect of SQL/MED queries on foreign
concurrency control (e.g. read locks) also varies by DBMS.

<h2>JDBC Metadata Import</h2>

Multiple foreign table definitions can be imported into Farrago
automatically with the IMPORT FOREIGN SCHEMA statement:

<pre><code>
import foreign schema sales
from server ora_sales_server
into ora_sales;

select * from ora_sales.emp;
</code></pre>

<p>

The following JDBC API calls are made in order to perform the import:

<ul>
<li>DatabaseMetaData.getTables
<li>DatabaseMetaData.getColumns
</ul>

<h2>Updating JDBC Foreign Tables</h2>

<em>NOTE</em>: update functionality is not yet implemented; this
section describes the planned support.

The Farrago SQL/MED plugin for JDBC will support the standard
INSERT/UPDATE/DELETE DML statements with a foreign table as the target,
e.g.

<pre><code>
insert into ora_sales.dept 
select * from sales.depts;

delete from ora_sales.dept
where deptno=10;
</code></pre>

Each row to be modified by the query corresponds to an individual
execution of a prepared statement.  The existence of a primary key is
required for DELETE or UPDATE.

<p>

New SQL/MED options govern the transactional characteristics of the DML:

<p>
<table border="1">
<tr>
<td>Name</td>
<td>Scope</td>
<td>Description</td>
</tr>
<tr>
<td>DISTRIBUTED_TRANSACTIONS</td> 
<td>server</td> 
<td>
A setting of 0 (the default) means that when a non-autocommit Farrago 
transaction accessing this server spans multiple DML statements, all of 
those statements must target the same server.  
A setting of 1 requests that non-autocommit Farrago transactions 
which access this  server should be implemented as distributed transactions 
(this requires all foreign servers involved to support the 
javax.sql.XAConnection interface).
</td>
</tr>
<tr>
<td>READ_ONLY</td> 
<td>server</td> 
<td>0 to request DML support.  1 for read-only connection (the default).
</td>
</tr>
<tr>
<td>ISOLATION_LEVEL</td> 
<td>server</td> 
<td>Isolation level to use for all access to this server.  If unspecified,
default is DBMS-dependent.  This setting is ignored for distributed transactions
(for which the isolation level is based on the Farrago session).
</td>
</tr>
<tr>
<td>TRANSACTION_ROW_LIMIT</td> 
<td>server or table (table overrides server)</td> 
<td>
Number of rows to modify before committing transaction and starting a
new one.  Default is 0 (only commit once all rows have been
processed).  This option is ignored when autocommit is disabled in the
Farrago session, because then the Farrago-level transaction governs
the foreign transaction.  This option is also ignored when this
wrapper's AUTOCOMMIT option is set to 'TRUE' (the default), because
then every update is committed immediately.
</td>
</tr>
<tr>
<td>BATCH_ROW_LIMIT</td> 
<td>server or table (table overrides server)</td> 
<td>
Number of rows to send to foreign server per batch.  Default is 1.
</td>
</tr>
</table>

<p>

The following JDBC API calls are made in order to execute DML against
a foreign table:

<ul>
<li>Connection.prepareStatement
<li>PreparedStatement.setXXX (where XXX depends on datatype of column updated)
<li>PreparedStatement.executeUpdate
<li>PreparedStatement.addBatch (if BATCH_ROW_LIMIT specified)
<li>Statement.executeBatch (if BATCH_ROW_LIMIT specified)
<li>Connection.setReadOnly (if supported)
<li>Connection.setTransactionIsolation 
    (if <code>ISOLATION_LEVEL</code> specified)
<li>Connection.commit
    (if <code>AUTOCOMMIT</code> set to false)
<li>Connection.rollback
    (if <code>AUTOCOMMIT</code> set to false)
<li>DatabaseMetaData.getPrimaryKeys (for UPDATE/DELETE)
</ul>

</body>
</html>
