<html>

<head>
<title>Farrago Extension Metamodel (FEM)</title>
<link rel="stylesheet" type="text/css" href="../stylesheet.css" />

</head>

<body>

<h1>Farrago Extension Metamodel (FEM)</h1>

This document describes how Farrago v0.5 metadata is modeled in UML.  The
UML model defined by Farrago is referred to as FEM, for Farrago
Extension Metamodel, because

<ul>

<li>FEM extends the <a href="http://www.omg.org/cwm">Common Warehouse
Metamodel</a> (CWM)

<li>FEM is designed to be further extended by 
<a href="../extensibility.html">systems which extend Farrago</a>

</ul>

Table of Contents

<ol>
<li><a href="#Overview">Overview</a>
<li><a href="#Containers">Containers</a>
<li><a href="#Tables">Tables</a>
<li><a href="#Columns">Columns</a>
<li><a href="#Views">Views</a>
<li><a href="#Constraints">Constraints</a>
<li><a href="#Indexes">Indexes</a>
<li><a href="#Types">Types</a>
<li><a href="#Routines">Routines</a>
<li><a href="#MED">SQL/MED</a>
<li><a href="#Security">Security</a>
<li><a href="#Configuration">Configuration</a>
<li><a href="#Fennel">Fennel</a>
</ol>

<hr>

<a name="Overview">
<h2>Overview</h2>
</a>

The metamodel defined by CWM sprawls over a large number of data
management areas.  In some areas, it is very generic and not
up-to-date with the latest SQL standards.  FEM specializes a subset of
CWM (hiding irrelevant submodels) with specifics from SQL and Farrago.
The CWM standard recommends that specialization be implemented via the
tag mechanism (to further the goal of interoperability), but tags are
inappropriate for the deep specialization required by Farrago, so we
use inheritance instead.  Where interoperability is desired, we plan
to provide a "slicing" mechanism which can take a set of FEM objects,
strip out all FEM-specifics, and produce a valid CWM XMI export.
Likewise, a CWM import mechanism may be provided which fills in
defaults for FEM-specifics.

<p>

In this document, we walk through the submodel areas covered by FEM,
illustrating them via static structure UML class and object diagrams.
Attributes are not always shown unless they are relevant to the
discussion.

<hr>

<a name="Containers">
<h2>Containers</h2>
</a>

In SQL, first-class objects are defined in a three-level containment
hierarchy: catalogs contain schemas, and schemas contain objects such
as tables, views, and procedures.  This containment is modeled in FEM
using the <code>Namespace/Package</code> constructs inherited from CWM:

<p>

<img src="CatalogAndSchema.png">

<p>

The <code>ElementOwnership</code> association is used to model both
catalog/schema and schema/object containment.  For example, suppose
the following DDL is executed:

<pre><code>
create schema blogs;
set schema 'blogs';
create table bloggers(
    id int not null primary key,
    name varchar(128) not null,
    handle varchar(128) not null unique,
    email_addr varchar(128) not null);
</code></pre>

Then (ignoring columns for the moment) the following object instances
would be created (or referenced in the case of the
<code>LOCALDB</code> catalog, which already exists) and linked:

<p>

<img src="CatalogAndSchemaInstance.png">

<p>

Note that any <code>ModelElement</code> can be contained in a schema,
meaning extension models can define their own first-class objects
beyond the standard ones by inheriting from <code>ModelElement</code>.

<hr>

<a name="Tables">
<h2>Tables</h2>
</a>

CWM refers to any table-like object as a <code>NamedColumnSet</code>.
The association between a <code>NamedColumnSet</code> and the
<code>Column</code> objects which define its structure is modeled on
the more abstract notion of a class and its attributes:

<p>

<img src="ColumnSet.png">

<p>

In particular, FEM defines tables and views as descendants of
<code>NamedColumnSet</code>, and differentiates between columns of
tables and views:

<p>

<img src="LocalTableAndView.png">

<p>

Here is a corresponding object diagram for the previous example:

<p> 

<img src="LocalTableInstance.png">

<p>

Note that the generic <code>ElementOwnership</code> association is
<em>not</em> used to model the containment of columns by a table;
instead, the more specific <code>ClassifierFeature</code> association
is used.  However, since <code>Classifier</code> subclasses
<code>Namespace</code>, the <code>ElementOwnership</code> association
may be used for a table's containment of non-column objects such as
constraints.

<hr>

<a name="Columns">
<h2>Columns</h2>
</a>

The information associated with a single column is modeled via attributes
and an association to a datatype:

<p>

<img src="Column.png"/>

<p>

Details of allowed datatypes are covered in a <a href="#Types">later
section</a>.  The <code>initialValue</code> attribute is used to store
any <code>DEFAULT</code> value (the Expression class is covered in the
next section on views).

<hr>

<a name="Views">
<h2>Views</h2>
</a>

SQL views have a body (an underlying query), result columns, and
dependencies on objects referenced by their body (e.g. tables, other
views, and functions).  We have already seen how view columns are
modeled.  Here is a class diagram for the view body and dependencies:

<p>

<img src="View.png">

<p>

A single instance of class <code>Dependency</code> is created per view
to hold all dependencies, and only direct dependencies are recorded
(rather than the transitive closure).  Consider this addition to 
our running DDL example:

<pre><code>
create table topics(
    id int not null primary key,
    blogger_id int not null references bloggers(id),
    name varchar(128) not null,
    creation_time timestamp not null);

create view blogger_topics as
select bloggers.name as blogger_name,topics.name as topic_name
from bloggers,topics
where bloggers.id=topics.blogger_id

create view breakfast_topics as
select *
from blogger_topics
where upper(topic_name) like '%BREAKFAST%';
</code></pre>

And the corresponding object diagram (ignoring columns):

<p>

<img src="ViewInstance.png">

<p>

Besides views, other kinds of dependencies are recorded by Farrago,
but the rest are not covered by this document.

<hr>

<a name="Constraints">
<h2>Constraints</h2>
</a>

Farrago currently supports primary keys and unique keys as
constraints.  (Foreign keys, check constraints other than NOT NULL,
and assertions are not yet supported.)  In CWM, these constraints are
modeled as objects contained by a <code>Table</code> and with direct
associations to the constrained columns (as subclasses of
<code>StructuralFeature</code>):

<p>

<img src="CwmConstraints.png">

<p>

Note the many-to-many association.  This is difficult to query via
SQL, and does not provide the constraint column ordinals needed for
metadata views.  Hence, in FEM, we add a redundant one-to-many
association and intersection class, and another level of
constraint hierarchy:

<p>

<img src="FemConstraints.png">

<p>

Here's an object diagram for the constraints on the <code>BLOGGERS</code>
table:

<p>

<img src="ConstraintInstance.png">

<hr>

<a name="Indexes">
<h2>Indexes</h2>
</a>

The object relationships for indexes are quite similar to constraints
(but without the redundancy, and with an explicit association to the
indexed table):

<p>

<img src="Index.png">

<p>

Unlike constraints, indexes are contained directly by schemas, but the
containing schema must be the same as the schema of the indexed table.
Given the following DDL:

<pre><code>
create index blogger_id_name_idx
on bloggers(id,name);
</code></pre>

the following objects would be created and linked:

<p>

<img src="IndexInstance.png">

<hr>

<a name="Types">
<h2>Types</h2>
</a>

The allowable datatypes of elements such as columns and routine
parameters is modeled as a hierarchy rooted at class
<code>SQLDataType</code>:

<p>

<img src="Types.png">

<p>

Instances of <code>SQLSimpleType</code> represent builtin types such
as <code>VARCHAR</code> and <code>INTEGER</code> and are populated as
singletons when the repository is initialized.  Farrago also supports:

<ul>

<li><em>collection type constructors</em> such as
<code>MULTISET</code>; <code>SQLMultisetType</code> and
<code>SQLArrayType</code> are parameterized by a component type, and
so are instantiated anonymously as part of the definition of a typed
element (for example, if columns A and B both declare their type to be
<code>INTEGER MULTISET</code>, two anonymous instances of this type
will be constructed)

<li><em>anonymous structured types</em>; <code>SQLRowType</code> is
instantiated with the ROW type constructor as part of the definition
of a typed element

<li><em>named structured object types</em>; <code>SQLObjectType</code>
is instantiated with the <code>CREATE TYPE</code> statement and can
subsequently be referenced by many typed elements

</ul>

The attributes of structured types (whether anonymous or named)
are instances of <code>SQLTypeAttribute</code>.  For collection types,
a single type attribute with name <code>COMPONENT</code> is created to
represent the component type.  Named user-defined types can also have
associated instances of <code>UserDefinedOrdering</code>.

<p>

Finally, the <code>CREATE TYPE</code> statement also supports creation
of <em>distinct types</em>, which are strongly-typed user-defined
aliases for simple types:

<p>

<img src="DistinctType.png">

<p>

For this example DDL:

<pre><code>
create type url as (
    protocol varchar(10),
    host varchar(128),
    path varchar(1024)
) final;

create type ip_addr as bigint final;

create table access_log(
    id int not null primary key,
    resource url not null,
    client_addr ip_addr not null,
    post_data tinyint multiset
);
</code></pre>

the following objects are created (or referenced in the case of
builtins) and linked:

<p>

<img src="TypeInstance.png">

<hr>

<a name="Routines">
<h2>Routines</h2>
</a>

User-defined routines include functions, procedures, and methods.
They are first-class objects like tables and views, and are contained
directly by schemas.  Relationships between routines and their typed
parameters are diagrammed here:

<p>

<img src="Routine.png">

<p>

Note that <code>Routine</code> subclasses <code>ColumnSet</code>.
This inheritance is not currently used, but will be in the future once
procedures which produce result sets are supported.  TBD: methods,
UDX's, schema paths, and example object diagrams; also update class
diagram for DYNAMIC_FUNCTION attribute described in <a
href="">../design/UserDefinedTypesAndRoutines.html</a>.

<hr>

<a name="MED">
<h2>SQL/MED</h2>
</a>

<p>

<img src="Med.png">

<p>

TBD:  explanation and example object diagrams.

<hr>

<a name="Security">
<h2>Security</h2>
</a>

<p>

<img src="Security.png">

<p>

TBD:  explanation and example object diagrams.

<hr>

<a name="Configuration">
<h2>Configuration</h2>
</a>

TBD:  class diagram, explanation and example object diagrams.

<hr>

<a name="Fennel">
<h2>Fennel</h2>
</a>

TBD: link to Fennel submodel doc.

<hr>

</body>

</html>
