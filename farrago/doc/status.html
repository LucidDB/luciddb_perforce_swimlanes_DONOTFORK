<html>

<head>
<title>Farrago Status Page</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" />

</head>

<body>

<h1>What's Working Already?</h1>

Here's a laundry list of SQL features which are already working in
Farrago.  Restrictions are noted inline as well as in subsequent
sections.  If a sub-feature isn't mentioned (e.g. CHECK clause in
CREATE TABLE), it isn't available yet.  Everything is supposed to work
according to the SQL standard, so if something doesn't, that's either
a bug or an incomplete feature.  Which standard?  Normal procedure is
to consult the SQL-2003 standard and cross-check it with SQL-92
and SQL-99 to see if there are any incompatibilities.

<h2>DDL</h2>

<ul>

<li>All identifiers may be up to 128 characters.  Identifiers may be
quoted (with case-sensitivity) or unquoted (with uppercasing
before both storage and lookup).  The compound identifier
"catalog_name"."schema_name"."object_name" fully qualifies a schema
element.

<li>SET CATALOG: the system currently starts out with several catalogs
predefined (SYS_BOOT, SYS_CWM, SYS_FEM, and LOCALDB).  Additional
catalogs can be created implicitly via the SQL/MED CREATE SERVER
command.  The SYS_BOOT catalog contains internal tables for metadata
storage, along with things like views for implementing JDBC metadata.
The SYS_CWM catalog is a virtual catalog exposing the contents of the
CWM-based repository.  SYS_FEM is similar, but for Farrago extensions
to CWM.  The LOCALDB catalog stores user metadata about both local and
foreign tables.  The default catalog starts out as LOCALDB; SET
CATALOG can be used to change this per-session.

<li>SET SCHEMA: user schemas are created in the LOCALDB catalog.
SET SCHEMA can be used to change the default schema within the
current catalog.  The SYS_CWM catalog defines one schema per CWM package
(e.g. "Core", "Relational", or "KeysIndexes"); the tables in the CWM
schemas correspond to classes (e.g. schema SYS_CWM."Core" contains
"ModelElement" and "Feature"; schema SYS_CWM."Relational" contains "Table"
and "View").  Likewise for SYS_FEM.

<li>CREATE SCHEMA: a schema can be created by itself, or together with
all of its contents in the same statement.  The AUTHORIZATION clause
is currently parsed but ignored since users and roles are not yet
implemented.

<li>CREATE TABLE: every table must have a primary key.  Supported
column datatypes are BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT,
REAL, DOUBLE (alias DOUBLE PRECISION), VARCHAR (alias CHARACTER
VARYING), VARBINARY, CHAR (alias CHARACTER), BINARY, DATE, TIME, and
TIMESTAMP.  Time precision is currently limited to seconds, but will
eventually be enhanced to microseconds (which should be the default
for TIMESTAMP according to the SQL standard).  Timezones are not yet
supported.  Support for <a
href="design/CollectionTypes.html">multisets</a>, time intervals, and
<a href="design/UserDefinedTypesAndRoutines.html">user-defined
types</a> is currently under development.

<li>NOT NULL:  can be specified explicitly on any column; is also implied
for columns which participate in the table's primary key or clustered index.

<li>DEFAULT: can be specified for any column; otherwise default value
is NULL.  Currently, default values can only be literals of the appropriate
datatype (not arbitrary expressions).

<li>PRIMARY KEY/UNIQUE:  constraints can be specified at either the
column level or the table level.  Constraints can be named, and are
enforced via implicitly created indexes.

<li>CREATE [UNIQUE] CLUSTERED INDEX: if specified, this must be at the
end of the CREATE TABLE statement, not in a separate statement.  Example:  
<pre><code>
create table t(i int not null primary key,j int not null,k int)
create clustered index t_x on t(j);
create index t_y on t(k);
<code></pre>
If not specified, the primary key is used implicitly for clustering.
<a href="design/TableIndexing.html">
Every table has exactly one clustered index</a>.

<li>CREATE [UNIQUE] INDEX: unclustered indexes can be created either
at the end of the table definition or in separate statements.  Indexes
are considered to be schema elements but are always created in the same
schema as their containing table.

<li>CREATE GLOBAL TEMPORARY TABLE: supports ON COMMIT
{PRESERVE|DELETE} [ROWS] option.  Note that the "GLOBAL TEMPORARY"
name in the standard is confusing: this is really an
instantiate-on-reference session-local temporary table with a
permanent shared metadata definition in the catalog.  Any indexes on a
temporary table must be specified together with the CREATE TABLE
statement; indexes may not be subsequently added or dropped (if you
need that, drop and recreate the table definition).  Beyond that,
temporary tables support the same features as permanent tables
(constraints, defaults, etc.).

<li>CREATE VIEW:  all views are currently read-only.

<li>DROP SCHEMA/TABLE/VIEW: both RESTRICT and CASCADE are supported.

<li>DROP INDEX:  only unclustered indexes may be dropped.

<li>TRUNCATE TABLE "tbl":  delete all rows from tbl without logging them
individually.

<li>ALTER SYSTEM SET "parameterName" = value; change a system
parameter (TODO: documentation for parameters).

<li>CHECKPOINT:  force an immediate checkpoint.

<li>COMMIT:  commit current transaction.

<li>ROLLBACK:  rollback current transaction.

<li>SAVEPOINT "x":  create a savepoint with name x.

<li>ROLLBACK TO SAVEPOINT "x": partially rollback current transaction
to savepoint x.

<li><a href="design/sqlmed.html">SQL/MED</a> support.  CREATE/DROP
FOREIGN DATA WRAPPER, CREATE/DROP SERVER, and CREATE/DROP FOREIGN
TABLE are working.  Implementations for JDBC and MDR are
available (the MDR implementation is already being used for exposing
the catalog contents via SQL).

<li><a href="design/UserDefinedTypesAndRoutines.html">CREATE FUNCTION</a>:  
supports functions with SQL-defined bodies consisting 
of a single RETURN statement).  Support for external Java functions is
currently under development.
</li>

</ul>

<h2>Queries</h2>

<ul>

<li>SELECT [DISTINCT] ... FROM ... WHERE ... ORDER BY

<li>UNION [ALL]

<li>FROM clause may contain tables, views, multi-row VALUES,
LEFT/RIGHT/INNER/CROSS JOIN, old-style comma list, nested queries,
and explicit TABLE references.

<li>EXPLAIN PLAN [{WITH|WITHOUT} IMPLEMENTATION] FOR
<em>query-or-DML-statement</em>; shows optimizer plan.  WITHOUT
IMPLEMENTATION yields unoptimized abstract relational plan.  Default
is WITH IMPLEMENTATION, which yields optimized plan with all physical
operators.

<li>Row expression support is currently very limited (basic
equality/inequality comparisons, AND, +, a few others).  
SESSION_USER, CURRENT_USER,  and SYSTEM_USER are supported
(but authentication and privileges are not yet implemented).

</ul>

<h2>DML</h2>

<ul>

<li>INSERT

<li>UPDATE

<li>DELETE

</ul>

<h2>JDBC API</h2>

<ul>

<li>prepared statements with dynamic parameters 
(e.g. <code>select * from emps where name=?</code>)

<li>some DatabaseMetaData:  getCatalogs, getSchemas, getTables, getTableTypes
(no pattern search support yet)

<li>savepoint API

<li>autocommit or manual commit (either via API or via SQL)

<li>implicit query plan cache

</ul>

<h2>Optimizer</h2>

<ul>

<li>cartesian product join (for inner joins only)

<li>index join (for LEFT, RIGHT, or INNER join;
single-column equijoin only)

<li>single-column index search (equals predicate only); only one index
at a time

<li>hybrid Java/Fennel plans

</ul>

<h2>Executor</h2>

<ul>

<li>Row expressions are implemented via a mix of Java code generation
and Fennel calculator programs.  In cases where both implementations
are available for the same row expression, the optimizer decides
(currently always in favor of Fennel; eventually this should be
properly costed).  System parameter "calcVirtualMachine" governs this
behavior (default setting CALCVM_AUTO uses mixed mode; CALCVM_FENNEL
forces Fennel only; CALCVM_JAVA forces Java only, used implicitly when
Fennel support is not available).

<li>Generated Java code is compiled by the Janino compiler (and then
possibly to native code JIT).  Alternate compilers such as Sun's can
be selected via the <code>javaCompilerClassName</code> system
parameter.

<li>All other execution objects are implemented by Fennel, except for
union (concatenation of Java iterators) and foreign table access (such
as MDR or JDBC).

<li>Each DML statement runs in its own implicit subtransaction as required
by the standard.

</ul>

<h2>Runtime Modes</h2>

<ul>

<li>Embedded engine:  everything runs in a single process; JDBC calls
go into the engine directly.

<li>Client/server: implemented using <a
href="http://rmijdbc.objectweb.org">RmiJdbc</a>.  By default, the
server listens for RMI connections on port 5433, and uses multiple
dynamically assigned ports for individual RMI objects.  This can be
controlled via configuration parameters;
<code>serverRmiRegistryPort</code> controls the connection port, and
<code>serverSingleListenerPort</code> forces all RMI objects to
multiplex over a single statically assigned port (default value of
<code>-1</code> means use dynamically assigned ports for this
instead).

</ul>

<h1>What's Broken?</h1>

Besides the absence of great gobs of standard stuff like aggregates,
fixed-point numerics, referential integrity, etc., it's worth
mentioning some serious limitations in the features listed above:

<ul>

<li>The validator is still under development, so when you make an invalid
request, you'll very likely get ugly internal errors, data corruption,
printer spontaneous combustion, etc.

<li>ORDER BY descending is not supported (nor is the non-standard
ORDER BY a+b).

<li>Subqueries and IN predicates are parsed and maybe validated but
don't actually work yet.  Same for INTERSECT and EXCEPT.

<li>Type inference is missing for some dynamic parameter contexts.

<li>Creating a new index on a table with existing rows will not
actually index those rows.

<li>You can specify a CHARACTER SET name on CHAR/VARCHAR columns from
only the single-byte character sets known to Java.

<li>BTree height increase is not yet implemented, so inserting lots of
data will lead to a long linear chain of pages.  Bulk load for
multi-level trees is implemented internally, but not yet exposed via SQL.

<li>There's no concurrency control at all, and a few known FIXME's for
threading problems.  So don't try more than a single session yet.

<li>Updates to unique keys are not ordered correctly, so spurious
uniqueness violations result for a statement like update t set pk=pk+1
(where pk is a primary key).  This probably won't be fixed until
triggers are implemented.

<li>INSERT/UPDATE do not support the explicit DEFAULT keyword.

<li>The amount of performance tuning which has been done so far is
exactly zero.

<li>The SET SCHEMA command cannot be used to set a schema in a
virtual catalog based on a SQL/MED server (including the predefined
SYS_CWM and SYS_FEM catalogs).

</ul>

<a href="mailto:perfecthash@users.sf.net">Feedback</a> on anything inaccurate
or missing from these lists is always apppreciated.

</body>

</html>
