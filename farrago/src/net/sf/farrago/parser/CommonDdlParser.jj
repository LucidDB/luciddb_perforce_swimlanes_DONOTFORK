/*****************************************
 * Convenience Functions                 *
 *****************************************/

 JAVACODE void SqlDataTypeSpecToCwmColumnType(SqlDataTypeSpec dataType,
                                             CwmColumn column)
{
    CwmSqldataType type =
        farragoParser.getStmtValidator().findSqldataType(
            dataType.getTypeName().getSimple());
    column.setType(type);
    if (dataType.getPrecision() > 0) {
        column.setPrecision(new Integer(dataType.getPrecision()));
    }
    if (dataType.getScale() > 0) {
        column.setScale(new Integer(dataType.getScale()));
    }
    if (dataType.getCharSetName() != null) {
        column.setCharacterSetName(dataType.getCharSetName());
    }
}

/*****************************************
 * Syntactical Descriptions              *
 *****************************************/


SqlIdentifier CompoundIdentifier2() :
{
    List list = new ArrayList();
    String p;
}
{
    (p = Identifier() {list.add(p);})
    (<DOT> p = Identifier() {list.add(p);})?
    {return new SqlIdentifier(ParserUtil.toStringArray(list),null);}
}

String QuotedString() :
{
    Token t;
}
{
    t = <QUOTED_STRING>
    {
      return ParserUtil.parseString(t.image);
    }
}

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 *
 * @return top-level CWM object affected for DDL statement, or top-level SqlNode
 * for DML or query statement
 */
Object FarragoSqlStmtEof() :
{
    Object obj;
}
{
    (
        obj = DdlStmtEof()
    |
        obj = SqlStmtEof()
    )
        { return obj; }
}

DdlStmt DdlStmtEof() :
{
    CwmModelElement modelElement;
    DdlStmt ddlStmt;
    SqlNode expr;
}
{
    (
        ( <CREATE>
          ( 
            modelElement = SchemaDefinition()
            |
            LOOKAHEAD(2)
            modelElement = SchemaObjectDefinition()
            |
            modelElement = IndexDefinition(null)
            |
            modelElement = DataWrapperDefinition()
            |
            modelElement = DataServerDefinition()
            |
            modelElement = ExtensionModelDefinition()
           )
        {
            ddlStmt = new DdlCreateStmt(modelElement);
        }
        )
        |
        ( <DROP>
        {
            // assume RESTRICT; CascadeOption() may override
            dropRestrict = true;
        }
          (
              modelElement = SchemaDrop()
              |
              LOOKAHEAD(2)
              modelElement = NamedColumnSetDrop()
              |
              modelElement = IndexDrop()
              |
              modelElement = ViewDrop()
              |
              modelElement = RoutineDrop()
              |
              modelElement = JarDrop()
              |
              LOOKAHEAD(2)
              modelElement = DataWrapperDrop()
              |
              modelElement = DataServerDrop()
              |
              modelElement = ExtensionModelDrop()
          )
        {
            ddlStmt = new DdlDropStmt(modelElement,dropRestrict);
        }
        )
        |
        ( <TRUNCATE>
          (
              <TABLE> modelElement = TableIdentifier()
          )
        {
            ddlStmt = new DdlTruncateStmt(modelElement);
        }
        )
        |
        ( <SET>
            (
                <CATALOG> expr = Expression(EXPR_ACCEPT_NONQUERY)
            {
                ddlStmt = new DdlSetCatalogStmt(expr);
            }
                | <SCHEMA> expr = Expression(EXPR_ACCEPT_NONQUERY)
            {
                ddlStmt = new DdlSetSchemaStmt(expr);
            }
                | <PATH> expr = Expression(EXPR_ACCEPT_NONQUERY)
            {
                ddlStmt = new DdlSetPathStmt(expr);
            }
            )
        )
        |
        ( <ALTER> 
          (
              <SYSTEM> <SET> ddlStmt = SystemParamAssignment()
              |
              ddlStmt = ExtensionModelAlter()
          )
        {
        }
        )
        |
        ( <CHECKPOINT> { ddlStmt = new DdlCheckpointStmt(); } )
        |
        ( <COMMIT> { ddlStmt = new DdlCommitStmt(); } )
        |
        ( <ROLLBACK> ddlStmt = Rollback())
        |
        ( <SAVEPOINT> ddlStmt = Savepoint())
        |
        ( <RELEASE> <SAVEPOINT> ddlStmt = ReleaseSavepoint())
    )
        <EOF>
        {
            return ddlStmt;
        }
}

// TODO:  support non-topological order of object definition, e.g. a
// referencing table before a referenced table

FemLocalSchema SchemaDefinition() :
{
    FemLocalSchema schema;
    SqlIdentifier schemaName,userName;
    boolean pathDefined = false;
}
{
    <SCHEMA> schemaName = CompoundIdentifier2()
        {
            schema = getRepos().newFemLocalSchema();
            if (schemaName.names.length == 2) {
                CwmCatalog catalog =
                    farragoParser.getStmtValidator().findCatalog(
                        schemaName.names[0]);
                schema.setNamespace(catalog);
                schema.setName(schemaName.names[1]);
            } else {
                schema.setNamespace(
                    farragoParser.getStmtValidator().getDefaultCatalog());
                schema.setName(schemaName.getSimple());
            }
        }
    [ <AUTHORIZATION> userName = SimpleIdentifier() ]
        {
            // TODO:  store userName
        }
    [ SchemaPath(schema) { pathDefined = true; } ]
        {
            if (!pathDefined) {
                // implicit default path is just this schema itself
                FemSqlpathElement element = getRepos().newFemSqlpathElement();
                element.setSearchedSchemaCatalogName(
                    schema.getNamespace().getName());
                element.setSearchedSchemaName(
                    schema.getName());
                schema.getPathElement().add(element);
            }

            // set up context which will prevail for any object
            // definitions included in this schema definition
            farragoParser.getDdlValidator().setCreatedSchemaContext(schema);
        }
    (
        <CREATE>
        SchemaObjectDefinition()
    )*
    {
        // TODO: character set, all that jazz
        return schema;
    }
}

void SchemaPath(FemLocalSchema schema) :
{
    List searchPath;
}
{
    searchPath = SearchPath()
        {
            Iterator iter = searchPath.iterator();
            while (iter.hasNext()) {
                CwmSchema searchedSchema = (CwmSchema) iter.next();
                if (searchedSchema.getNamespace() != schema.getNamespace()) {
                    throw FarragoResource.instance().newValidatorPathBadCatalog(
                        getRepos().getLocalizedObjectName(
                            searchedSchema.getNamespace()),
                        getRepos().getLocalizedObjectName(
                            schema.getNamespace()));
                }
                FemSqlpathElement element = getRepos().newFemSqlpathElement();
                element.setSearchedSchemaCatalogName(
                    searchedSchema.getNamespace().getName());
                element.setSearchedSchemaName(
                    searchedSchema.getName());
                schema.getPathElement().add(element);
            }
        }
}

List SearchPath() :
{
    List list = new ArrayList();
}
{
    <PATH> SearchPathElement(list) (<COMMA> SearchPathElement(list))*
        {
            return list;
        }
}

void SearchPathElement(List list) :
{
    SqlIdentifier id;
}
{
    id = CompoundIdentifier2()
        {
            FemLocalSchema searchedSchema =
                farragoParser.getStmtValidator().findSchema(id);
            list.add(searchedSchema);
        }
}

// TODO:  support non-topological order of table element definition, e.g. a
// referencing constraint definition before a referenced column definition

CwmTable TableDefinition() :
{
    FemStoredTable table;
    FemDataServer server = null;
}
{
    (
        table = UnscopedTableDefinition()
        |
        table = ScopedTableDefinition()
    )
        {
        }
    [ server = DataServerReference() ]
        {
        }
    OptionalStorageOptions(table)
        {
        }
    (LOOKAHEAD(2) <CREATE> IndexDefinition(table))*
        {
        }
    {
        if (server == null) {
            server =
                farragoParser.getStmtValidator().getDefaultLocalDataServer();
        }
        table.setServer(server);
        return table;
    }
}

FemLocalTable UnscopedTableDefinition() :
{
    FemLocalTable table;
    SqlIdentifier qualifiedTableName;
}
{
    <TABLE>
        {
            table = getRepos().newFemLocalTable();
        }
    qualifiedTableName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                table,qualifiedTableName);
        }
    <LPAREN> TableElementList(table) <RPAREN>
        {
        }
    {
        return table;
    }
}

FemLocalTable ScopedTableDefinition() :
{
    FemLocalTable table;
    String scope;
    String commitOption;
}
{
    <GLOBAL> <TEMPORARY>
    table = UnscopedTableDefinition()
        {
            table.setTemporary(true);
            
            // TODO:  support LOCAL (as "MODULE")
            scope = "SESSION";
            commitOption = "DELETE";
        }
    [ <ON> <COMMIT>
      (
          <PRESERVE> 
      {
          commitOption = "PRESERVE";
      }
          |
          <DELETE>
      {
          commitOption = "DELETE";
      }
      )
      <ROWS> ]
        {
        }
    {
        // TODO:  define a tag for commitOption, since CWM doesn't have a place
        // for it?
        table.setTemporaryScope(scope + ":COMMIT=" + commitOption);
        return table;
    }
}

CwmView ViewDefinition() :
{
    CwmView view;
    SqlIdentifier qualifiedViewName;
    SqlNode query;
    List columnNameList;
}
{
    <VIEW>
        {
           view = getRepos().newCwmView();
        }
    qualifiedViewName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                view,qualifiedViewName);
        }
    [<LPAREN> columnNameList = SimpleIdentifierCommaList() 
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName = 
                    ((SqlIdentifier) columnNameIter.next()).getSimple();
                CwmColumn column = getRepos().newFemViewColumn();
                column.setName(columnName);
                view.getFeature().add(column);
            }
        }
     <RPAREN>]

    <AS> query = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY)
    {
        // NOTE:  we accept ORDER BY on the view definition, even though
        // that's not standard SQL, and leave it up to the validator to
        // decide what to do with it
        farragoParser.getDdlValidator().setViewText(view, query);
    }
    {
       return view;
    }
}


FemLocalIndex IndexDefinition(CwmTable table) :
{
    FemLocalIndex index;
    SqlIdentifier indexName;
    CwmTable specifiedTable;
    List columnNameList;
    boolean unique = false;
    boolean clustered = false;
}
{
    [ <UNIQUE> { unique = true; } ]
        {
        }
    [ <CLUSTERED> { clustered = true; } ]
        {
        }
    <INDEX>
        {
            index = getRepos().newFemLocalIndex();
        }
    indexName = SimpleIdentifier()
        {
            index.setName(indexName.names[0]);
        }
    <ON> specifiedTable = TableIdentifier()
        {
            if (table == null) {
                table = specifiedTable;
            } else {
                // TODO:  move rule down into validator
                if (table != specifiedTable) {
                    throw farragoParser.getDdlValidator().newPositionalError(
                        index,
                        FarragoResource.instance().newValidatorIndexBadTable());
                }
            }
            getRepos().getKeysIndexesPackage().getIndexSpansClass().add(
                table,index);
            // REVIEW:  why is this necessary?  shouldn't association above be
            // sufficient?
            index.setSpannedClass(table);
            if (clustered) {
                index.setClustered(true);
            }
            index.setUnique(unique);
        }
    <LPAREN> columnNameList = SimpleIdentifierCommaList() <RPAREN>
        {
            int iOrdinal = 0;
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).names[0];
                CwmColumn column = farragoParser.getStmtValidator().findColumn(
                    table,columnName);
                FemLocalIndexColumn indexColumn =
                    getRepos().newFemLocalIndexColumn();
                indexColumn.setName(columnName);
                indexColumn.setAscending(Boolean.TRUE);
                indexColumn.setFeature(column);
                indexColumn.setIndex(index);
                indexColumn.setOrdinal(iOrdinal++);
            }
        }
    {
        return index;
    }
}

CwmTable TableIdentifier() :
{
    SqlIdentifier qualifiedTableName;
    CwmTable table;
}
{
    qualifiedTableName = CompoundIdentifier2()
        {
            table = (CwmTable)
            farragoParser.getStmtValidator().findSchemaObject(
                qualifiedTableName,
                getRepos().getRelationalPackage().getCwmTable());
        }
    {
        return table;
    }
}

CwmView ViewReference() :
{
    SqlIdentifier qualifiedViewName;
    CwmView view;
}
{
    <VIEW> qualifiedViewName = CompoundIdentifier2()
        {
            view = (CwmView) farragoParser.getStmtValidator().findSchemaObject(
                qualifiedViewName,
                getRepos().getRelationalPackage().getCwmView());
        }
    {
        return view;
    }
}

FemRoutine RoutineReference() :
{
    SqlIdentifier qualifiedRoutineName;
    FemRoutine routine;
    boolean specific = false;
    ProcedureType routineType;
}
{
    [ <SPECIFIC> { specific = true; } ]
    (
        <ROUTINE>
    {
        routineType = null;
    }
        | <FUNCTION>
    {
        routineType = ProcedureTypeEnum.FUNCTION;
    }
        | <PROCEDURE>
    {
        routineType = ProcedureTypeEnum.PROCEDURE;
    }
    )
        qualifiedRoutineName = CompoundIdentifier2()
        {
            // TODO jvs 24-Dec-2004: implement lookup by invocation name
            // and signature when !specific
            routine = (FemRoutine)
            farragoParser.getStmtValidator().findSchemaObject(
                qualifiedRoutineName,
                getRepos().getSql2003Package().getFemRoutine());

            // REVIEW jvs 29-Dec-2004:  localization in message below
            // is iffy

            // if they specifically asked for a FUNCTION or PROCEDURE,
            // and the object found does not match, pretend we
            // found nothing
            if ((routineType != null) && (routineType != routine.getType())) {
                throw farragoParser.newPositionalError(
                    FarragoResource.instance().newValidatorUnknownObject(
                        routineType.toString() + " " +
                        getRepos().getLocalizedObjectName(
                            routine.getNamespace().getName(),
                            routine.getName(),
                            null)));
            }
        }
    {
        return routine;
    }
}

void TableElementList(CwmTable table) :
{
}
{
    TableElement(table)
    (
        <COMMA>
        TableElement(table)
    )*
}



CwmModelElement TableElement(CwmTable table) :
{
    CwmModelElement modelElement;
}
{
    (
        modelElement = ColumnDefinition(table)
        |
        modelElement = TableConstraint(table)
    )
        {
            return modelElement;
        }
}

void BasicColumnDefinition(CwmNamedColumnSet table,CwmColumn column) :
{
    SqlIdentifier columnName;
}
{
    columnName = SimpleIdentifier()
        {
            table.getFeature().add(column);
            column.setName(columnName.names[0]);
        }
    TypedElement(column)
}

void TypedElement(CwmColumn column) :
{
    SqlDataTypeSpec dataType;
}
{
    dataType = DataType()
    [
        <MULTISET>
        {
            FemSqlmultisetType colType = getRepos().newFemSqlmultisetType();
            colType.setName("MULTISET");
            FemSqltypeAttribute componentType =
                                            getRepos().newFemSqltypeAttribute();
            componentType.setName("COMPONENT");
            colType.setComponentType(componentType);
            SqlDataTypeSpecToCwmColumnType(dataType, componentType);
            column.setType(colType);
            return;
        }
    ]
    {
        SqlDataTypeSpecToCwmColumnType(dataType, column);
    }
}

CwmColumn ColumnDefinition(CwmTable table) :
{
    FemStoredColumn column;
    SqlNode defaultClause;
}
{
    {
        column = getRepos().newFemStoredColumn();
    }
    BasicColumnDefinition(table,column)
        {
        }
    [
        defaultClause = DefaultClause() 
        {
            CwmExpression defaultExpression =
            getRepos().newCwmExpression();
            defaultExpression.setBody(defaultClause.toSqlString(null));
            defaultExpression.setLanguage("SQL");
            column.setInitialValue(defaultExpression);
        }
    ]
        {
        }
    ( ColumnConstraint(table,column) )*
        {
        }
    OptionalStorageOptions(column)
        {
        }
    {
        return column;
    }
}

SqlNode DefaultClause() :
{
    SqlNode expression;
}
{
    <DEFAULT_KW> (
        // TODO:  allow USER, CURRENT_USER, CURRENT_ROLE, SESSION_USER,
        // SYSTEM_USER, CURRENT_PATH, <datatime value function>,
        // <implicitly typed value specification>
        expression = Literal()
    )
        {
            return expression;
        }
}

CwmModelElement TableConstraint(CwmTable table) :
{
    String constraintName = null;
    CwmUniqueConstraint constraint;
}
{
    [ <CONSTRAINT> constraintName = Identifier() ]
        {
        }
    constraint = TableUniqueConstraint(table)
        {
            if (constraintName != null) {
                constraint.setName(constraintName);
            } else {
                FarragoCatalogUtil.generateConstraintName(
                    getRepos(), constraint);
            }
            table.getOwnedElement().add(constraint);
        }
    {
        return constraint;
    }
}

CwmUniqueConstraint TableUniqueConstraint(CwmTable table) :
{
    CwmUniqueConstraint constraint;
    List columnNameList;
}
{
    constraint = UniqueConstraint()
        {
        }
    <LPAREN> columnNameList = SimpleIdentifierCommaList() <RPAREN>
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).names[0];
                CwmColumn column = farragoParser.getStmtValidator().findColumn(
                    table,columnName);
                constraint.getFeature().add(column);
                // TODO:  validate no duplicates
            }
        }
    // TODO:  deferrability, etc.
    {
        return constraint;
    }
}

CwmUniqueConstraint UniqueConstraint() :
{
    CwmUniqueConstraint constraint;
}
{
    (
        <UNIQUE>
    {
        constraint = getRepos().newCwmUniqueConstraint();
    }
        |
        <PRIMARY> <KEY>
    {
        constraint = getRepos().newCwmPrimaryKey();
    }
    )
        {
            constraint.setDeferrability(DeferrabilityTypeEnum.NOT_DEFERRABLE);
            return constraint;
        }
}



void ColumnConstraint(CwmNamedColumnSet table,CwmColumn column) :
{
    CwmUniqueConstraint constraint;
    String constraintName = null;
}
{
    [ <CONSTRAINT> constraintName = Identifier() ]
        {
        }
    (
        <NOT> <NULL>
    {
        column.setIsNullable(NullableTypeEnum.COLUMN_NO_NULLS);
    }
        | constraint = UniqueConstraint()
        {
            constraint.getFeature().add(column);
            table.getOwnedElement().add(constraint);
            if (constraintName != null) {
                constraint.setName(constraintName);
            } else {
                FarragoCatalogUtil.generateConstraintName(
                    getRepos(), constraint);
            }
        }
    )
        {
        }
}

CwmModelElement SchemaDrop() :
{
    SqlIdentifier schemaName;
    FemLocalSchema schema;
}
{
    schema = SchemaReference()
        {
        }
    CascadeOption()
        {
            return schema;
        }
}

CwmCatalog CatalogReference() :
{
    SqlIdentifier catalogName;
}
{
    <CATALOG> catalogName = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findCatalog(
                catalogName.getSimple());
        }
}

FemLocalSchema SchemaReference() :
{
    SqlIdentifier schemaName;
}
{
    <SCHEMA> schemaName = CompoundIdentifier2()
        {
            return farragoParser.getStmtValidator().findSchema(schemaName);
        }
}

CwmModelElement TableDrop() :
{
    CwmModelElement table;
}
{
    <TABLE> table = TableIdentifier()
        {
        }
    CascadeOption()
        {
            return table;
        }
}

CwmModelElement ViewDrop() :
{
    CwmModelElement view;
}
{
    view = ViewReference()
        {
        }
    CascadeOption()
        {
            return view;
        }
}

CwmModelElement RoutineDrop() :
{
    CwmModelElement routine;
}
{
    routine = RoutineReference()
        {
        }
    CascadeOption()
        {
            return routine;
        }
}

CwmModelElement JarDrop() :
{
    SqlIdentifier qualifiedJarName;
    SqlLiteral deploymentState;
}
{
    <JAR> qualifiedJarName = CompoundIdentifier2()
        {
        }
    <OPTIONS>
         <LPAREN> deploymentState = NumericLiteral(ParserPosition.ZERO) <RPAREN>
        {
        }
    CascadeOption()
        {
        }
    {
        FemJar jar = (FemJar) farragoParser.getStmtValidator().findSchemaObject(
            qualifiedJarName,
            getRepos().getSql2003Package().getFemJar());
        jar.setDeploymentState(deploymentState.intValue());
        return jar;
    }
}

CwmModelElement IndexDrop() :
{
    SqlIdentifier qualifiedIndexName;
}
{
    <INDEX> qualifiedIndexName = CompoundIdentifier2()
        {
            return farragoParser.getStmtValidator().findSchemaObject(
                qualifiedIndexName,
                getRepos().getMedPackage().getFemLocalIndex());
        }
}

void CascadeOption() :
{
}
{
    [
        (
            <RESTRICT>
        {
            dropRestrict = true;
        }
            | <CASCADE>
        {
            dropRestrict = false;
        }
        )
    ]
}

DdlStmt SystemParamAssignment() :
{
    SqlIdentifier paramName;
    SqlLiteral paramValue;
}
{
    paramName = SimpleIdentifier()
        {
        }
    <EQ>
        {
        }
    paramValue = SystemParamValue()
        {
        }
    {
        return new DdlSetSystemParamStmt(
            paramName.names[0],paramValue);
    }
}

SqlLiteral SystemParamValue() :
{
    SqlLiteral paramValue;
    ParserPosition pos = null;  
}
{
    (
        paramValue = StrictLiteral()
        {
        }
        | <MAX>
        {
            // TODO jvs 22-May-2004:  for MIN and MAX here, use metadata
            // to determine the correct min and max values
            pos = getPos();
            paramValue = SqlLiteral.createExactNumeric("-1", pos);
        }
        | <MIN>
        {
            pos = getPos();
            paramValue = SqlLiteral.createExactNumeric("0", pos);
        }
    )
        {
            return paramValue;
        }
}

DdlStmt Rollback() :
{
    SqlIdentifier savepointName = null;
}
{
    (<TO> <SAVEPOINT> savepointName = SimpleIdentifier() )?
        {
        }
    {
        if (savepointName != null) {
            return new DdlRollbackStmt(savepointName.names[0]);
        } else {
            return new DdlRollbackStmt(null);
        }
    }
}

DdlStmt Savepoint() :
{
    SqlIdentifier savepointName = null;
}
{
    savepointName = SimpleIdentifier()
        {
        }
    {
        return new DdlSavepointStmt(savepointName.names[0]);
    }
}

DdlStmt ReleaseSavepoint() :
{
    SqlIdentifier savepointName = null;
}
{
    savepointName = SimpleIdentifier()
        {
        }
    {
        return new DdlReleaseSavepointStmt(savepointName.names[0]);
    }
}

FemDataWrapper DataWrapperDefinition() :
{
    FemDataWrapper wrapper;
    SqlIdentifier wrapperName;
    String libraryFile;
    boolean isForeign;
}
{
    isForeign = ForeignOpt()
        {
        }
    <DATA> <WRAPPER> wrapperName = SimpleIdentifier()
        {
            wrapper = getRepos().newFemDataWrapper();
            wrapper.setName(wrapperName.getSimple());
            wrapper.setNamespace(
                getRepos().getCatalog(
                    FarragoRepos.SYSBOOT_CATALOG_NAME));
            wrapper.setForeign(isForeign);
        }
    <LIBRARY> libraryFile = QuotedString()
        {
            wrapper.setLibraryFile(libraryFile);
        }
    <LANGUAGE> <JAVA>
        {
            wrapper.setLanguage("JAVA");
        }
    OptionalStorageOptions(wrapper)
        {
        }
    {
        return wrapper;
    }
}

boolean ForeignOpt() :
{
}
{
    <LOCAL>
        {
            return false;
        }
    | <FOREIGN>
        {
            return true;
        }
}

FemDataWrapper DataWrapperReference() :
{
    SqlIdentifier name;
    boolean isForeign;
}
{
    isForeign = ForeignOpt()
        {
        }
    <DATA> <WRAPPER> name = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findDataWrapper(
                name,isForeign);
        }
}

FemDataServer DataServerDefinition() :
{
    FemDataServer server;
    FemDataWrapper wrapper;
    SqlIdentifier serverName;
    String serverType;
    String serverVersion;
}
{
    <SERVER> serverName = SimpleIdentifier()
        {
            server = getRepos().newFemDataServer();
            server.setName(serverName.getSimple());
            server.setNamespace(
                getRepos().getCatalog(
                    FarragoRepos.SYSBOOT_CATALOG_NAME));
        }
    [
        <TYPE> serverType = QuotedString() 
        {
            server.setType(serverType);
        }
    ]
    [
        <VERSION> serverVersion = QuotedString() 
        {
            server.setVersion(serverVersion);
        }
    ]
        {
        }
    wrapper = DataWrapperReference()
        {
            server.setWrapper(wrapper);
        }
    OptionalStorageOptions(server)
        {
        }
    {
        return server;
    }
}

FemRoutine FunctionDefinition() :
{
    FemRoutine function;
    SqlIdentifier qualifiedName;
    FemRoutineParameter returnParam;
}
{
    <FUNCTION> 
        {
            function = getRepos().newFemRoutine();
            function.setType(ProcedureTypeEnum.FUNCTION);
            returnParam = getRepos().newFemRoutineParameter();
            function.setCalledOnNullInput(true);
        }
    qualifiedName = CompoundIdentifier2()
        {
            // REVIEW jvs 27-Dec-2004:  SQL standard says that
            // specific name is implementation-defined when unspecified.
            // The behavior here is to use the invocation name, which
            // means if there's a conflict with an existing specific name,
            // the CREATE statement will fail.  This forces users to
            // provide specific names when overloads are defined.  An
            // alternative is to generate unique specific names automatically
            // in case of conflict.
            farragoParser.getDdlValidator().setSchemaObjectName(
                function,qualifiedName);
            function.setInvocationName(function.getName());
        }
    <LPAREN> [ RoutineParamList(function) ] <RPAREN>
        {
        }
    <RETURNS> TypedElement(returnParam)
        {
            returnParam.setName("RETURN");
            returnParam.setKind(ParameterDirectionKindEnum.PDK_RETURN);
            function.getParameter().add(returnParam);
        }
    RoutineCharacteristics(function)
        {
        }
    [ <STATIC> <DISPATCH> ]
        {
            function.setStaticDispatch(true);
        }
    (
        SqlRoutineBody(function)
        | ExternalRoutineBody(function)
    )
    {
        return function;
    }
}

FemRoutine ProcedureDefinition() :
{
    FemRoutine procedure;
    SqlIdentifier qualifiedName;
}
{
    <PROCEDURE> 
        {
            procedure = getRepos().newFemRoutine();
            procedure.setType(ProcedureTypeEnum.PROCEDURE);
            procedure.setCalledOnNullInput(true);
        }
    qualifiedName = CompoundIdentifier2()
        {
            // REVIEW jvs 18-Jan-2005:  see corresponding comment
            // in FunctionDefinition().
            farragoParser.getDdlValidator().setSchemaObjectName(
                procedure,qualifiedName);
            procedure.setInvocationName(procedure.getName());
        }
    <LPAREN> [ RoutineParamList(procedure) ] <RPAREN>
        {
        }
    RoutineCharacteristics(procedure)
        {
            // TODO jvs 18-Jan-2005:  disallow characteristics which
            // don't apply to procedures
        }
    (
        ExternalRoutineBody(procedure)
    )
    {
        return procedure;
    }
}

void SqlRoutineBody(FemRoutine routine) :
{
    SqlNode expr;
}
{
    [ <SQL> <SECURITY>
        (
            <INVOKER>
        {
            routine.setImpersonateDefiner(false);
        }
            | <DEFINER>
        {
            routine.setImpersonateDefiner(true);
        }
        )
    ]
        {
        }
        <RETURN> expr = Expression(EXPR_ACCEPT_NONQUERY)
    {
        // TODO jvs 24-Dec-2004: eventually allow subqueries and non-functional
        // routine bodies.
        farragoParser.getDdlValidator().setProcedureText(routine, expr);
    }
}

void ExternalRoutineBody(FemRoutine routine) :
{
    String name;
}
{
    <EXTERNAL> <NAME>
        (
             name = Identifier()
             | name = QuotedString()
        )
        {
            routine.setExternalName(name);
        }
    [ RoutineParameterStyle(routine) ]
        {
        }
    [ <EXTERNAL> <SECURITY> (
        <DEFINER>
    {
        routine.setImpersonateDefiner(true);
    }
        | <INVOKER>
    {
        routine.setImpersonateDefiner(false);
    }
        | <IMPLEMENTATION> <DEFINED>
    {
        routine.setImpersonateDefiner(true);
    }
        )
    {
    }
    ]
}

void RoutineParameterStyle(FemRoutine routine) :
{
}
{
    <PARAMETER> <STYLE> (
        <SQL>
    {
        routine.setParameterStyle(
            RoutineParameterStyleEnum.RPS_SQL);
    }
        | <GENERAL>
    {
        routine.setParameterStyle(
            RoutineParameterStyleEnum.RPS_GENERAL);
    }
        | <JAVA>
    {
        routine.setParameterStyle(
            RoutineParameterStyleEnum.RPS_JAVA);
    }
    )
        {
        }
}

void RoutineCharacteristics(FemRoutine routine) :
{
    SqlIdentifier specificName;
}
{
// TODO jvs 24-Dec-2004:  prevent conflicting declarations
    (
        (<LANGUAGE>
            (<JAVA>
                {
                    routine.setLanguage("JAVA");
                }
                | <SQL>
                {
                    routine.setLanguage("SQL");
                }
                ))
    {
    }
        | RoutineParameterStyle(routine)
    {
    }
        | (<SPECIFIC> specificName = CompoundIdentifier2())
    {
        if (specificName.names.length > 1) {
            assert(specificName.names.length == 2);
            if (!specificName.names[0].equals(routine.getNamespace().getName()))
            {
                throw farragoParser.getDdlValidator().newPositionalError(
                    routine, 
                    FarragoResource.instance().
                    newValidatorRoutineSchemaMismatch(
                        getRepos().getLocalizedObjectName(
                            specificName.names[0]), 
                        getRepos().getLocalizedObjectName(
                            routine.getNamespace())));
            }
            routine.setName(specificName.names[1]);
        } else {
            routine.setName(specificName.getSimple());
        }
    }
        | ( <DETERMINISTIC> )
    {
        routine.setDeterministic(true);
    }
        | ( <NOT> <DETERMINISTIC> )
    {
        routine.setDeterministic(false);
    }
        | (<NO> <SQL>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_NO_SQL);
    }
        | (<CONTAINS> <SQL>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_CONTAINS_SQL);
    }
        | (<READS> <SQL> <DATA>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_READS_SQL_DATA);
    }
        | (<MODIFIES> <SQL> <DATA>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_MODIFIES_SQL_DATA);
    }
        | (<RETURNS> <NULL> <ON> <NULL> <INPUT>)
    {
        routine.setCalledOnNullInput(false);
    }
        | (<CALLED> <ON> <NULL> <INPUT>)
    {
        routine.setCalledOnNullInput(true);
    }
// TODO jvs 24-Dec-2004:  add characteristics for dynamic result sets
// and savepoint level
    )*
}

void RoutineParamList(FemRoutine routine) :
{
}
{
    RoutineParam(routine)
    (
        <COMMA>
        RoutineParam(routine)
    )*
}

FemRoutineParameter RoutineParam(FemRoutine routine) :
{
    FemRoutineParameter param;
    SqlIdentifier name;
    
    param = getRepos().newFemRoutineParameter();
    routine.getParameter().add(param);
}
{
    {
    }
    [
        (
            <IN>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_IN);
        }
            | <OUT>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_OUT);
        }
            | <INOUT>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_INOUT);
        }
        )
    ]
        {
        }
    name = SimpleIdentifier()
        {
            param.setName(name.getSimple());
        }
    TypedElement(param)
        {
        }
    {
        return param;
    }
}

FemJar JarDefinition() :
{
    FemJar jar;
    SqlIdentifier qualifiedName;
    String url;
    SqlLiteral deploymentState;
}
{
    <JAR> 
        {
            jar = getRepos().newFemJar();
        }
    qualifiedName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                jar,qualifiedName);
        }
    <LIBRARY> url = QuotedString()
        {
            jar.setUrl(url);
        }
    <OPTIONS> <LPAREN> 
         deploymentState = NumericLiteral(ParserPosition.ZERO) <RPAREN>
        {
            jar.setDeploymentState(deploymentState.intValue());
        }
    {
        return jar;
    }
}

FemDataServer DataServerReference() :
{
    SqlIdentifier name;
}
{
    <SERVER> name = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findDataServer(name);
        }
}

FemForeignTable ForeignTableDefinition() :
{
    FemForeignTable table;
    FemDataServer server;
    SqlIdentifier qualifiedTableName;
}
{
    <FOREIGN> <TABLE>
        {
            table = getRepos().newFemForeignTable();
        }
    qualifiedTableName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                table,qualifiedTableName);
        }
    [ <LPAREN> ForeignTableElementList(table) <RPAREN> ]
        {
        }
    server = DataServerReference()
        {
            server.getColumnSet().add(table);
        }
    OptionalStorageOptions(table)
        {
        }
    {
        return table;
    }
}

FemForeignTable ForeignTableReference() :
{
    SqlIdentifier qualifiedTableName;
    FemForeignTable table;
}
{
    <FOREIGN> <TABLE> qualifiedTableName = CompoundIdentifier2()
        {
            table = (FemForeignTable)
            farragoParser.getStmtValidator().findSchemaObject(
                qualifiedTableName,
                getRepos().getMedPackage().getFemForeignTable());
        }
    {
        return table;
    }
}

void ForeignTableElementList(FemForeignTable table) :
{
}
{
    ColumnDefinition(table)
    (
        <COMMA>
        ColumnDefinition(table)
    )*
}

void OptionalStorageOptions(FemElementWithStorageOptions element) :
{
}
{
    [
        <OPTIONS>
        <LPAREN>
        StorageOption(element)
        (
            <COMMA>
            StorageOption(element)
        )*
        <RPAREN>
    {
    } ]
}

void StorageOption(FemElementWithStorageOptions element) :
{
    SqlIdentifier name;
    String value;
}
{
    name = SimpleIdentifier()
        {
        }
    value = QuotedString()
        {
        }
    {
        FemStorageOption option = getRepos().newFemStorageOption();
        option.setName(name.getSimple());
        option.setValue(value);
        element.getStorageOptions().add(option);
    }
}

CwmModelElement DataWrapperDrop() :
{
    CwmModelElement wrapper;
}
{
    wrapper = DataWrapperReference()
        {
        }
    CascadeOption()
        {
            return wrapper;
        }
}

CwmModelElement DataServerDrop() :
{
    CwmModelElement server;
}
{
    server = DataServerReference()
        {
        }
    CascadeOption()
        {
            return server;
        }
}

CwmModelElement ForeignTableDrop() :
{
    CwmModelElement table;
}
{
    table = ForeignTableReference()
        {
        }
    CascadeOption()
        {
            return table;
        }
}

/* KEYWORDS:  anything in this list is a reserved word unless it appears
   in the NonReservedKeyWord() production. */

TOKEN :
{
  < ALTER: "alter" >
| < AUTHORIZATION: "authorization" >
| < CALLED: "called" >
| < CASCADE: "cascade" >
| < CATALOG: "catalog" >
| < CHECKPOINT: "checkpoint" >
| < CLUSTERED: "clustered" >
| < COMMIT: "commit" >
| < CONSTRAINT: "constraint" >
| < CONTAINS: "contains" >
| < CREATE: "create" >
| < DATA: "data" >
| < DEFAULT_KW: "default" >
| < DEFINED: "defined" >
| < DEFINER: "definer" >
| < DETERMINISTIC: "deterministic" >
| < DISPATCH: "dispatch" >
| < DROP: "drop" >
| < EXTERNAL: "external" >
| < FOREIGN: "foreign" >
| < FUNCTION: "function" >
| < GENERAL: "general" >
| < GLOBAL: "global" >
| < INDEX: "index" >
| < INOUT: "inout" >
| < INPUT: "input" >
| < INVOKER: "invoker" >
| < JAR: "jar" >
| < JAVA: "java" >
| < MAX: "max" >
| < MIN: "min" >
| < KEY: "key" >
| < LANGUAGE: "language" >
| < LIBRARY: "library" >
| < LOCAL: "local" >
| < MODIFIES: "modifies" >
| < OPTIONS: "options" >
| < NAME: "name" >
| < NO: "no" >
| < OUT: "out" >
| < PARAMETER: "parameter" >
| < PATH: "path" >
| < PRESERVE: "preserve" >
| < PRIMARY: "primary" >
| < PROCEDURE: "procedure" >
| < READS: "reads" >
| < RELEASE: "release" >
| < RESTRICT: "restrict" >
| < RETURN: "return" >
| < RETURNS: "returns" >
| < ROLLBACK: "rollback" >
| < ROUTINE: "routine" >
| < SAVEPOINT: "savepoint" >
| < SCHEMA: "schema" >
| < SECURITY: "security" >
| < SERVER: "server" >
| < SPECIFIC: "specific" >
| < SQL: "sql" >
| < STATIC: "static" >
| < STYLE: "style" >
| < SYSTEM: "system" >
| < TEMPORARY: "temporary" >
| < TRUNCATE: "truncate" >
| < TYPE: "type" >
| < VERSION: "version" >
| < VIEW: "view" >
| < WRAPPER: "wrapper" >
}

/**
 * Parses a non-reserved DDL keyword for use as an identifier.  Parser
 * implementations based on CommonDdlParser.jj should include this as
 * well as CommonParser.jj's CommonNonReservedKeyWord() in their
 * implementation of the NonReservedKeyWord() production.
 */
String DdlNonReservedKeyWord() :
{
}
{
    (
        <CALLED>
        | <CASCADE>
        | <CATALOG>
        | <CONTAINS>
        | <DATA>
        | <DEFINED>
        | <DEFINER>
        | <DETERMINISTIC>
        | <DISPATCH>
        | <EXTERNAL>
        | <GENERAL>
        | <INDEX>
        | <INPUT>
        | <INVOKER>
        | <JAR>
        | <JAVA>
        | <KEY>
        | <LIBRARY>
        | <MAX>
        | <MIN>
        | <MODIFIES>
        | <NAME>
        | <NO>
        | <OPTIONS>
        | <PARAMETER>
        | <PATH>
        | <PRESERVE>
        | <READS>
        | <RESTRICT>
        | <RETURN>
        | <RETURNS>
        | <SCHEMA>
        | <SECURITY>
        | <SERVER>
        | <SPECIFIC>
        | <STATIC>
        | <STYLE>
        | <TEMPORARY>
        | <VERSION>
        | <VIEW>
        | <WRAPPER>
    )
        {
            return getToken(0).image.toUpperCase();
        }
}

// End CommonDdlParser.jj
