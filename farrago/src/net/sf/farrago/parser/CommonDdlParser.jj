// NOTE jvs 1-Feb-2005:  convenience functions belong in
// FarragoAbstractParserImpl, not here, unless they depend on
// information which is only available in the generated parser class
// (e.g. token).

/*****************************************
 * Convenience Functions                 *
 *****************************************/

JAVACODE SqlParserPos getEndPos()
{
    return new SqlParserPos(
        token.beginLine,
        token.beginColumn + token.image.length());
}

/*****************************************
 * Syntactical Descriptions              *
 *****************************************/


SqlIdentifier CompoundIdentifier2() :
{
    List list = new ArrayList();
    String p;
}
{
    (p = Identifier() {list.add(p);})
    (<DOT> p = Identifier() {list.add(p);})?
    {return new SqlIdentifier(SqlParserUtil.toStringArray(list),null);}
}

String QuotedString() :
{
    Token t;
}
{
    t = <QUOTED_STRING>
    {
      return SqlParserUtil.parseString(t.image);
    }
}

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 *
 * @return top-level CWM object affected for DDL statement, or top-level SqlNode
 * for DML or query statement
 */
Object FarragoSqlStmtEof() :
{
    Object obj;
}
{
    (
        obj = DdlStmtEof()
    |
        obj = SqlStmtEof()
    )
        { return obj; }
}

DdlStmt DdlStmtEof() :
{
    CwmModelElement modelElement;
    DdlStmt ddlStmt;
    SqlNode expr;
}
{
    (
        ( <CREATE>
          (
            modelElement = SchemaDefinition()
            |
            LOOKAHEAD(2)
            modelElement = DataWrapperDefinition()
            |
            modelElement = SchemaObjectDefinition()
            |
            modelElement = IndexDefinition(null)
            |
            modelElement = DataServerDefinition()
            |
            modelElement = ExtensionModelDefinition()
           )
        {
            ddlStmt = new DdlCreateStmt(modelElement);
        }
        )
        |
        ( <DROP>
        {
            // assume RESTRICT; CascadeOption() may override
            dropRestrict = true;
        }
          (
              modelElement = SchemaDrop()
              |
              modelElement = TableDrop()
              |
              modelElement = IndexDrop()
              |
              modelElement = ViewDrop()
              |
              modelElement = RoutineDrop()
              |
              modelElement = JarDrop()
              |
              modelElement = DataServerDrop()
              |
              LOOKAHEAD(2)
              modelElement = DataWrapperDrop()
              |
              LOOKAHEAD(2)
              modelElement = ForeignTableDrop()
              |
              modelElement = ExtensionModelDrop()
          )
        {
            ddlStmt = new DdlDropStmt(modelElement,dropRestrict);
        }
        )
        |
        ( <TRUNCATE>
          (
              <TABLE> modelElement = TableIdentifier()
          )
        {
            ddlStmt = new DdlTruncateStmt(modelElement);
        }
        )
        |
        ( <SET>
            (
                <CATALOG> expr = Expression(EXPR_ACCEPT_NONQUERY)
            {
                ddlStmt = new DdlSetCatalogStmt(expr);
            }
                | <SCHEMA> expr = Expression(EXPR_ACCEPT_NONQUERY)
            {
                ddlStmt = new DdlSetSchemaStmt(expr);
            }
                | <PATH> expr = Expression(EXPR_ACCEPT_NONQUERY)
            {
                ddlStmt = new DdlSetPathStmt(expr);
            }
            )
        )
        |
        ( <ALTER>
          (
              <SYSTEM> <SET> ddlStmt = SystemParamAssignment()
              |
              ddlStmt = ExtensionModelAlter()
          )
        {
        }
        )
        |
        ( <CHECKPOINT> { ddlStmt = new DdlCheckpointStmt(); } )
        |
        ( <COMMIT> { ddlStmt = new DdlCommitStmt(); } )
        |
        ( <ROLLBACK> ddlStmt = Rollback())
        |
        ( <SAVEPOINT> ddlStmt = Savepoint())
        |
        ( <RELEASE> <SAVEPOINT> ddlStmt = ReleaseSavepoint())
    )
        <EOF>
        {
            return ddlStmt;
        }
}

// TODO:  support non-topological order of object definition, e.g. a
// referencing table before a referenced table

FemLocalSchema SchemaDefinition() :
{
    FemLocalSchema schema;
    SqlIdentifier schemaName,userName;
    boolean pathDefined = false;
}
{
    <SCHEMA> schemaName = CompoundIdentifier2()
        {
            schema = getRepos().newFemLocalSchema();
            if (schemaName.names.length == 2) {
                CwmCatalog catalog =
                    farragoParser.getStmtValidator().findCatalog(
                        schemaName.names[0]);
                schema.setNamespace(catalog);
                schema.setName(schemaName.names[1]);
            } else {
                schema.setNamespace(
                    farragoParser.getStmtValidator().getDefaultCatalog());
                schema.setName(schemaName.getSimple());
            }
        }
    [ <AUTHORIZATION> userName = SimpleIdentifier() ]
        {
            // TODO:  store userName
        }
    [ SchemaPath(schema) { pathDefined = true; } ]
        {
            if (!pathDefined) {
                // implicit default path is just this schema itself
                FemSqlpathElement element = getRepos().newFemSqlpathElement();
                element.setSearchedSchemaCatalogName(
                    schema.getNamespace().getName());
                element.setSearchedSchemaName(
                    schema.getName());
                schema.getPathElement().add(element);
            }

            // set up context which will prevail for any object
            // definitions included in this schema definition
            farragoParser.getDdlValidator().setCreatedSchemaContext(schema);
        }
    (
        <CREATE>
        SchemaObjectDefinition()
    )*
    {
        // TODO: character set, all that jazz
        return schema;
    }
}

CwmModelElement SchemaObjectDefinition() :
{
    CwmModelElement modelElement;
}
{
    (
        modelElement = TableDefinition()
        |
        modelElement = ViewDefinition()
        |
        LOOKAHEAD(2)
        modelElement = ForeignTableDefinition()
        |
        modelElement = FunctionDefinition()
        |
        modelElement = ProcedureDefinition()
        |
        modelElement = JarDefinition()
        |
        modelElement = UserDefinedTypeDefinition()
        |
        modelElement = ExtensionModelSchemaObjDefinition()
    )
        {
            return modelElement;
        }
}

void SchemaPath(FemLocalSchema schema) :
{
    List searchPath;
}
{
    searchPath = SearchPath()
        {
            Iterator iter = searchPath.iterator();
            while (iter.hasNext()) {
                CwmSchema searchedSchema = (CwmSchema) iter.next();
                if (searchedSchema.getNamespace() != schema.getNamespace()) {
                    throw FarragoResource.instance().newValidatorPathBadCatalog(
                        getRepos().getLocalizedObjectName(
                            searchedSchema.getNamespace()),
                        getRepos().getLocalizedObjectName(
                            schema.getNamespace()));
                }
                FemSqlpathElement element = getRepos().newFemSqlpathElement();
                element.setSearchedSchemaCatalogName(
                    searchedSchema.getNamespace().getName());
                element.setSearchedSchemaName(
                    searchedSchema.getName());
                schema.getPathElement().add(element);
            }
        }
}

List SearchPath() :
{
    List list = new ArrayList();
}
{
    <PATH> SearchPathElement(list) (<COMMA> SearchPathElement(list))*
        {
            return list;
        }
}

void SearchPathElement(List list) :
{
    SqlIdentifier id;
}
{
    id = CompoundIdentifier2()
        {
            FemLocalSchema searchedSchema =
                farragoParser.getStmtValidator().findSchema(id);
            list.add(searchedSchema);
        }
}

// TODO:  support non-topological order of table element definition, e.g. a
// referencing constraint definition before a referenced column definition

CwmTable TableDefinition() :
{
    FemStoredTable table;
    FemDataServer server = null;
}
{
    (
        table = UnscopedTableDefinition()
        |
        table = ScopedTableDefinition()
    )
        {
        }
    [ server = DataServerReference() ]
        {
        }
    OptionalStorageOptions(table)
        {
        }
    (LOOKAHEAD(2) <CREATE> IndexDefinition(table))*
        {
        }
    {
        if (server == null) {
            server =
                farragoParser.getStmtValidator().getDefaultLocalDataServer();
        }
        table.setServer(server);
        return table;
    }
}

FemLocalTable UnscopedTableDefinition() :
{
    FemLocalTable table;
    SqlIdentifier qualifiedTableName;
}
{
    <TABLE>
        {
            table = getRepos().newFemLocalTable();
        }
    qualifiedTableName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                table,qualifiedTableName);
        }
    <LPAREN> TableElementList(table) <RPAREN>
        {
        }
    {
        return table;
    }
}

FemLocalTable ScopedTableDefinition() :
{
    FemLocalTable table;
    String scope;
    String commitOption;
}
{
    <GLOBAL> <TEMPORARY>
    table = UnscopedTableDefinition()
        {
            table.setTemporary(true);

            // TODO:  support LOCAL (as "MODULE")
            scope = "SESSION";
            commitOption = "DELETE";
        }
    [ <ON> <COMMIT>
      (
          <PRESERVE>
      {
          commitOption = "PRESERVE";
      }
          |
          <DELETE>
      {
          commitOption = "DELETE";
      }
      )
      <ROWS> ]
        {
        }
    {
        // TODO:  define a tag for commitOption, since CWM doesn't have a place
        // for it?
        table.setTemporaryScope(scope + ":COMMIT=" + commitOption);
        return table;
    }
}

CwmView ViewDefinition() :
{
    CwmView view;
    SqlIdentifier qualifiedViewName;
    SqlNode query;
    List columnNameList;
    SqlParserPos defStart, defEnd;
}
{
    <VIEW>
        {
           view = getRepos().newCwmView();
        }
    qualifiedViewName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                view,qualifiedViewName);
        }
    [<LPAREN> columnNameList = SimpleIdentifierCommaList()
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).getSimple();
                CwmColumn column = getRepos().newFemViewColumn();
                column.setName(columnName);
                view.getFeature().add(column);
            }
        }
     <RPAREN>]

    <AS>
        {
            defStart = getEndPos();
            farragoParser.getDdlValidator().setParserOffset(view, defStart);
        }
    query = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY)
        {
            defEnd = getEndPos();
            
            // NOTE:  we accept ORDER BY on the view definition, even though
            // that's not standard SQL, and leave it up to the validator to
            // decide what to do with it

            String bodyText = farragoParser.getSubstring(defStart, defEnd);
            CwmQueryExpression queryExpr = getRepos().newCwmQueryExpression();
            queryExpr.setLanguage("SQL");
            queryExpr.setBody(bodyText);
            view.setQueryExpression(queryExpr);
        }
    {
       return view;
    }
}


FemLocalIndex IndexDefinition(CwmTable table) :
{
    FemLocalIndex index;
    SqlIdentifier indexName;
    CwmTable specifiedTable;
    List columnNameList;
    boolean unique = false;
    boolean clustered = false;
}
{
    [ <UNIQUE> { unique = true; } ]
        {
        }
    [ <CLUSTERED> { clustered = true; } ]
        {
        }
    <INDEX>
        {
            index = getRepos().newFemLocalIndex();
        }
    indexName = SimpleIdentifier()
        {
            index.setName(indexName.getSimple());
        }
    <ON> specifiedTable = TableIdentifier()
        {
            if (table == null) {
                table = specifiedTable;
            } else {
                // TODO:  move rule down into validator
                if (table != specifiedTable) {
                    throw farragoParser.getDdlValidator().newPositionalError(
                        index,
                        FarragoResource.instance().newValidatorIndexBadTable());
                }
            }
            getRepos().getKeysIndexesPackage().getIndexSpansClass().add(
                table,index);
            // REVIEW:  why is this necessary?  shouldn't association above be
            // sufficient?
            index.setSpannedClass(table);
            if (clustered) {
                index.setClustered(true);
            }
            index.setUnique(unique);
        }
    <LPAREN> columnNameList = SimpleIdentifierCommaList() <RPAREN>
        {
            int iOrdinal = 0;
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).getSimple();
                CwmColumn column = farragoParser.getStmtValidator().findColumn(
                    table,columnName);
                FemLocalIndexColumn indexColumn =
                    getRepos().newFemLocalIndexColumn();
                indexColumn.setName(columnName);
                indexColumn.setAscending(Boolean.TRUE);
                indexColumn.setFeature(column);
                indexColumn.setIndex(index);
                indexColumn.setOrdinal(iOrdinal++);
            }
        }
    {
        return index;
    }
}

CwmTable TableIdentifier() :
{
    SqlIdentifier qualifiedTableName;
    CwmTable table;
}
{
    qualifiedTableName = CompoundIdentifier2()
        {
            table = (CwmTable)
            farragoParser.getStmtValidator().findSchemaObject(
                qualifiedTableName,
                getRepos().getRelationalPackage().getCwmTable());
        }
    {
        return table;
    }
}

CwmView ViewReference() :
{
    SqlIdentifier qualifiedViewName;
    CwmView view;
}
{
    <VIEW> qualifiedViewName = CompoundIdentifier2()
        {
            view = (CwmView) farragoParser.getStmtValidator().findSchemaObject(
                qualifiedViewName,
                getRepos().getRelationalPackage().getCwmView());
        }
    {
        return view;
    }
}

FemRoutine RoutineReference() :
{
    SqlIdentifier qualifiedRoutineName;
    FemRoutine routine;
    boolean specific = false;
    ProcedureType routineType;
}
{
    [ <SPECIFIC> { specific = true; } ]
    (
        <ROUTINE>
    {
        routineType = null;
    }
        | <FUNCTION>
    {
        routineType = ProcedureTypeEnum.FUNCTION;
    }
        | <PROCEDURE>
    {
        routineType = ProcedureTypeEnum.PROCEDURE;
    }
    )
        qualifiedRoutineName = CompoundIdentifier2()
        {
            // TODO jvs 24-Dec-2004: implement lookup by invocation name
            // and signature when !specific
            routine = (FemRoutine)
            farragoParser.getStmtValidator().findSchemaObject(
                qualifiedRoutineName,
                getRepos().getSql2003Package().getFemRoutine());

            // REVIEW jvs 29-Dec-2004:  localization in message below
            // is iffy

            // if they specifically asked for a FUNCTION or PROCEDURE,
            // and the object found does not match, pretend we
            // found nothing
            if ((routineType != null) && (routineType != routine.getType())) {
                throw farragoParser.newPositionalError(
                    FarragoResource.instance().newValidatorUnknownObject(
                        routineType.toString() + " " +
                        getRepos().getLocalizedObjectName(
                            routine.getNamespace().getName(),
                            routine.getName(),
                            null)));
            }
        }
    {
        return routine;
    }
}

void TableElementList(CwmTable table) :
{
}
{
    TableElement(table)
    (
        <COMMA>
        TableElement(table)
    )*
}



CwmModelElement TableElement(CwmTable table) :
{
    CwmModelElement modelElement;
}
{
    (
        modelElement = ColumnDefinition(table)
        |
        modelElement = TableConstraint(table)
    )
        {
            return modelElement;
        }
}

void BasicColumnDefinition(CwmNamedColumnSet table,FemAbstractColumn column) :
{
    SqlIdentifier columnName;
}
{
    columnName = SimpleIdentifier()
        {
            table.getFeature().add(column);
            column.setName(columnName.getSimple());
        }
    TypedElement(column)
}

void TypedElement(FemAbstractTypedElement element) :
{
    SqlDataTypeSpec dataType;
}
{
    dataType = DataType()
    [
        <MULTISET>
        {
            FemSqlmultisetType colType = getRepos().newFemSqlmultisetType();
            colType.setName("MULTISET");
            FemSqltypeAttribute componentType =
                getRepos().newFemSqltypeAttribute();
            componentType.setName("COMPONENT");
            colType.getFeature().add(componentType);
            farragoParser.getDdlValidator().setSqlDefinition(
                componentType,
                dataType);
            FemSqltypedElement typedElement =
                FarragoCatalogUtil.toFemSqltypedElement(element);
            typedElement.setType(colType);
            return;
        }
    ]
    {
        farragoParser.getDdlValidator().setSqlDefinition(
            element,
            dataType);
    }
}

CwmColumn ColumnDefinition(CwmTable table) :
{
    FemStoredColumn column;
    SqlNode defaultClause;
    SqlCollation sqlCollation;
}
{
    {
        column = getRepos().newFemStoredColumn();
    }
    BasicColumnDefinition(table,column)
        {
        }
    [
        defaultClause = DefaultClause()
        {
            setDefaultExpression(column, defaultClause);
        }
    ]
        {
        }
    ( ColumnConstraint(table,column) )*
        {
        }
    [ sqlCollation = CollateClause()
        {
            column.setCollationName(sqlCollation.getCollationName());
        }
    ]
        {
        }
    OptionalStorageOptions(column)
        {
        }
    {
        return column;
    }
}

SqlNode DefaultClause() :
{
    SqlNode expression;
}
{
    <DEFAULT_KW> (
        // TODO:  allow USER, CURRENT_USER, CURRENT_ROLE, SESSION_USER,
        // SYSTEM_USER, CURRENT_PATH, <datatime value function>,
        // <implicitly typed value specification>
        expression = Literal()
    )
        {
            return expression;
        }
}

CwmModelElement TableConstraint(CwmTable table) :
{
    String constraintName = null;
    CwmUniqueConstraint constraint;
}
{
    [ <CONSTRAINT> constraintName = Identifier() ]
        {
        }
    constraint = TableUniqueConstraint(table)
        {
            if (constraintName != null) {
                constraint.setName(constraintName);
            } else {
                FarragoCatalogUtil.generateConstraintName(
                    getRepos(), constraint);
            }
            table.getOwnedElement().add(constraint);
        }
    {
        return constraint;
    }
}

CwmUniqueConstraint TableUniqueConstraint(CwmTable table) :
{
    CwmUniqueConstraint constraint;
    List columnNameList;
}
{
    constraint = UniqueConstraint()
        {
        }
    <LPAREN> columnNameList = SimpleIdentifierCommaList() <RPAREN>
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).getSimple();
                CwmColumn column = farragoParser.getStmtValidator().findColumn(
                    table,columnName);
                constraint.getFeature().add(column);
                // TODO:  validate no duplicates
            }
        }
    // TODO:  deferrability, etc.
    {
        return constraint;
    }
}

CwmUniqueConstraint UniqueConstraint() :
{
    CwmUniqueConstraint constraint;
}
{
    (
        <UNIQUE>
    {
        constraint = getRepos().newCwmUniqueConstraint();
    }
        |
        <PRIMARY> <KEY>
    {
        constraint = getRepos().newCwmPrimaryKey();
    }
    )
        {
            constraint.setDeferrability(DeferrabilityTypeEnum.NOT_DEFERRABLE);
            return constraint;
        }
}



void ColumnConstraint(CwmNamedColumnSet table,CwmColumn column) :
{
    CwmUniqueConstraint constraint;
    String constraintName = null;
}
{
    [ <CONSTRAINT> constraintName = Identifier() ]
        {
        }
    (
        <NOT> <NULL>
    {
        column.setIsNullable(NullableTypeEnum.COLUMN_NO_NULLS);
    }
        | constraint = UniqueConstraint()
        {
            constraint.getFeature().add(column);
            table.getOwnedElement().add(constraint);
            if (constraintName != null) {
                constraint.setName(constraintName);
            } else {
                FarragoCatalogUtil.generateConstraintName(
                    getRepos(), constraint);
            }
        }
    )
        {
        }
}

CwmModelElement SchemaDrop() :
{
    SqlIdentifier schemaName;
    FemLocalSchema schema;
}
{
    schema = SchemaReference()
        {
        }
    CascadeOption()
        {
            return schema;
        }
}

CwmCatalog CatalogReference() :
{
    SqlIdentifier catalogName;
}
{
    <CATALOG> catalogName = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findCatalog(
                catalogName.getSimple());
        }
}

FemLocalSchema SchemaReference() :
{
    SqlIdentifier schemaName;
}
{
    <SCHEMA> schemaName = CompoundIdentifier2()
        {
            return farragoParser.getStmtValidator().findSchema(schemaName);
        }
}

CwmModelElement TableDrop() :
{
    CwmModelElement table;
}
{
    <TABLE> table = TableIdentifier()
        {
        }
    CascadeOption()
        {
            return table;
        }
}

CwmModelElement ViewDrop() :
{
    CwmModelElement view;
}
{
    view = ViewReference()
        {
        }
    CascadeOption()
        {
            return view;
        }
}

CwmModelElement RoutineDrop() :
{
    CwmModelElement routine;
}
{
    routine = RoutineReference()
        {
        }
    CascadeOption()
        {
            return routine;
        }
}

CwmModelElement JarDrop() :
{
    SqlIdentifier qualifiedJarName;
    SqlLiteral deploymentState;
}
{
    <JAR> qualifiedJarName = CompoundIdentifier2()
        {
        }
    <OPTIONS>
         <LPAREN> deploymentState = NumericLiteral(SqlParserPos.ZERO) <RPAREN>
        {
        }
    CascadeOption()
        {
        }
    {
        FemJar jar = (FemJar) farragoParser.getStmtValidator().findSchemaObject(
            qualifiedJarName,
            getRepos().getSql2003Package().getFemJar());
        jar.setDeploymentState(deploymentState.intValue());
        return jar;
    }
}

CwmModelElement IndexDrop() :
{
    SqlIdentifier qualifiedIndexName;
}
{
    <INDEX> qualifiedIndexName = CompoundIdentifier2()
        {
            return farragoParser.getStmtValidator().findSchemaObject(
                qualifiedIndexName,
                getRepos().getMedPackage().getFemLocalIndex());
        }
}

void CascadeOption() :
{
}
{
    [
        (
            <RESTRICT>
        {
            dropRestrict = true;
        }
            | <CASCADE>
        {
            dropRestrict = false;
        }
        )
    ]
}

DdlStmt SystemParamAssignment() :
{
    SqlIdentifier paramName;
    SqlLiteral paramValue;
}
{
    paramName = SimpleIdentifier()
        {
        }
    <EQ>
        {
        }
    paramValue = SystemParamValue()
        {
        }
    {
        return new DdlSetSystemParamStmt(
            paramName.getSimple(),paramValue);
    }
}

SqlLiteral SystemParamValue() :
{
    SqlLiteral paramValue;
    SqlParserPos pos = null;  
}
{
    (
        paramValue = StrictLiteral()
        {
        }
        | <MAX>
        {
            // TODO jvs 22-May-2004:  for MIN and MAX here, use metadata
            // to determine the correct min and max values
            pos = getPos();
            paramValue = SqlLiteral.createExactNumeric("-1", pos);
        }
        | <MIN>
        {
            pos = getPos();
            paramValue = SqlLiteral.createExactNumeric("0", pos);
        }
    )
        {
            return paramValue;
        }
}

DdlStmt Rollback() :
{
    SqlIdentifier savepointName = null;
}
{
    (<TO> <SAVEPOINT> savepointName = SimpleIdentifier() )?
        {
        }
    {
        if (savepointName != null) {
            return new DdlRollbackStmt(savepointName.getSimple());
        } else {
            return new DdlRollbackStmt(null);
        }
    }
}

DdlStmt Savepoint() :
{
    SqlIdentifier savepointName = null;
}
{
    savepointName = SimpleIdentifier()
        {
        }
    {
        return new DdlSavepointStmt(savepointName.getSimple());
    }
}

DdlStmt ReleaseSavepoint() :
{
    SqlIdentifier savepointName = null;
}
{
    savepointName = SimpleIdentifier()
        {
        }
    {
        return new DdlReleaseSavepointStmt(savepointName.getSimple());
    }
}

FemDataWrapper DataWrapperDefinition() :
{
    FemDataWrapper wrapper;
    SqlIdentifier wrapperName;
    String libraryFile;
    boolean isForeign;
}
{
    isForeign = ForeignOpt()
        {
        }
    <DATA> <WRAPPER> wrapperName = SimpleIdentifier()
        {
            wrapper = getRepos().newFemDataWrapper();
            wrapper.setName(wrapperName.getSimple());
            wrapper.setNamespace(
                getRepos().getCatalog(
                    FarragoRepos.SYSBOOT_CATALOG_NAME));
            wrapper.setForeign(isForeign);
        }
    <LIBRARY> libraryFile = QuotedString()
        {
            wrapper.setLibraryFile(libraryFile);
        }
    <LANGUAGE> <JAVA>
        {
            wrapper.setLanguage("JAVA");
        }
    OptionalStorageOptions(wrapper)
        {
        }
    {
        return wrapper;
    }
}

boolean ForeignOpt() :
{
}
{
    <LOCAL>
        {
            return false;
        }
    | <FOREIGN>
        {
            return true;
        }
}

FemDataWrapper DataWrapperReference() :
{
    SqlIdentifier name;
    boolean isForeign;
}
{
    isForeign = ForeignOpt()
        {
        }
    <DATA> <WRAPPER> name = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findDataWrapper(
                name,isForeign);
        }
}

FemDataServer DataServerDefinition() :
{
    FemDataServer server;
    FemDataWrapper wrapper;
    SqlIdentifier serverName;
    String serverType;
    String serverVersion;
}
{
    <SERVER> serverName = SimpleIdentifier()
        {
            server = getRepos().newFemDataServer();
            server.setName(serverName.getSimple());
            server.setNamespace(
                getRepos().getCatalog(
                    FarragoRepos.SYSBOOT_CATALOG_NAME));
        }
    [
        <TYPE> serverType = QuotedString()
        {
            server.setType(serverType);
        }
    ]
    [
        <VERSION> serverVersion = QuotedString()
        {
            server.setVersion(serverVersion);
        }
    ]
        {
        }
    wrapper = DataWrapperReference()
        {
            server.setWrapper(wrapper);
        }
    OptionalStorageOptions(server)
        {
        }
    {
        return server;
    }
}

FemRoutine FunctionDefinition() :
{
    FemRoutine function;
    SqlIdentifier qualifiedName;
    FemRoutineParameter returnParam;
}
{
    <FUNCTION>
        {
            function = getRepos().newFemRoutine();
            function.setType(ProcedureTypeEnum.FUNCTION);
            returnParam = getRepos().newFemRoutineParameter();
            function.setCalledOnNullInput(true);
        }
    qualifiedName = CompoundIdentifier2()
        {
            // REVIEW jvs 27-Dec-2004:  SQL standard says that
            // specific name is implementation-defined when unspecified.
            // The behavior here is to use the invocation name, which
            // means if there's a conflict with an existing specific name,
            // the CREATE statement will fail.  This forces users to
            // provide specific names when overloads are defined.  An
            // alternative is to generate unique specific names automatically
            // in case of conflict.
            farragoParser.getDdlValidator().setSchemaObjectName(
                function,qualifiedName);
            function.setInvocationName(function.getName());
        }
    <LPAREN> [ RoutineParamList(function) ] <RPAREN>
        {
        }
    <RETURNS> TypedElement(returnParam)
        {
            returnParam.setName("RETURN");
            returnParam.setKind(ParameterDirectionKindEnum.PDK_RETURN);
            function.getParameter().add(returnParam);
        }
    RoutineCharacteristics(function)
        {
        }
    [ <STATIC> <DISPATCH> ]
        {
            function.setStaticDispatch(true);
        }
    (
        SqlRoutineBody(function)
        | ExternalRoutineBody(function)
    )
    {
        return function;
    }
}

FemRoutine ProcedureDefinition() :
{
    FemRoutine procedure;
    SqlIdentifier qualifiedName;
}
{
    <PROCEDURE>
        {
            procedure = getRepos().newFemRoutine();
            procedure.setType(ProcedureTypeEnum.PROCEDURE);
            procedure.setCalledOnNullInput(true);
        }
    qualifiedName = CompoundIdentifier2()
        {
            // REVIEW jvs 18-Jan-2005:  see corresponding comment
            // in FunctionDefinition().
            farragoParser.getDdlValidator().setSchemaObjectName(
                procedure,qualifiedName);
            procedure.setInvocationName(procedure.getName());
        }
    <LPAREN> [ RoutineParamList(procedure) ] <RPAREN>
        {
        }
    RoutineCharacteristics(procedure)
        {
            // TODO jvs 18-Jan-2005:  disallow characteristics which
            // don't apply to procedures
        }
    (
        ExternalRoutineBody(procedure)
    )
    {
        return procedure;
    }
}

void SqlRoutineBody(FemRoutine routine) :
{
    SqlNode expr;
    SqlParserPos defStart, defEnd;
}
{
    [ <SQL> <SECURITY>
        (
            <INVOKER>
        {
            routine.setImpersonateDefiner(false);
        }
            | <DEFINER>
        {
            routine.setImpersonateDefiner(true);
        }
        )
    ]
        {
        }
    <RETURN>
        {
            defStart = getEndPos();
            farragoParser.getDdlValidator().setParserOffset(routine, defStart);
            
            // TODO jvs 24-Dec-2004: eventually allow subqueries and
            // non-functional routine bodies.
        }
    expr = Expression(EXPR_ACCEPT_NONQUERY)
        {
            defEnd = getEndPos();
        
            String bodyText = farragoParser.getSubstring(defStart, defEnd);
            CwmProcedureExpression procedureExpr =
            getRepos().newCwmProcedureExpression();
            procedureExpr.setLanguage("SQL");
            procedureExpr.setBody(
                FarragoUserDefinedRoutine.addReturnPrefix(bodyText));
            routine.setBody(procedureExpr);
        }
}

void ExternalRoutineBody(FemRoutine routine) :
{
    String name;
}
{
    <EXTERNAL> <NAME>
        (
             name = Identifier()
             | name = QuotedString()
        )
        {
            routine.setExternalName(name);
        }
    [ RoutineParameterStyle(routine) ]
        {
        }
    [ <EXTERNAL> <SECURITY> (
        <DEFINER>
    {
        routine.setImpersonateDefiner(true);
    }
        | <INVOKER>
    {
        routine.setImpersonateDefiner(false);
    }
        | <IMPLEMENTATION> <DEFINED>
    {
        routine.setImpersonateDefiner(true);
    }
        )
    {
    }
    ]
}

void RoutineParameterStyle(FemRoutine routine) :
{
}
{
    <PARAMETER> <STYLE> (
        <SQL>
    {
        routine.setParameterStyle(
            RoutineParameterStyleEnum.RPS_SQL);
    }
        | <GENERAL>
    {
        routine.setParameterStyle(
            RoutineParameterStyleEnum.RPS_GENERAL);
    }
        | <JAVA>
    {
        routine.setParameterStyle(
            RoutineParameterStyleEnum.RPS_JAVA);
    }
    )
        {
        }
}

void RoutineCharacteristics(FemRoutine routine) :
{
    SqlIdentifier specificName;
}
{
// TODO jvs 24-Dec-2004:  prevent conflicting declarations
    (
        (<LANGUAGE>
            (<JAVA>
                {
                    routine.setLanguage("JAVA");
                }
                | <SQL>
                {
                    routine.setLanguage("SQL");
                }
                ))
    {
    }
        | RoutineParameterStyle(routine)
    {
    }
        | (<SPECIFIC> specificName = CompoundIdentifier2())
    {
        if (specificName.names.length > 1) {
            assert(specificName.names.length == 2);
            if (!specificName.names[0].equals(routine.getNamespace().getName()))
            {
                throw farragoParser.getDdlValidator().newPositionalError(
                    routine,
                    FarragoResource.instance().
                    newValidatorRoutineSchemaMismatch(
                        getRepos().getLocalizedObjectName(
                            specificName.names[0]),
                        getRepos().getLocalizedObjectName(
                            routine.getNamespace())));
            }
            routine.setName(specificName.names[1]);
        } else {
            routine.setName(specificName.getSimple());
        }
    }
        | ( <DETERMINISTIC> )
    {
        routine.setDeterministic(true);
    }
        | ( <NOT> <DETERMINISTIC> )
    {
        routine.setDeterministic(false);
    }
        | (<NO> <SQL>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_NO_SQL);
    }
        | (<CONTAINS> <SQL>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_CONTAINS_SQL);
    }
        | (<READS> <SQL> <DATA>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_READS_SQL_DATA);
    }
        | (<MODIFIES> <SQL> <DATA>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_MODIFIES_SQL_DATA);
    }
        | (<RETURNS> <NULL> <ON> <NULL> <INPUT>)
    {
        routine.setCalledOnNullInput(false);
    }
        | (<CALLED> <ON> <NULL> <INPUT>)
    {
        routine.setCalledOnNullInput(true);
    }
// TODO jvs 24-Dec-2004:  add characteristics for dynamic result sets
// and savepoint level
    )*
}

void RoutineParamList(FemRoutine routine) :
{
}
{
    RoutineParam(routine)
    (
        <COMMA>
        RoutineParam(routine)
    )*
}

FemRoutineParameter RoutineParam(FemRoutine routine) :
{
    FemRoutineParameter param;
    SqlIdentifier name;

    param = getRepos().newFemRoutineParameter();
    routine.getParameter().add(param);
}
{
    {
    }
    [
        (
            <IN>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_IN);
        }
            | <OUT>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_OUT);
        }
            | <INOUT>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_INOUT);
        }
        )
    ]
        {
        }
    name = SimpleIdentifier()
        {
            param.setName(name.getSimple());
        }
    TypedElement(param)
        {
        }
    {
        return param;
    }
}

FemJar JarDefinition() :
{
    FemJar jar;
    SqlIdentifier qualifiedName;
    String url;
    SqlLiteral deploymentState;
}
{
    <JAR>
        {
            jar = getRepos().newFemJar();
        }
    qualifiedName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                jar,qualifiedName);
        }
    <LIBRARY> url = QuotedString()
        {
            jar.setUrl(url);
        }
    <OPTIONS> <LPAREN>

         deploymentState = NumericLiteral(SqlParserPos.ZERO) <RPAREN>
        {
            jar.setDeploymentState(deploymentState.intValue());
        }
    {
        return jar;
    }
}

FemUserDefinedType UserDefinedTypeDefinition() :
{
    SqlIdentifier qualifiedName;
    FemUserDefinedType typeDef;
}
{
    // TODO jvs 1-Feb-2005:  UNDER, AS-less, methods,
    // references, cast defs
    <TYPE> qualifiedName = CompoundIdentifier2()
        {
        }
    <AS> (
        typeDef = ObjectTypeDefinition()
        | typeDef = DistinctTypeDefinition()
    )
        {
        }
    UserDefinedTypeOptions(typeDef)
        {
        }
    {
        farragoParser.getDdlValidator().setSchemaObjectName(
            typeDef, qualifiedName);
        return typeDef;
    }
}

void UserDefinedTypeOptions(FemUserDefinedType typeDef) :
{
}
{
// TODO jvs 13-Feb-2005:  prevent conflicting declarations.  Also, technically,
// structured types REQUIRE a finality declaration, and distinct types
// PROHIBIT an instantiability declaration.
    (
        <FINAL>
    {
        typeDef.setFinal(true);
    }
        | <INSTANTIABLE>
    {
        typeDef.setAbstract(false);
    }
        | <NOT>
        (
            <FINAL>
        {
            typeDef.setFinal(false);
        }
            | <INSTANTIABLE>
        {
            typeDef.setAbstract(true);
        }
        )
    )*
        {
        }
    {
    }
}

FemSqlobjectType ObjectTypeDefinition() :
{
    FemSqlobjectType typeDef = getRepos().newFemSqlobjectType();
}
{
    <LPAREN>
         AttributeDefinition(typeDef)
         (<COMMA> AttributeDefinition(typeDef))* <RPAREN>
        {
        }    
    {
        // NOTE jvs 13-Feb-2005:  for now, this is to trigger an error
        // in case they forget to specify FINAL
        typeDef.setFinal(false);
        typeDef.setAbstract(false);
        return typeDef;
    }
}

FemSqldistinguishedType DistinctTypeDefinition() :
{
    FemSqldistinguishedType typeDef = getRepos().newFemSqldistinguishedType();
    SqlDataTypeSpec dataType;
}
{
    dataType = DataType()
        {
            farragoParser.getDdlValidator().setSqlDefinition(
                typeDef,
                dataType);
        }
    {
        typeDef.setFinal(true);
        typeDef.setAbstract(false);
        return typeDef;
    }
}

void AttributeDefinition(FemSqlobjectType typeDef) :
{
    SqlIdentifier name;
    SqlDataTypeSpec dataType;
    FemSqltypeAttribute attrDef = getRepos().newFemSqltypeAttribute();
    SqlNode defaultClause;
    SqlCollation sqlCollation;
}
{
    name = SimpleIdentifier()
        {
            attrDef.setName(name.getSimple());
        }
    dataType = DataType()
        {
            farragoParser.getDdlValidator().setSqlDefinition(
                attrDef,
                dataType);
        }
    [ defaultClause = DefaultClause()
        {
            setDefaultExpression(attrDef, defaultClause);
        }
    ]
        {
        }
    [ sqlCollation = CollateClause()
        {
            attrDef.setCollationName(sqlCollation.getCollationName());
        }
    ]
        {
        }
    {
        typeDef.getFeature().add(attrDef);
    }
}

FemDataServer DataServerReference() :
{
    SqlIdentifier name;
}
{
    <SERVER> name = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findDataServer(name);
        }
}

FemForeignTable ForeignTableDefinition() :
{
    FemForeignTable table;
    FemDataServer server;
    SqlIdentifier qualifiedTableName;
}
{
    <FOREIGN> <TABLE>
        {
            table = getRepos().newFemForeignTable();
        }
    qualifiedTableName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                table,qualifiedTableName);
        }
    [ <LPAREN> ForeignTableElementList(table) <RPAREN> ]
        {
        }
    server = DataServerReference()
        {
            server.getColumnSet().add(table);
        }
    OptionalStorageOptions(table)
        {
        }
    {
        return table;
    }
}

FemForeignTable ForeignTableReference() :
{
    SqlIdentifier qualifiedTableName;
    FemForeignTable table;
}
{
    <FOREIGN> <TABLE> qualifiedTableName = CompoundIdentifier2()
        {
            table = (FemForeignTable)
            farragoParser.getStmtValidator().findSchemaObject(
                qualifiedTableName,
                getRepos().getMedPackage().getFemForeignTable());
        }
    {
        return table;
    }
}

void ForeignTableElementList(FemForeignTable table) :
{
}
{
    ColumnDefinition(table)
    (
        <COMMA>
        ColumnDefinition(table)
    )*
}

void OptionalStorageOptions(FemElementWithStorageOptions element) :
{
}
{
    [
        <OPTIONS>
        <LPAREN>
        StorageOption(element)
        (
            <COMMA>
            StorageOption(element)
        )*
        <RPAREN>
    {
    } ]
}

void StorageOption(FemElementWithStorageOptions element) :
{
    SqlIdentifier name;
    String value;
}
{
    name = SimpleIdentifier()
        {
        }
    value = QuotedString()
        {
        }
    {
        FemStorageOption option = getRepos().newFemStorageOption();
        option.setName(name.getSimple());
        option.setValue(value);
        element.getStorageOptions().add(option);
    }
}

CwmModelElement DataWrapperDrop() :
{
    CwmModelElement wrapper;
}
{
    wrapper = DataWrapperReference()
        {
        }
    CascadeOption()
        {
            return wrapper;
        }
}

CwmModelElement DataServerDrop() :
{
    CwmModelElement server;
}
{
    server = DataServerReference()
        {
        }
    CascadeOption()
        {
            return server;
        }
}

CwmModelElement ForeignTableDrop() :
{
    CwmModelElement table;
}
{
    table = ForeignTableReference()
        {
        }
    CascadeOption()
        {
            return table;
        }
}

/* KEYWORDS:  anything in this list is a reserved word unless it appears
   in the NonReservedKeyWord() production. */

TOKEN :
{
  < CHECKPOINT: "CHECKPOINT" >
| < CLUSTERED: "CLUSTERED" >
| < INDEX: "INDEX" >
| < JAR: "JAR" >
| < TRUNCATE: "TRUNCATE" >
}

/**
 * Parses a non-reserved DDL keyword for use as an identifier.  Parser
 * implementations based on CommonDdlParser.jj should include this as
 * well as CommonParser.jj's CommonNonReservedKeyWord() in their
 * implementation of the NonReservedKeyWord() production.
 *
 *<p>
 *
 * When adding keywords to this list, be sure that they are not reserved
 * by the SQL:2003 standard (see productions for "non-reserved word"
 * and "reserved word" in reference below).
 *
 * @sql.2003 Part 2 Section 5.2
 */
String DdlNonReservedKeyWord() :
{
}
{
    (
          <INDEX>
        | <JAR>
    )
        {
            return getToken(0).image.toUpperCase();
        }
}

// End CommonDdlParser.jj

