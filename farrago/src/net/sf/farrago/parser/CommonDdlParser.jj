
/*****************************************
 * Syntactical Descriptions              *
 *****************************************/


SqlIdentifier CompoundIdentifier2() :
{
    List list = new ArrayList();
    String p;
}
{
    (p = Identifier() {list.add(p);})
    (<DOT> p = Identifier() {list.add(p);})?
    {return new SqlIdentifier(ParserUtil.toStringArray(list),null);}
}

String QuotedString() :
{
    Token t;
}
{
    t = <QUOTED_STRING>
    {
      return ParserUtil.parseString(t.image);
    }
}

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 *
 * @return top-level CWM object affected for DDL statement, or top-level SqlNode
 * for DML or query statement
 */
Object FarragoSqlStmtEof() :
{
    Object obj;
}
{
    (
        obj = DdlStmtEof()
    |
        obj = SqlStmtEof()
    )
        { return obj; }
}

DdlStmt DdlStmtEof() :
{
    CwmModelElement modelElement;
    DdlStmt ddlStmt;
}
{
    (
        ( <CREATE>
          ( 
            modelElement = SchemaDefinition()
            |
            LOOKAHEAD(2)
            modelElement = SchemaObjectDefinition(null)
            |
            modelElement = IndexDefinition(null,null)
            |
            modelElement = DataWrapperDefinition()
            |
            modelElement = DataServerDefinition()
            |
            modelElement = ExtensionModelDefinition()
           )
        {
            ddlStmt = new DdlCreateStmt(modelElement);
        }
        )
        |
        ( <DROP>
        {
            // assume RESTRICT; CascadeOption() may override
            dropRestrict = true;
        }
          (
              modelElement = SchemaDrop()
              |
              LOOKAHEAD(2)
              modelElement = NamedColumnSetDrop()
              |
              modelElement = IndexDrop()
              |
              modelElement = ViewDrop()
              |
              modelElement = RoutineDrop()
              |
              LOOKAHEAD(2)
              modelElement = DataWrapperDrop()
              |
              modelElement = DataServerDrop()
              |
              modelElement = ExtensionModelDrop()
          )
        {
            ddlStmt = new DdlDropStmt(modelElement,dropRestrict);
        }
        )
        |
        ( <TRUNCATE>
          (
              <TABLE> modelElement = TableIdentifier(null)
          )
        {
            ddlStmt = new DdlTruncateStmt(modelElement);
        }
        )
        |
        ( <SET>
          (
              (modelElement = CatalogReference())
              |
              (modelElement = SchemaReference())
          )
        {
            ddlStmt = new DdlSetQualifierStmt(modelElement);
        }
        )
        |
        ( <ALTER> 
          (
              <SYSTEM> <SET> ddlStmt = SystemParamAssignment()
              |
              ddlStmt = ExtensionModelAlter()
          )
        {
        }
        )
        |
        ( <CHECKPOINT> { ddlStmt = new DdlCheckpointStmt(); } )
        |
        ( <COMMIT> { ddlStmt = new DdlCommitStmt(); } )
        |
        ( <ROLLBACK> ddlStmt = Rollback())
        |
        ( <SAVEPOINT> ddlStmt = Savepoint())
        |
        ( <RELEASE> <SAVEPOINT> ddlStmt = ReleaseSavepoint())
    )
        <EOF>
        {
            return ddlStmt;
        }
}

// TODO:  support non-topological order of object definition, e.g. a
// referencing table before a referenced table

CwmSchema SchemaDefinition() :
{
    CwmSchema schema;
    SqlIdentifier schemaName,userName;
}
{
    <SCHEMA> schemaName = CompoundIdentifier2()
        {
            schema = getRepos().newCwmSchema();
            if (schemaName.names.length == 2) {
                CwmCatalog catalog =
                    farragoParser.getStmtValidator().findCatalog(
                        schemaName.names[0]);
                schema.setNamespace(catalog);
                schema.setName(schemaName.names[1]);
            } else {
                schema.setNamespace(
                    farragoParser.getStmtValidator().getDefaultCatalog());
                schema.setName(schemaName.getSimple());
            }
        }
    [ <AUTHORIZATION> userName = SimpleIdentifier() ]
        {
            // TODO:  store userName
        }
    (
        <CREATE>
        SchemaObjectDefinition(schema)
    )*
    {
        // TODO: character set, all that jazz
        return schema;
    }
}


// TODO:  support non-topological order of table element definition, e.g. a
// referencing constraint definition before a referenced column definition

CwmTable TableDefinition(CwmSchema schema) :
{
    FemStoredTable table;
    FemDataServer server = null;
}
{
    (
        table = UnscopedTableDefinition(schema)
        |
        table = ScopedTableDefinition(schema)
    )
        {
        }
    [ server = DataServerReference() ]
        {
        }
    OptionalStorageOptions(table)
        {
        }
    (LOOKAHEAD(2) <CREATE> IndexDefinition(schema,table))*
        {
        }
    {
        if (server == null) {
            server =
                farragoParser.getStmtValidator().getDefaultLocalDataServer();
        }
        table.setServer(server);
        return table;
    }
}

FemLocalTable UnscopedTableDefinition(CwmSchema schema) :
{
    FemLocalTable table;
    SqlIdentifier qualifiedTableName;
}
{
    <TABLE>
        {
            table = getRepos().newFemLocalTable();
        }
    qualifiedTableName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                schema,table,qualifiedTableName);
        }
    <LPAREN> TableElementList(table) <RPAREN>
        {
        }
    {
        return table;
    }
}

FemLocalTable ScopedTableDefinition(CwmSchema schema) :
{
    FemLocalTable table;
    String scope;
    String commitOption;
}
{
    <GLOBAL> <TEMPORARY>
    table = UnscopedTableDefinition(schema)
        {
            table.setTemporary(true);
            
            // TODO:  support LOCAL (as "MODULE")
            scope = "SESSION";
            commitOption = "DELETE";
        }
    [ <ON> <COMMIT>
      (
          <PRESERVE> 
      {
          commitOption = "PRESERVE";
      }
          |
          <DELETE>
      {
          commitOption = "DELETE";
      }
      )
      <ROWS> ]
        {
        }
    {
        // TODO:  define a tag for commitOption, since CWM doesn't have a place
        // for it?
        table.setTemporaryScope(scope + ":COMMIT=" + commitOption);
        return table;
    }
}

CwmView ViewDefinition(CwmSchema schema) :
{
    CwmView view;
    SqlIdentifier qualifiedViewName;
    SqlNode query;
    List columnNameList;
}
{
    <VIEW>
        {
           view = getRepos().newCwmView();
        }
    qualifiedViewName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                schema,view,qualifiedViewName);
        }
    [<LPAREN> columnNameList = SimpleIdentifierCommaList() 
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName = 
                    ((SqlIdentifier) columnNameIter.next()).getSimple();
                CwmColumn column = getRepos().newFemViewColumn();
                column.setName(columnName);
                view.getFeature().add(column);
            }
        }
     <RPAREN>]

    <AS> query = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY)
    {
        // NOTE:  we accept ORDER BY on the view definition, even though
        // that's not standard SQL, and leave it up to the validator to
        // decide what to do with it
        farragoParser.getDdlValidator().setViewText(view, query);
    }
    {
       return view;
    }
}


CwmSqlindex IndexDefinition(CwmSchema schema,CwmTable table) :
{
    CwmSqlindex index;
    SqlIdentifier indexName;
    CwmTable specifiedTable;
    List columnNameList;
    boolean unique = false;
    boolean clustered = false;

    if ((schema == null) && (table != null)) {
        schema = (CwmSchema) table.getNamespace();
    }
}
{
    [ <UNIQUE> { unique = true; } ]
        {
        }
    [ <CLUSTERED> { clustered = true; } ]
        {
        }
    <INDEX>
        {
            index = getRepos().newCwmSqlindex();
        }
    indexName = SimpleIdentifier()
        {
            index.setName(indexName.names[0]);
        }
    <ON> specifiedTable = TableIdentifier(schema)
        {
            if (table == null) {
                table = specifiedTable;
            } else {
                // TODO:  move rule down into validator
                if (table != specifiedTable) {
                    throw FarragoResource.instance().newValidatorIndexBadTable(
                        farragoParser.getDdlValidator().getParserPosString(
                            index));
                }
            }
            getRepos().indexPackage.getIndexSpansClass().add(table,index);
            // REVIEW:  why is this necessary?  shouldn't association above be
            // sufficient?
            index.setSpannedClass(table);
            if (clustered) {
                getRepos().setTagValue(index,"clusteredIndex","");
            }
            index.setUnique(unique);
        }
    <LPAREN> columnNameList = SimpleIdentifierCommaList() <RPAREN>
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).names[0];
                CwmColumn column = farragoParser.getStmtValidator().findColumn(
                    table,columnName);
                CwmSqlindexColumn indexColumn =
                    getRepos().newCwmSqlindexColumn();
                indexColumn.setName(columnName);
                indexColumn.setAscending(Boolean.TRUE);
                indexColumn.setFeature(column);
                indexColumn.setIndex(index);
            }
        }
    {
        return index;
    }
}

CwmTable TableIdentifier(CwmSchema schema) :
{
    SqlIdentifier qualifiedTableName;
    CwmTable table;
}
{
    qualifiedTableName = CompoundIdentifier2()
        {
            table = (CwmTable)
            farragoParser.getStmtValidator().findSchemaObject(
                schema,
                qualifiedTableName,
                getRepos().relationalPackage.getCwmTable());
        }
    {
        return table;
    }
}

CwmView ViewReference(CwmSchema schema) :
{
    SqlIdentifier qualifiedViewName;
    CwmView view;
}
{
    <VIEW> qualifiedViewName = CompoundIdentifier2()
        {
            view = (CwmView) farragoParser.getStmtValidator().findSchemaObject(
                schema,
                qualifiedViewName,
                getRepos().relationalPackage.getCwmView());
        }
    {
        return view;
    }
}

FemRoutine RoutineReference(CwmSchema schema) :
{
    SqlIdentifier qualifiedRoutineName;
    FemRoutine routine;
    boolean specific = false;
    ProcedureType routineType;
}
{
    [ <SPECIFIC> { specific = true; } ]
    (
        <ROUTINE>
    {
        routineType = null;
    }
        | <FUNCTION>
    {
        routineType = ProcedureTypeEnum.FUNCTION;
    }
        | <PROCEDURE>
    {
        routineType = ProcedureTypeEnum.PROCEDURE;
    }
    )
        qualifiedRoutineName = CompoundIdentifier2()
        {
            // TODO jvs 24-Dec-2004: implement lookup by invocation name
            // and signature when !specific
            routine = (FemRoutine)
            farragoParser.getStmtValidator().findSchemaObject(
                schema,
                qualifiedRoutineName,
                getRepos().getSql2003Package().getFemRoutine());

            // REVIEW jvs 29-Dec-2004:  localization in message below
            // is iffy

            // if they specifically asked for a FUNCTION or PROCEDURE,
            // and the object found does not match, pretend we
            // found nothing
            if ((routineType != null) && (routineType != routine.getType())) {
                throw FarragoResource.instance().newValidatorUnknownObject(
                    routineType.toString() + " " +
                    getRepos().getLocalizedObjectName(
                        routine.getNamespace().getName(),
                        routine.getName(),
                        null),
                    getCurrentPosition().toString());
            }
        }
    {
        return routine;
    }
}

void TableElementList(CwmTable table) :
{
}
{
    TableElement(table)
    (
        <COMMA>
        TableElement(table)
    )*
}



CwmModelElement TableElement(CwmTable table) :
{
    CwmModelElement modelElement;
}
{
    (
        modelElement = ColumnDefinition(table)
        |
        modelElement = TableConstraint(table)
    )
        {
            return modelElement;
        }
}

void BasicColumnDefinition(CwmNamedColumnSet table,CwmColumn column) :
{
    SqlIdentifier columnName;
}
{
    columnName = SimpleIdentifier()
        {
            table.getFeature().add(column);
            column.setName(columnName.names[0]);
        }
    TypedElement(column)
        {
        }
}

void TypedElement(CwmColumn column) :
{
    SqlDataTypeSpec dataType;
}
{
    dataType = DataType()
        {
            CwmSqldataType type =
                farragoParser.getStmtValidator().findSqldataType(
                    dataType.getTypeName().getSimple());
            column.setType(type);
            if (dataType.getPrecision() > 0) {
                column.setPrecision(new Integer(dataType.getPrecision()));
            }
            if (dataType.getScale() > 0) {
                column.setScale(new Integer(dataType.getScale()));
            }
            if (dataType.getCharSetName() != null) {
                column.setCharacterSetName(dataType.getCharSetName());
            }
        }
}

CwmColumn ColumnDefinition(CwmTable table) :
{
    FemStoredColumn column;
    SqlNode defaultClause;
}
{
    {
        column = getRepos().newFemStoredColumn();
    }
    BasicColumnDefinition(table,column)
        {
        }
    [
        defaultClause = DefaultClause() 
        {
            CwmExpression defaultExpression =
            getRepos().newCwmExpression();
            defaultExpression.setBody(defaultClause.toSqlString(null));
            defaultExpression.setLanguage("SQL");
            column.setInitialValue(defaultExpression);
        }
    ]
        {
        }
    ( ColumnConstraint(table,column) )*
        {
        }
    OptionalStorageOptions(column)
        {
        }
    {
        return column;
    }
}

SqlNode DefaultClause() :
{
    SqlNode expression;
}
{
    <DEFAULT_KW> (
        // TODO:  allow USER, CURRENT_USER, CURRENT_ROLE, SESSION_USER,
        // SYSTEM_USER, CURRENT_PATH, <datatime value function>,
        // <implicitly typed value specification>
        expression = Literal()
    )
        {
            return expression;
        }
}

CwmModelElement TableConstraint(CwmTable table) :
{
    String constraintName = null;
    CwmUniqueConstraint constraint;
}
{
    [ <CONSTRAINT> constraintName = Identifier() ]
        {
        }
    constraint = TableUniqueConstraint(table)
        {
            if (constraintName != null) {
                constraint.setName(constraintName);
            } else {
                getRepos().generateConstraintName(constraint);
            }
            table.getOwnedElement().add(constraint);
        }
    {
        return constraint;
    }
}

CwmUniqueConstraint TableUniqueConstraint(CwmTable table) :
{
    CwmUniqueConstraint constraint;
    List columnNameList;
}
{
    constraint = UniqueConstraint()
        {
        }
    <LPAREN> columnNameList = SimpleIdentifierCommaList() <RPAREN>
        {
            Iterator columnNameIter = columnNameList.iterator();
            while (columnNameIter.hasNext()) {
                String columnName =
                    ((SqlIdentifier) columnNameIter.next()).names[0];
                CwmColumn column = farragoParser.getStmtValidator().findColumn(
                    table,columnName);
                constraint.getFeature().add(column);
                // TODO:  validate no duplicates
            }
        }
    // TODO:  deferrability, etc.
    {
        return constraint;
    }
}

CwmUniqueConstraint UniqueConstraint() :
{
    CwmUniqueConstraint constraint;
}
{
    (
        <UNIQUE>
    {
        constraint = getRepos().newCwmUniqueConstraint();
    }
        |
        <PRIMARY> <KEY>
    {
        constraint = getRepos().newCwmPrimaryKey();
    }
    )
        {
            constraint.setDeferrability(DeferrabilityTypeEnum.NOT_DEFERRABLE);
            return constraint;
        }
}



void ColumnConstraint(CwmNamedColumnSet table,CwmColumn column) :
{
    CwmUniqueConstraint constraint;
    String constraintName = null;
}
{
    [ <CONSTRAINT> constraintName = Identifier() ]
        {
        }
    (
        <NOT> <NULL>
    {
        column.setIsNullable(NullableTypeEnum.COLUMN_NO_NULLS);
    }
        | constraint = UniqueConstraint()
        {
            constraint.getFeature().add(column);
            table.getOwnedElement().add(constraint);
            if (constraintName != null) {
                constraint.setName(constraintName);
            } else {
                getRepos().generateConstraintName(constraint);
            }
        }
    )
        {
        }
}

CwmModelElement SchemaDrop() :
{
    SqlIdentifier schemaName;
    CwmSchema schema;
}
{
    schema = SchemaReference()
        {
        }
    CascadeOption()
        {
            return schema;
        }
}

CwmCatalog CatalogReference() :
{
    SqlIdentifier catalogName;
}
{
    <CATALOG> catalogName = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findCatalog(
                catalogName.getSimple());
        }
}

CwmSchema SchemaReference() :
{
    SqlIdentifier schemaName;
}
{
    <SCHEMA> schemaName = CompoundIdentifier2()
        {
            return farragoParser.getStmtValidator().findSchema(schemaName);
        }
}

CwmModelElement TableDrop() :
{
    CwmModelElement table;
}
{
    <TABLE> table = TableIdentifier(null)
        {
        }
    CascadeOption()
        {
            return table;
        }
}

CwmModelElement ViewDrop() :
{
    CwmModelElement view;
}
{
    view = ViewReference(null)
        {
        }
    CascadeOption()
        {
            return view;
        }
}

CwmModelElement RoutineDrop() :
{
    CwmModelElement routine;
}
{
    routine = RoutineReference(null)
        {
        }
    CascadeOption()
        {
            return routine;
        }
}

CwmModelElement IndexDrop() :
{
    SqlIdentifier qualifiedIndexName;
}
{
    <INDEX> qualifiedIndexName = CompoundIdentifier2()
        {
            return farragoParser.getStmtValidator().findSchemaObject(
                null,
                qualifiedIndexName,
                getRepos().relationalPackage.getCwmSqlindex());
        }
}

void CascadeOption() :
{
}
{
    [
        (
            <RESTRICT>
        {
            dropRestrict = true;
        }
            | <CASCADE>
        {
            dropRestrict = false;
        }
        )
    ]
}

DdlStmt SystemParamAssignment() :
{
    SqlIdentifier paramName;
    SqlLiteral paramValue;
}
{
    paramName = SimpleIdentifier()
        {
        }
    <EQ>
        {
        }
    paramValue = SystemParamValue()
        {
        }
    {
        return new DdlSetSystemParamStmt(
            paramName.names[0],paramValue);
    }
}

SqlLiteral SystemParamValue() :
{
    SqlLiteral paramValue;
    ParserPosition pos = null;  
}
{
    (
        paramValue = StrictLiteral()
        {
        }
        | <MAX>
        {
            // TODO jvs 22-May-2004:  for MIN and MAX here, use metadata
            // to determine the correct min and max values
            pos = getPos();
            paramValue = SqlLiteral.createExactNumeric("-1", pos);
        }
        | <MIN>
        {
            pos = getPos();
            paramValue = SqlLiteral.createExactNumeric("0", pos);
        }
    )
        {
            return paramValue;
        }
}

DdlStmt Rollback() :
{
    SqlIdentifier savepointName = null;
}
{
    (<TO> <SAVEPOINT> savepointName = SimpleIdentifier() )?
        {
        }
    {
        if (savepointName != null) {
            return new DdlRollbackStmt(savepointName.names[0]);
        } else {
            return new DdlRollbackStmt(null);
        }
    }
}

DdlStmt Savepoint() :
{
    SqlIdentifier savepointName = null;
}
{
    savepointName = SimpleIdentifier()
        {
        }
    {
        return new DdlSavepointStmt(savepointName.names[0]);
    }
}

DdlStmt ReleaseSavepoint() :
{
    SqlIdentifier savepointName = null;
}
{
    savepointName = SimpleIdentifier()
        {
        }
    {
        return new DdlReleaseSavepointStmt(savepointName.names[0]);
    }
}

FemDataWrapper DataWrapperDefinition() :
{
    FemDataWrapper wrapper;
    SqlIdentifier wrapperName;
    String libraryFile;
    boolean isForeign;
}
{
    isForeign = ForeignOpt()
        {
        }
    <DATA> <WRAPPER> wrapperName = SimpleIdentifier()
        {
            wrapper = getRepos().newFemDataWrapper();
            wrapper.setName(wrapperName.getSimple());
            wrapper.setNamespace(
                getRepos().getCwmCatalog(
                    FarragoRepos.SYSBOOT_CATALOG_NAME));
            wrapper.setForeign(isForeign);
        }
    <LIBRARY> libraryFile = QuotedString()
        {
            wrapper.setLibraryFile(libraryFile);
        }
    <LANGUAGE> <JAVA>
        {
            wrapper.setLanguage("JAVA");
        }
    OptionalStorageOptions(wrapper)
        {
        }
    {
        return wrapper;
    }
}

boolean ForeignOpt() :
{
}
{
    <LOCAL>
        {
            return false;
        }
    | <FOREIGN>
        {
            return true;
        }
}

FemDataWrapper DataWrapperReference() :
{
    SqlIdentifier name;
    boolean isForeign;
}
{
    isForeign = ForeignOpt()
        {
        }
    <DATA> <WRAPPER> name = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findDataWrapper(
                name,isForeign);
        }
}

FemDataServer DataServerDefinition() :
{
    FemDataServer server;
    FemDataWrapper wrapper;
    SqlIdentifier serverName;
    String serverType;
    String serverVersion;
}
{
    <SERVER> serverName = SimpleIdentifier()
        {
            server = getRepos().newFemDataServer();
            server.setName(serverName.getSimple());
            server.setNamespace(
                getRepos().getCwmCatalog(
                    FarragoRepos.SYSBOOT_CATALOG_NAME));
        }
    [
        <TYPE> serverType = QuotedString() 
        {
            server.setType(serverType);
        }
    ]
    [
        <VERSION> serverVersion = QuotedString() 
        {
            server.setVersion(serverVersion);
        }
    ]
        {
        }
    wrapper = DataWrapperReference()
        {
            server.setWrapper(wrapper);
        }
    OptionalStorageOptions(server)
        {
        }
    {
        return server;
    }
}

FemRoutine FunctionDefinition(CwmSchema schema) :
{
    FemRoutine function;
    SqlIdentifier qualifiedName;
    FemRoutineParameter returnParam;
}
{
    <FUNCTION> 
        {
            function = getRepos().newFemRoutine();
            function.setType(ProcedureTypeEnum.FUNCTION);
            returnParam = getRepos().newFemRoutineParameter();
            function.setCalledOnNullInput(true);
            function.setParameterStyle(RoutineParameterStyleEnum.RPS_SQL);
        }
    qualifiedName = CompoundIdentifier2()
        {
            // REVIEW jvs 27-Dec-2004:  SQL standard says that
            // specific name is implementation-defined when unspecified.
            // The behavior here is to use the invocation name, which
            // means if there's a conflict with an existing specific name,
            // the CREATE statement will fail.  This forces users to
            // provide specific names when overloads are defined.  An
            // alternative is to generate unique specific names automatically
            // in case of conflict.
            farragoParser.getDdlValidator().setSchemaObjectName(
                schema,function,qualifiedName);
            function.setInvocationName(function.getName());
        }
    <LPAREN> RoutineParamList(function) <RPAREN>
        {
        }
    <RETURNS> TypedElement(returnParam)
        {
            returnParam.setName("RETURN");
            returnParam.setKind(ParameterDirectionKindEnum.PDK_RETURN);
            function.getParameter().add(returnParam);
        }
    RoutineCharacteristics(function)
        {
        }
    [ <STATIC> <DISPATCH> ]
        {
            function.setStaticDispatch(true);
        }
    RoutineBody(function)
        {
        }
    {
        return function;
    }
}

void RoutineBody(FemRoutine routine) :
{
    SqlNode expr;
}
{
    [ <SQL> <SECURITY>
        (
            <INVOKER>
        {
            routine.setImpersonateDefiner(false);
        }
            | <DEFINER>
        {
            routine.setImpersonateDefiner(true);
        }
        )
    ]
        {
        }
        <RETURN> expr = Expression(EXPR_ACCEPT_NONQUERY)
    {
        // TODO jvs 24-Dec-2004: eventually allow subqueries, non-functional
        // routine bodies, and external routines.
        farragoParser.getDdlValidator().setProcedureText(routine, expr);
    }
}

void RoutineCharacteristics(FemRoutine routine) :
{
    SqlIdentifier specificName;
}
{
// TODO jvs 24-Dec-2004:  prevent conflicting declarations
    (
        (<LANGUAGE> (<JAVA> | <SQL>))
    {
        // TODO jvs 24-Dec-2004:  cross-check this with body and sql-access
    }
        | (<PARAMETER> <STYLE>
            (
                <SQL>
            {
                routine.setParameterStyle(
                    RoutineParameterStyleEnum.RPS_SQL);
            }
                | <GENERAL>
            {
                routine.setParameterStyle(
                    RoutineParameterStyleEnum.RPS_GENERAL);
            }
            )
        )
    {
    }
        | (<SPECIFIC> specificName = CompoundIdentifier2())
    {
        if (specificName.names.length > 1) {
            assert(specificName.names.length == 2);
            if (!specificName.names[0].equals(routine.getNamespace().getName()))
            {
                throw FarragoResource.instance().
                    newValidatorRoutineSchemaMismatch(
                        specificName.names[0], 
                        routine.getNamespace().getName(),
                        farragoParser.getDdlValidator().getParserPosString(
                            routine));
            }
            routine.setName(specificName.names[1]);
        } else {
            routine.setName(specificName.getSimple());
        }
    }
        | ( <DETERMINISTIC> )
    {
        routine.setDeterministic(true);
    }
        | ( <NOT> <DETERMINISTIC> )
    {
        routine.setDeterministic(false);
    }
        | (<NO> <SQL>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_NO_SQL);
    }
        | (<CONTAINS> <SQL>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_CONTAINS_SQL);
    }
        | (<READS> <SQL> <DATA>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_READS_SQL_DATA);
    }
        | (<MODIFIES> <SQL> <DATA>)
    {
        routine.setDataAccess(RoutineDataAccessEnum.RDA_MODIFIES_SQL_DATA);
    }
        | (<RETURNS> <NULL> <ON> <NULL> <INPUT>)
    {
        routine.setCalledOnNullInput(false);
    }
        | (<CALLED> <ON> <NULL> <INPUT>)
    {
        routine.setCalledOnNullInput(true);
    }
// TODO jvs 24-Dec-2004:  add characteristics for dynamic result sets
// and savepoint level
    )*
}

void RoutineParamList(FemRoutine routine) :
{
}
{
    RoutineParam(routine)
    (
        <COMMA>
        RoutineParam(routine)
    )*
}

FemRoutineParameter RoutineParam(FemRoutine routine) :
{
    FemRoutineParameter param;
    SqlIdentifier name;
    
    param = getRepos().newFemRoutineParameter();
    routine.getParameter().add(param);
}
{
    {
    }
    [
        (
            <IN>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_IN);
        }
            | <OUT>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_OUT);
        }
            | <INOUT>
        {
            param.setKind(ParameterDirectionKindEnum.PDK_INOUT);
        }
        )
    ]
        {
        }
    name = SimpleIdentifier()
        {
            param.setName(name.getSimple());
        }
    TypedElement(param)
        {
        }
    {
        return param;
    }
}

FemDataServer DataServerReference() :
{
    SqlIdentifier name;
}
{
    <SERVER> name = SimpleIdentifier()
        {
            return farragoParser.getStmtValidator().findDataServer(name);
        }
}

FemForeignTable ForeignTableDefinition(CwmSchema schema) :
{
    FemForeignTable table;
    FemDataServer server;
    SqlIdentifier qualifiedTableName;
}
{
    <FOREIGN> <TABLE>
        {
            table = getRepos().newFemForeignTable();
        }
    qualifiedTableName = CompoundIdentifier2()
        {
            farragoParser.getDdlValidator().setSchemaObjectName(
                schema,table,qualifiedTableName);
        }
    [ <LPAREN> ForeignTableElementList(table) <RPAREN> ]
        {
        }
    server = DataServerReference()
        {
            server.getColumnSet().add(table);
        }
    OptionalStorageOptions(table)
        {
        }
    {
        return table;
    }
}

FemForeignTable ForeignTableReference(CwmSchema schema) :
{
    SqlIdentifier qualifiedTableName;
    FemForeignTable table;
}
{
    <FOREIGN> <TABLE> qualifiedTableName = CompoundIdentifier2()
        {
            table = (FemForeignTable)
            farragoParser.getStmtValidator().findSchemaObject(
                schema,
                qualifiedTableName,
                getRepos().medPackage.getFemForeignTable());
        }
    {
        return table;
    }
}

void ForeignTableElementList(FemForeignTable table) :
{
}
{
    ColumnDefinition(table)
    (
        <COMMA>
        ColumnDefinition(table)
    )*
}

void OptionalStorageOptions(FemElementWithStorageOptions element) :
{
}
{
    [
        <OPTIONS>
        <LPAREN>
        StorageOption(element)
        (
            <COMMA>
            StorageOption(element)
        )*
        <RPAREN>
    {
    } ]
}

void StorageOption(FemElementWithStorageOptions element) :
{
    SqlIdentifier name;
    String value;
}
{
    name = SimpleIdentifier()
        {
        }
    value = QuotedString()
        {
        }
    {
        FemStorageOption option = getRepos().newFemStorageOption();
        option.setName(name.getSimple());
        option.setValue(value);
        element.getStorageOptions().add(option);
    }
}

CwmModelElement DataWrapperDrop() :
{
    CwmModelElement wrapper;
}
{
    wrapper = DataWrapperReference()
        {
        }
    CascadeOption()
        {
            return wrapper;
        }
}

CwmModelElement DataServerDrop() :
{
    CwmModelElement server;
}
{
    server = DataServerReference()
        {
        }
    CascadeOption()
        {
            return server;
        }
}

CwmModelElement ForeignTableDrop() :
{
    CwmModelElement table;
}
{
    table = ForeignTableReference(null)
        {
        }
    CascadeOption()
        {
            return table;
        }
}

/* KEYWORDS:  anything in this list is a reserved word unless it appears
   in the NonReservedKeyWord() production. */

TOKEN :
{
  < ALTER: "alter" >
| < AUTHORIZATION: "authorization" >
| < CALLED: "called" >
| < CASCADE: "cascade" >
| < CATALOG: "catalog" >
| < CHECKPOINT: "checkpoint" >
| < CLUSTERED: "clustered" >
| < COMMIT: "commit" >
| < CONSTRAINT: "constraint" >
| < CONTAINS: "contains" >
| < CREATE: "create" >
| < DATA: "data" >
| < DEFAULT_KW: "default" >
| < DEFINER: "definer" >
| < DETERMINISTIC: "deterministic" >
| < DISPATCH: "dispatch" >
| < DROP: "drop" >
| < EXTERNAL: "external" >
| < FOREIGN: "foreign" >
| < FUNCTION: "function" >
| < GENERAL: "general" >
| < GLOBAL: "global" >
| < INDEX: "index" >
| < INOUT: "inout" >
| < INPUT: "input" >
| < INVOKER: "invoker" >
| < JAVA: "java" >
| < MAX: "max" >
| < MIN: "min" >
| < KEY: "key" >
| < LANGUAGE: "language" >
| < LIBRARY: "library" >
| < LOCAL: "local" >
| < MODIFIES: "modifies" >
| < OPTIONS: "options" >
| < NAME: "name" >
| < NO: "no" >
| < OUT: "out" >
| < PARAMETER: "parameter" >
| < PRESERVE: "preserve" >
| < PRIMARY: "primary" >
| < PROCEDURE: "procedure" >
| < READS: "reads" >
| < RELEASE: "release" >
| < RESTRICT: "restrict" >
| < RETURN: "return" >
| < RETURNS: "returns" >
| < ROLLBACK: "rollback" >
| < ROUTINE: "routine" >
| < SAVEPOINT: "savepoint" >
| < SCHEMA: "schema" >
| < SECURITY: "security" >
| < SERVER: "server" >
| < SPECIFIC: "specific" >
| < SQL: "sql" >
| < STATIC: "static" >
| < STYLE: "style" >
| < SYSTEM: "system" >
| < TEMPORARY: "temporary" >
| < TRUNCATE: "truncate" >
| < TYPE: "type" >
| < VERSION: "version" >
| < VIEW: "view" >
| < WRAPPER: "wrapper" >
}

/**
 * Parses a non-reserved DDL keyword for use as an identifier.  Parser
 * implementations based on CommonDdlParser.jj should include this as
 * well as CommonParser.jj's CommonNonReservedKeyWord() in their
 * implementation of the NonReservedKeyWord() production.
 */
String DdlNonReservedKeyWord() :
{
}
{
    (
        <CALLED>
        | <CASCADE>
        | <CATALOG>
        | <CONTAINS>
        | <DATA>
        | <DEFINER>
        | <DETERMINISTIC>
        | <DISPATCH>
        | <EXTERNAL>
        | <GENERAL>
        | <INDEX>
        | <INPUT>
        | <INVOKER>
        | <JAVA>
        | <KEY>
        | <LIBRARY>
        | <MAX>
        | <MIN>
        | <MODIFIES>
        | <NAME>
        | <NO>
        | <OPTIONS>
        | <PARAMETER>
        | <PRESERVE>
        | <READS>
        | <RESTRICT>
        | <RETURN>
        | <RETURNS>
        | <SCHEMA>
        | <SECURITY>
        | <SERVER>
        | <SPECIFIC>
        | <STATIC>
        | <STYLE>
        | <TEMPORARY>
        | <VERSION>
        | <VIEW>
        | <WRAPPER>
    )
        {
            return getToken(0).image.toUpperCase();
        }
}

// End CommonDdlParser.jj
