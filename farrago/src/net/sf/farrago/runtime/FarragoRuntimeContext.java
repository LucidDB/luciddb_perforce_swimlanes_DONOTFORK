/*
// Farrago is a relational database management system.
// Copyright (C) 2003-2004 John V. Sichi.
// Copyright (C) 2003-2004 Disruptive Tech
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
package net.sf.farrago.runtime;

import java.util.*;
import java.sql.*;

import javax.jmi.reflect.*;

import net.sf.farrago.catalog.*;
import net.sf.farrago.cwm.relational.*;
import net.sf.farrago.fem.fennel.*;
import net.sf.farrago.fem.med.*;
import net.sf.farrago.fennel.*;
import net.sf.farrago.namespace.*;
import net.sf.farrago.namespace.util.*;
import net.sf.farrago.resource.*;
import net.sf.farrago.session.*;
import net.sf.farrago.type.*;
import net.sf.farrago.type.runtime.*;
import net.sf.farrago.util.*;

import org.eigenbase.relopt.*;
import org.eigenbase.util.*;

import java.sql.Date;

/**
 * FarragoRuntimeContext defines runtime support routines needed by generated
 * code.
 *
 * @author John V. Sichi
 * @version $Id$
 */
public class FarragoRuntimeContext extends FarragoCompoundAllocation
    implements FarragoSessionRuntimeContext,
        RelOptConnection,
        FennelJavaStreamMap
{
    //~ Instance fields -------------------------------------------------------

    private FarragoRepos repos;
    private FarragoObjectCache codeCache;
    private Map txnCodeCache;
    private FennelTxnContext fennelTxnContext;
    private Map streamIdToHandleMap = new HashMap();
    private Object [] dynamicParamValues;
    private FarragoCompoundAllocation streamOwner;
    private FarragoSessionIndexMap indexMap;
    private FarragoSessionVariables sessionVariables;
    private FarragoDataWrapperCache dataWrapperCache;
    private FennelStreamGraph streamGraph;
    private long currentTime;

    //~ Constructors ----------------------------------------------------------

    /**
     * Create a new FarragoRuntimeContext.
     *
     * @param params constructor params
     */
    public FarragoRuntimeContext(FarragoSessionRuntimeParams params)
    {
        this.repos = params.repos;
        this.codeCache = params.codeCache;
        this.txnCodeCache = params.txnCodeCache;
        this.fennelTxnContext = params.fennelTxnContext;
        this.indexMap = params.indexMap;
        this.dynamicParamValues = params.dynamicParamValues;
        this.sessionVariables = params.sessionVariables;

        dataWrapperCache =
            new FarragoDataWrapperCache(
                this,
                params.sharedDataWrapperCache,
                params.repos,
                params.fennelTxnContext.getFennelDbHandle());

        streamOwner = new StreamOwner();
    }

    //~ Methods ---------------------------------------------------------------

    // implement RelOptConnection
    public RelOptSchema getRelOptSchema()
    {
        throw new AssertionError();
    }

    // override FarragoCompoundAllocation
    public void closeAllocation()
    {
        // make sure all streams get closed BEFORE they are deallocated
        streamOwner.closeAllocation();
        super.closeAllocation();
    }

    // implement RelOptConnection
    public Object contentsAsArray(
        String qualifier,
        String tableName)
    {
        throw new AssertionError();
    }

    /**
     * Get an object needed to support the implementation of foreign
     * data access.
     *
     * @param serverMofId MOFID of foreign server being accessed
     *
     * @param param server-specific runtime parameter
     *
     * @return server-specific runtime support object
     */
    public Object getDataServerRuntimeSupport(
        String serverMofId,
        Object param)
    {
        FemDataServerImpl femServer =
            (FemDataServerImpl) repos.getMdrRepos().getByMofId(serverMofId);

        FarragoMedDataServer server =
            femServer.loadFromCache(dataWrapperCache);
        try {
            Object obj = server.getRuntimeSupport(param);
            if (obj instanceof FarragoAllocation) {
                addAllocation((FarragoAllocation) obj);
            }
            return obj;
        } catch (Throwable ex) {
            throw FarragoResource.instance().newDataServerRuntimeFailed(ex);
        }
    }

    /**
     * Get the MofId for a RefBaseObject, or null if the object is null.  This
     * is called at execution from code generated by MdrTable.
     *
     * @param refObj RefBaseObject for which to get the MofId
     *
     * @return MofId or null
     */
    public String getRefMofId(RefBaseObject refObj)
    {
        if (refObj == null) {
            return null;
        } else {
            return refObj.refMofId();
        }
    }

    /**
     * Get the value bound to a dynamic parameter.
     *
     * @param paramIndex 0-based index of parameter
     *
     * @return bound value
     */
    public Object getDynamicParamValue(int paramIndex)
    {
        return dynamicParamValues[paramIndex];
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable USER.
     */
    public String getContextVariable_USER()
    {
        return sessionVariables.currentUserName;
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_USER.
     */
    public String getContextVariable_CURRENT_USER()
    {
        return sessionVariables.currentUserName;
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable SYSTEM_USER.
     */
    public String getContextVariable_SYSTEM_USER()
    {
        return sessionVariables.systemUserName;
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable SESSION_USER.
     */
    public String getContextVariable_SESSION_USER()
    {
        return sessionVariables.sessionUserName;
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_ROLE.
     */
    public String getContextVariable_CURRENT_ROLE()
    {
        // TODO jvs 25-Sept-2004:  once supported
        return "";
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_PATH.
     */
    public String getContextVariable_CURRENT_PATH()
    {
        // TODO jvs 25-Sept-2004:  once supported
        return "";
    }

    protected long getCurrentTime()
    {
        // NOTE jvs 25-Sept-2004:  per SQL standard, the same time
        // is used for all references within the same statement.
        if (currentTime == 0) {
            currentTime = System.currentTimeMillis();
        }
        return currentTime;
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_DATE.
     */
    public Date getContextVariable_CURRENT_DATE()
    {
        return new Date(getCurrentTime());
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_TIME.
     */
    public Time getContextVariable_CURRENT_TIME()
    {
        return new Time(getCurrentTime());
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_TIMESTAMP.
     */
    public Timestamp getContextVariable_CURRENT_TIMESTAMP()
    {
        return new Timestamp(getCurrentTime());
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable LOCALTIME.
     */
    public Time getContextVariable_LOCALTIME()
    {
        return getContextVariable_CURRENT_TIME();
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable LOCALTIMESTAMP.
     */
    public Timestamp getContextVariable_LOCALTIMESTAMP()
    {
        return getContextVariable_CURRENT_TIMESTAMP();
    }

    /**
     * Create a JavaTupleStream (for feeding the results of an Iterator to
     * Fennel) and store it in a handle.  This is called at execution from
     * code generated by IteratorToFennelConverter.
     *
     * @param streamId ID for stream (unique within statement)
     * @param tupleWriter FennelTupleWriter for marshalling tuples
     * @param iter row producer
     *
     * @return dummy object
     */
    public Object newJavaTupleStream(
        int streamId,
        FennelTupleWriter tupleWriter,
        Iterator iter)
    {
        JavaTupleStream stream = new JavaTupleStream(tupleWriter, iter);

        streamIdToHandleMap.put(
            new Integer(streamId),
            getFennelDbHandle().allocateNewObjectHandle(this, stream));

        return null;
    }

    /**
     * Stupid helper for code generated by FennelDoubleRel.
     *
     * @param dummy1 a dummy
     * @param dummy2 another dummy
     * @return yet another dummy
     */
    public Object dummyPair(
        Object dummy1,
        Object dummy2)
    {
        assert (dummy1 == null);
        assert (dummy2 == null);
        return null;
    }

    // implement FarragoSessionRuntimeContext
    public void loadFennelPlan(final String xmiFennelPlan)
    {
        assert (streamGraph == null);

        FarragoObjectCache.CachedObjectFactory streamFactory =
            new FarragoObjectCache.CachedObjectFactory() {
                public void initializeEntry(
                    Object key,
                    FarragoObjectCache.UninitializedEntry entry)
                {
                    assert (key.equals(xmiFennelPlan));
                    streamGraph = prepareStreamGraph(xmiFennelPlan);

                    // TODO:  proper memory accounting
                    long memUsage =
                        FarragoUtil.getStringMemoryUsage(xmiFennelPlan);
                    entry.initialize(streamGraph, memUsage);
                }
            };

        FarragoObjectCache.Entry cacheEntry = null;
        if (txnCodeCache != null) {
            cacheEntry =
                (FarragoObjectCache.Entry) txnCodeCache.get(xmiFennelPlan);
        }
        if (cacheEntry == null) {
            // NOTE jvs 15-July-2004:  to avoid deadlock, grab the catalog
            // lock BEFORE we pin the cache entry (this matches the
            // order used by statement preparation)
            repos.beginTransientTxn();
            try {
                cacheEntry = codeCache.pin(xmiFennelPlan, streamFactory, true);
            } finally {
                repos.endTransientTxn();
            }
        }

        if (txnCodeCache == null) {
            addAllocation(cacheEntry);
        } else {
            txnCodeCache.put(xmiFennelPlan, cacheEntry);
        }

        if (streamGraph == null) {
            streamGraph = (FennelStreamGraph) cacheEntry.getValue();
            streamOwner.addAllocation(streamGraph);
        }
    }

    // implement FarragoSessionRuntimeContext
    public void openStreams()
    {
        assert (streamGraph != null);
        streamGraph.open(fennelTxnContext, this);
    }

    /**
     * Create a FennelIterator for executing a plan represented as XML.  This
     * is called at execution from code generated by
     * FennelToIteratorConverter.
     *
     * @param tupleReader object providing FennelTupleReader implementation
     * @param streamName name of stream from which to read
     * @param dummies a dummy parameter to give non-Fennel children a place to
     *        generate code
     *
     * @return iterator
     */
    public Iterator newFennelIterator(
        FennelTupleReader tupleReader,
        String streamName,
        Object dummies)
    {
        assert (dummies == null);
        assert (streamGraph != null);

        FennelStreamHandle streamHandle = getStreamHandle(streamName);

        return new FennelIterator(
            tupleReader,
            streamGraph,
            streamHandle,
            repos.getCurrentConfig().getFennelConfig().getCachePageSize());
    }

    protected FennelStreamHandle getStreamHandle(String globalStreamName)
    {
        repos.beginReposTxn(true);
        try {
            return streamGraph.findStream(repos, globalStreamName);
        } finally {
            repos.endReposTxn(false);
        }
    }

    private FennelStreamGraph prepareStreamGraph(String xmiFennelPlan)
    {
        boolean success = false;
        FennelStreamGraph newStreamGraph = null;
        try {
            Collection collection =
                JmiUtil.importFromXmiString(repos.transientFarragoPackage,
                    xmiFennelPlan);
            assert (collection.size() == 1);
            FemCmdPrepareExecutionStreamGraph cmd =
                (FemCmdPrepareExecutionStreamGraph) collection.iterator().next();

            newStreamGraph = fennelTxnContext.newStreamGraph(streamOwner);
            cmd.setStreamGraphHandle(newStreamGraph.getStreamGraphHandle());
            fennelTxnContext.getFennelDbHandle().executeCmd(cmd);
            success = true;
            return newStreamGraph;
        } finally {
            if (!success) {
                newStreamGraph.closeAllocation();
            }
        }
    }

    // implement FennelJavaStreamMap
    public long getJavaStreamHandle(int streamId)
    {
        FennelJavaHandle handle =
            (FennelJavaHandle) streamIdToHandleMap.get(new Integer(streamId));
        assert (handle != null);
        return handle.getLongHandle();
    }

    // implement FennelJavaStreamMap
    public long getIndexRoot(long pageOwnerId)
    {
        CwmSqlindex index = indexMap.getIndexById(pageOwnerId);
        return indexMap.getIndexRoot(index);
    }

    /**
     * .
     *
     * @return handle to Fennel database being accessed
     */
    public FennelDbHandle getFennelDbHandle()
    {
        return fennelTxnContext.getFennelDbHandle();
    }

    /**
     * Called when a nullable value is cast to a NOT NULL type.
     *
     * @param nullableValue source value
     */
    public void checkNotNull(NullableValue nullableValue)
    {
        if (nullableValue.isNull()) {
            throw FarragoResource.instance().newNullNotAllowed();
        }
    }

    /**
    * Called when a nullable value is cast to a NOT NULL type.
    *
    * @param obj source value
    */
    public void checkNotNull(Object obj)
    {
        if (null == obj) {
            throw FarragoResource.instance().newNullNotAllowed();
        }
    }

    //~ Inner Classes ---------------------------------------------------------

    /**
     * Inner class for taking care of closing streams without deallocating
     * them.
     */
    private static class StreamOwner extends FarragoCompoundAllocation
    {
        public void closeAllocation()
        {
            // traverse in reverse order
            ListIterator iter = allocations.listIterator(allocations.size());
            while (iter.hasPrevious()) {
                FennelStreamGraph streamGraph =
                    (FennelStreamGraph) iter.previous();
                streamGraph.close();
            }
            allocations.clear();
        }
    }
}


// End FarragoRuntimeContext.java
