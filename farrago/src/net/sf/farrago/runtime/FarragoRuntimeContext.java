/*
// Farrago is a relational database management system.
// Copyright (C) 2003-2004 John V. Sichi.
// Copyright (C) 2003-2004 Disruptive Tech
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

package net.sf.farrago.runtime;

import org.eigenbase.relopt.*;
import net.sf.farrago.fennel.*;
import net.sf.farrago.fem.fennel.*;
import net.sf.farrago.fem.med.*;
import net.sf.farrago.cwm.relational.*;
import net.sf.farrago.catalog.*;
import net.sf.farrago.type.*;
import net.sf.farrago.type.runtime.*;
import net.sf.farrago.util.*;
import net.sf.farrago.resource.*;
import net.sf.farrago.session.*;
import net.sf.farrago.namespace.*;
import net.sf.farrago.namespace.util.*;

import org.eigenbase.util.*;

import java.util.*;
import javax.jmi.reflect.*;

/**
 * FarragoRuntimeContext defines runtime support routines needed by generated
 * code.
 *
 * @author John V. Sichi
 * @version $Id$
 */
public class FarragoRuntimeContext
    extends FarragoCompoundAllocation
    implements FarragoSessionRuntimeContext,
        RelOptConnection,
        FennelJavaStreamMap
{
    private FarragoRepos repos;

    private FarragoObjectCache codeCache;

    private Map txnCodeCache;

    private FennelTxnContext fennelTxnContext;

    private Map streamIdToHandleMap = new HashMap();

    private Object [] dynamicParamValues;

    private FarragoCompoundAllocation streamOwner;

    private FarragoIndexMap indexMap;

    private FarragoSessionVariables sessionVariables;

    private FarragoDataWrapperCache dataWrapperCache;

    private FennelStreamGraph streamGraph;

    /**
     * Create a new FarragoRuntimeContext.
     *
     * @param params constructor params
     */
    public FarragoRuntimeContext(
        FarragoSessionRuntimeParams params)
    {
        this.repos = params.repos;
        this.codeCache = params.codeCache;
        this.txnCodeCache = params.txnCodeCache;
        this.fennelTxnContext = params.fennelTxnContext;
        this.indexMap = params.indexMap;
        this.dynamicParamValues = params.dynamicParamValues;
        this.sessionVariables = params.sessionVariables;

        dataWrapperCache = new FarragoDataWrapperCache(
            this,
            params.sharedDataWrapperCache,
            params.repos,
            params.fennelTxnContext.getFennelDbHandle());

        streamOwner = new StreamOwner();
    }

    // implement RelOptConnection
    public RelOptSchema getRelOptSchema()
    {
        throw new AssertionError();
    }

    // override FarragoCompoundAllocation
    public void closeAllocation()
    {
        // make sure all streams get closed BEFORE they are deallocated
        streamOwner.closeAllocation();
        super.closeAllocation();
    }
    
    // implement RelOptConnection
    public Object contentsAsArray(String qualifier,String tableName)
    {
        throw new AssertionError();
    }
    
    /**
     * Get an object needed to support the implementation of foreign
     * data access.
     *
     * @param serverMofId MOFID of foreign server being accessed
     *
     * @param param server-specific runtime parameter
     *
     * @return server-specific runtime support object
     */
    public Object getDataServerRuntimeSupport(
        String serverMofId,
        Object param)
    {
        FemDataServerImpl femServer = (FemDataServerImpl)
            repos.getMdrRepos().getByMofId(serverMofId);

        FarragoMedDataServer server = 
            femServer.loadFromCache(dataWrapperCache);
        try {
            Object obj = server.getRuntimeSupport(param);
            if (obj instanceof FarragoAllocation) {
                addAllocation((FarragoAllocation) obj);
            }
            return obj;
        } catch (Throwable ex) {
            throw FarragoResource.instance().newDataServerRuntimeFailed(ex);
        }
    }

    /**
     * Get the MofId for a RefBaseObject, or null if the object is null.  This
     * is called at execution from code generated by MdrTable.
     *
     * @param refObj RefBaseObject for which to get the MofId
     *
     * @return MofId or null
     */
    public String getRefMofId(RefBaseObject refObj)
    {
        if (refObj == null) {
            return null;
        } else {
            return refObj.refMofId();
        }
    }

    /**
     * Get the value bound to a dynamic parameter.
     *
     * @param paramIndex 0-based index of parameter
     *
     * @return bound value
     */
    public Object getDynamicParamValue(int paramIndex)
    {
        return dynamicParamValues[paramIndex];
    }

    /**
     * Called from generated code.
     *
     * @return the value of context variable USER.
     */
    public String getContextVariable_USER()
    {
        return sessionVariables.currentUserName;
    }
    
    /**
     * Called from generated code.
     *
     * @return the value of context variable CURRENT_USER.
     */
    public String getContextVariable_CURRENT_USER()
    {
        return sessionVariables.currentUserName;
    }
    
    /**
     * Called from generated code.
     *
     * @return the value of context variable SYSTEM_USER.
     */
    public String getContextVariable_SYSTEM_USER()
    {
        return sessionVariables.systemUserName;
    }
    
    /**
     * Called from generated code.
     *
     * @return the value of context variable SESSION_USER.
     */
    public String getContextVariable_SESSION_USER()
    {
        return sessionVariables.sessionUserName;
    }
    
    /**
     * Create a JavaTupleStream (for feeding the results of an Iterator to
     * Fennel) and store it in a handle.  This is called at execution from
     * code generated by IteratorToFennelConverter.
     *
     * @param streamId ID for stream (unique within statement)
     * @param tupleWriter FennelTupleWriter for marshalling tuples
     * @param iter row producer
     *
     * @return dummy object
     */
    public Object newJavaTupleStream(
        int streamId,
        FennelTupleWriter tupleWriter,
        Iterator iter)
    {
        if (!repos.isFennelEnabled()) {
            return null;
        }

        JavaTupleStream stream = new JavaTupleStream(tupleWriter,iter);

        streamIdToHandleMap.put(
            new Integer(streamId),
            getFennelDbHandle().allocateNewObjectHandle(
                this,stream));
                
        return null;
    }

    /**
     * Stupid helper for code generated by FennelDoubleRel.
     *
     * @param dummy1 a dummy
     * @param dummy2 another dummy
     * @return yet another dummy
     */
    public Object dummyPair(Object dummy1,Object dummy2)
    {
        assert(dummy1 == null);
        assert(dummy2 == null);
        return null;
    }

    // implement FarragoSessionRuntimeContext
    public void loadFennelPlan(final String xmiFennelPlan)
    {
        assert(streamGraph == null);
        
        FarragoObjectCache.CachedObjectFactory streamFactory = new
            FarragoObjectCache.CachedObjectFactory()
            {
                public void initializeEntry(
                    Object key,
                    FarragoObjectCache.UninitializedEntry entry)
                {
                    assert(key.equals(xmiFennelPlan));
                    streamGraph = prepareStreamGraph(xmiFennelPlan);
                    // TODO:  proper memory accounting
                    long memUsage = FarragoUtil.getStringMemoryUsage(
                        xmiFennelPlan);
                    entry.initialize(streamGraph,memUsage);
                }
            };

        FarragoObjectCache.Entry cacheEntry = null;
        if (txnCodeCache != null) {
            cacheEntry = (FarragoObjectCache.Entry)
                txnCodeCache.get(xmiFennelPlan);
        }
        if (cacheEntry == null) {
            // NOTE jvs 15-July-2004:  to avoid deadlock, grab the catalog
            // lock BEFORE we pin the cache entry (this matches the
            // order used by statement preparation)
            repos.beginTransientTxn();
            try {
                cacheEntry =
                    codeCache.pin(xmiFennelPlan,streamFactory,true);
            } finally {
                repos.endTransientTxn();
            }
        }

        if (txnCodeCache == null) {
            addAllocation(cacheEntry);
        } else {
            txnCodeCache.put(xmiFennelPlan,cacheEntry);
        }

        if (streamGraph == null) {
            streamGraph = (FennelStreamGraph) cacheEntry.getValue();
            streamOwner.addAllocation(streamGraph);
        }
    }

    // implement FarragoSessionRuntimeContext
    public void openStreams()
    {
        assert(streamGraph != null);
        streamGraph.open(fennelTxnContext,this);
    }

    /**
     * Create a FennelIterator for executing a plan represented as XML.  This
     * is called at execution from code generated by
     * FennelToIteratorConverter.
     *
     * @param tupleReader object providing FennelTupleReader implementation
     * @param streamName name of stream from which to read
     * @param dummies a dummy parameter to give non-Fennel children a place to
     *        generate code
     *
     * @return iterator
     */
    public Iterator newFennelIterator(
        FennelTupleReader tupleReader,
        String streamName,
        Object dummies)
    {
        if (!repos.isFennelEnabled()) {
            return Collections.EMPTY_LIST.iterator();
        }

        assert (dummies == null);
        assert(streamGraph != null);

        FennelStreamHandle streamHandle = getStreamHandle(streamName);
        
        return new FennelIterator(
            tupleReader,
            streamGraph,
            streamHandle,
            repos.getCurrentConfig().getFennelConfig().getCachePageSize());
    }

    protected FennelStreamHandle getStreamHandle(
        String globalStreamName)
    {
        repos.beginReposTxn(true);
        try {
            return streamGraph.findStream(repos,globalStreamName);
        } finally {
            repos.endReposTxn(false);
        }
    }

    private FennelStreamGraph prepareStreamGraph(String xmiFennelPlan)
    {
        boolean success = false;
        FennelStreamGraph newStreamGraph = null;
        try {
            Collection collection = JmiUtil.importFromXmiString(
                repos.transientFarragoPackage,xmiFennelPlan);
            assert (collection.size() == 1);
            FemCmdPrepareExecutionStreamGraph cmd =
                (FemCmdPrepareExecutionStreamGraph)
                collection.iterator().next();

            newStreamGraph = fennelTxnContext.newStreamGraph(streamOwner);
            cmd.setStreamGraphHandle(newStreamGraph.getStreamGraphHandle());
            fennelTxnContext.getFennelDbHandle().executeCmd(cmd);
            success = true;
            return newStreamGraph;
        } finally {
            if (!success) {
                newStreamGraph.closeAllocation();
            }
        }
    }

    // implement FennelJavaStreamMap
    public long getJavaStreamHandle(int streamId)
    {
        FennelJavaHandle handle = (FennelJavaHandle)
            streamIdToHandleMap.get(new Integer(streamId));
        assert(handle != null);
        return handle.getLongHandle();
    }

    // implement FennelJavaStreamMap
    public long getIndexRoot(long pageOwnerId)
    {
        CwmSqlindex index = indexMap.getIndexById(pageOwnerId);
        return indexMap.getIndexRoot(index);
    }
    
    /**
     * .
     *
     * @return handle to Fennel database being accessed
     */
    public FennelDbHandle getFennelDbHandle()
    {
        return fennelTxnContext.getFennelDbHandle();
    }

    /**
     * Called when a nullable value is cast to a NOT NULL type.
     *
     * @param nullableValue source value
     */
    public void checkNotNull(NullableValue nullableValue)
    {
        if (nullableValue.isNull()) {
            throw FarragoResource.instance().newNullNotAllowed();
        }
    }

     /**
     * Called when a nullable value is cast to a NOT NULL type.
     *
     * @param obj source value
     */
    public void checkNotNull(Object obj)
    {
        if (null == obj) {
            throw FarragoResource.instance().newNullNotAllowed();
        }
    }

    /**
     * Inner class for taking care of closing streams without deallocating
     * them.
     */
    private static class StreamOwner extends FarragoCompoundAllocation
    {
        public void closeAllocation()
        {
            // traverse in reverse order
            ListIterator iter = allocations.listIterator(allocations.size());
            while (iter.hasPrevious()) {
                FennelStreamGraph streamGraph = (FennelStreamGraph)
                    iter.previous();
                streamGraph.close();
            }
            allocations.clear();
        }
    }
}

// End FarragoRuntimeContext.java
