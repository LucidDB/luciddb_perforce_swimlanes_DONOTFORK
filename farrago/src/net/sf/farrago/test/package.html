<html>
<head>
<title>Package net.sf.farrago.test</title>
</head>
<body>

Contains Farrago unit tests.

<hr>

<h2>Farrago Unit Testing</h2>

The Farrago unit test framework is based on <a
href="http://www.junit.org">JUnit</a>.  All test cases subclass {@link
net.sf.farrago.test.FarragoTestCase }, which provides Farrago-specific
infrastructure methods (e.g. starting up and shutting down a database
instance automatically).  

<p>

Unit tests can be divided into a number of categories:

<ul>

<li>
Component tests are standard JUnit tests which exercise a single
class in isolation.  Currently there are none of these, but there
should be (e.g. for FarragoObjectCache).

<li>
API tests (e.g. {@link net.sf.farrago.test.FarragoJdbcTest } for the
{@link java.sql JDBC API }) are standard black-box JUnit tests.

<li>
SQL-based tests have no associated Java code (other than a generic
harness class).  Instead, they are implemented as SQL script files
together with reference files containing the expected results.  More
details on their operation are provided below.  SQL-based tests can be
used to test classes which are very difficult to test in isolation due
to large numbers of dependencies.  For example, EXPLAIN PLAN is a good
way to verify that optimizer transformation rules are firing as expected.

</ul>

See also the {@link net.sf.farrago.test.regression regression testing
framework}.

<h3>Diff-based Tests</h3>

In many cases, desired functionality can be verified by producing a
string representing the test result and comparing this with another
string which defines the expected results.  {@link
org.eigenbase.test.DiffTestCase} provides generic diff-based testing
infrastructure.  A specific test case calls the
DiffTestCase.openTestLog() method to get a {@link java.io.Writer}, and
writes its output to this Writer.  The test case then calls the
DiffTestCase.diffTestLog() method to compare the results.  Normally,
the test output is written to the same directory as the .java file for
the test, with a filename like TestClassName.testCaseName.log.  The
expected results must be checked into source control as a file with
the same name except with the extension .ref instead of .log.  If the
test passes, the .log file is deleted automatically.  If the test
fails, the .log file is left behind for diagnostic purposes.  (Old log
files are automatically deleted before testing starts.)  No .dif file
is ever generated; the comparison is performed by Java code.

<p>

When designing diff-based tests, it's important to control for all
variables which could cause spurious failures.  Possible problems are
algorithm non-determinism (for example, a non-stable sort may produce
different sort orders on different machines) and environmental
differences (e.g. a reference to the local machine's name).  Whenever
possible, a diff-based test must prevent these (e.g. by specifying an
ORDER BY clause with a full key for each SQL statement).  (If there
are too many, it's a sign that diff-based testing is inappropriate for
the test case.)  FarragoTestCase also provides a workaround in the
form of the addDiffMask method, which allows the caller to specify a
regular expression to be masked out before diffing.  This should only
be used sparingly.

<h3>SQL Tests</h3>

The harness class {@link net.sf.farrago.test.FarragoSqlTest} works
together with the ant build to find and execute the set of all SQL
scripts to be run.  The ant build defines a fileset containing all
.sql files under the <code>//open/farrago/unitsql</code> directory.
This is passed as a multi-line string of filenames to FarragoSqlTest
via the property <code>net.sf.farrago.fileset.unitsql</code>.  For
each script, FarragoSqlTest invokes <a
href="http://sqlline.sf.net">SqlLine</a> to produce a .log file.  This
is diffed against the .ref file using the diff-based testing support
described above.  However, the .log and .ref files for SQL tests are
stored in the same directory as the source .sql file (rather than
under the src directory).

<p>

Here's an example test script:

<pre><code>
set schema sales;

-- test DISTINCT on a single column
select distinct gender from emps order by 1;
</code></pre>

<p>

And the expected output:

<pre><code>
0: jdbc:farrago:&gt; set schema sales;
0: jdbc:farrago:&gt; 
0: jdbc:farrago:&gt; -- test DISTINCT on a single column
0: jdbc:farrago:&gt; select distinct gender from emps order by 1;
+---------+
| GENDER  |
+---------+
|         |
| F       |
| M       |
+---------+
</code></pre>

<h3>Test Context</h3>

The standard test schema SALES is created and populated by all
developer builds.  See script
<code>//open/dev/farrago/initsql/createSalesSchema.sql</code> for its
definition.  This schema can be read (but not written) by any test
case as a global fixture.

<p>

At the beginning of each test suite (but not each test case),
FarragoTestCase takes care of dropping (with CASCADE) all schemas
other than SALES.  This means that tests can rely on being able to use
any other schema name, and do not have to worry about dropping test
objects on exit.  Tests should not create new objects in the SALES
schema.  For SQL-based tests, each script is its own test suite.  For
Java-based tests, each test class is normally a single suite, while
each method is a test case.  Besides dropping objects at the beginning
of each suite, FarragoTestCase also restores system parameters to their
pre-test state at the end of each test.

<h3>Fennel Tests</h3>

Tests must run successfully when Fennel storage is
available.  Without Fennel storage, many tests are expected to fail.

<h3>Test Utilities</h3>

The "ant test" target rebuilds the catalog and runs all unit tests.
Use "ant junit" to skip the catalog rebuild (but building the catalog
is actually an important test by itself).  You can also run a single
unit test via the junitSingle script located in
<code>//open/dev/farrago</code>.  This script takes a single argument.
If the argument is the name of an existing file, the file is assumed
to be an SQL script and is executed as a diff-based test.  Otherwise,
the argument is assumed to be the unqualified name of a JUnit test
class to be run.

<p>

The junitDebug script operates like the junitSingle script but brings
up the JSwat debugger as well.

<h3>Test Tracing</h3>

Besides test log output, test execution also produces trace
information in the normal location,
<code>//open/dev/farrago/trace/FarragoTrace.log</code>.  (This trace
log is truncated automatically at the beginning of a full run.)
FarragoTestCase inserts trace messages for the beginning and ending of
each test case, making it easier to find a problem in the middle of a
long run.

<h3>Test Data</h3>

Some tests may require external data; there are several ways to handle this:

<ul>

<li>
Check in external datafiles.  For an example, see 
<code>//open/dev/farrago/unitsql/med/csv.sql</code>, which
reads data from <code>example.csv</code> in the same directory.
But please don't check in large datafiles.

<li>
Generate external datafiles from the build.  For an example, see
<code>//open/dev/farrago/unitsql/ddl/med.sql</code>, which reads data
from <code>mdr.*</code> in the same directory (generated by ant target
"createMdrTestData").  This option isn't a good general solution since
it couples the build with testing (TODO: decouple it and make it
easier to use).

<li>
Generate external datafiles from the test itself.  This is the
recommended approach whenever it makes sense (i.e. generated data can
provide the required coverage).  For an example, see {@link
net.sf.farrago.test.regression.FarragoSorterTest}.  This test also
demonstrates how a Java-based test can use a companion .sql script for
setup-only purposes.  Data should be generated in a test-specific
directory under <code>//open/dev/farrago/testgen</code>.

</ul>

</body>
</html>
