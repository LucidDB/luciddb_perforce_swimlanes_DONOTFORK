/*
// $Id$
// Saffron preprocessor and data engine
// (C) Copyright 2002-2004 Disruptive Tech
// (C) Copyright 2002-2004 John V. Sichi
// You must accept the terms in LICENSE.html to use this software.
//
// This file contains the heart of a parser for SQL SELECT statements.
// code can be shared between various parsers (for example, a DDL parser and a
// DML parser) but is not a standalone JavaCC file. You need to prepend a
// parser declaration (such as that in Parser.jj).
*/

/* Epsilon */
JAVACODE
void E() {}

JAVACODE List startList(Object o)
{
    List list = new ArrayList();
    list.add(o);
    return list;
}

/*
 * NOTE jvs 6-Feb-2004: The straightforward way to implement the SQL grammar is
 * to keep query expressions (SELECT, UNION, etc) separate from row expressions
 * (+, LIKE, etc).  However, this is not possible with an LL(k) parser, because
 * both kinds of expressions allow parenthesization, so no fixed amount of left
 * context is ever good enough.  A subquery can be a leaf in a row expression,
 * and can include operators like UNION, so it's not even possible to use a
 * syntactic lookahead rule like "look past an indefinite number of parentheses
 * until you see SELECT, VALUES, or TABLE" (since at that point we still
 * don't know whether we're parsing a subquery like ((select ...) + x)
 * vs. (select ... union select ...).
 *
 * The somewhat messy solution is to unify the two kinds of expression,
 * and to enforce syntax rules using parameterized context.  This
 * is the purpose of the ExprContext parameter.  It is passed to
 * most expression productions, which check the expressions encountered
 * against the context for correctness.  When a query
 * element like SELECT is encountered, the production calls
 * checkQueryExpression, which will throw an exception if
 * a row expression was expected instead.  When a row expression like
 * IN is encountered, the production calls checkNonQueryExpression
 * instead.  It is very important to understand how this works
 * when modifying the grammar.
 *
 * The commingling of expressions results in some bogus ambiguities which are
 * resolved with LOOKAHEAD hints.  The worst example is comma.  SQL allows both
 * (WHERE x IN (1,2)) and (WHERE x IN (select ...)).  This means when we parse
 * the right-hand-side of an IN, we have to allow any kind of expression inside
 * the parentheses.  Now consider the expression "WHERE x IN(SELECT a FROM b
 * GROUP BY c,d)".  When the parser gets to "c,d" it doesn't know whether the
 * comma indicates the end of the GROUP BY or the end of one item in an IN
 * list.  Luckily, we know that select and comma-list are mutually exclusive
 * within IN, so we use maximal munch for the GROUP BY comma.  However, this
 * usage of hints could easily mask unintended ambiguities resulting from
 * future changes to the grammar, making it very brittle.
 */

JAVACODE ParserPosition getPos()
{
    return new ParserPosition(
            token.beginLine,
            token.beginColumn);
}

JAVACODE String getPositionString()
{
    return EigenbaseResource.instance().
        getParserContext(new Integer(token.beginLine),
                         new Integer(token.beginColumn));
}

JAVACODE void checkQueryExpression(ExprContext exprContext)
{
    if ((exprContext == EXPR_ACCEPT_NONQUERY)
        || (exprContext == EXPR_ACCEPT_SUBQUERY))
    {
        // REVIEW: I tried to use generateParseException(), but
        // that results in bogus internal errors due to
        // lookahead.
        throw new ParseException(
            "Query expression " + token.image
            + " encountered in illegal context near "
            + getPositionString());
    }
}

JAVACODE void checkNonQueryExpression(ExprContext exprContext)
{
    if (exprContext == EXPR_ACCEPT_QUERY) {
        throw new ParseException(
            "Non-query expression " + token.image
            + " encountered in illegal context near "
            + getPositionString());
    }
}

// The date/time parse utilities have to live here, instead of in the
// ParserUtil class because ParseException is ambigous, and CommonParser has to
// live in multiple packages.

JAVACODE SqlDateLiteral parseDateLiteral(String s, ParserPosition pos) throws ParseException {
    pos = getPos();
    String dateStr = ParserUtil.strip(s, "'");
    Calendar cal = ParserUtil.parseDateFormat(dateStr, ParserUtil.DateFormatStr);
    if (null==cal) {
        EigenbaseResource res = EigenbaseResource.instance();
        String msg = res.getIllegalLiteral("DATE", s, pos.toString(),
                         res.getBadFormat(ParserUtil.DateFormatStr));
        throw new ParseException(msg);
    }
    return SqlLiteral.createDate(cal, pos);
}

JAVACODE SqlTimeLiteral parseTimeLiteral(String s, ParserPosition pos)
    throws ParseException{
    pos = getPos();
    String dateStr = ParserUtil.strip(s, "'");
    ParserUtil.PrecisionTime pt =
        ParserUtil.parsePrecisionDateTimeLiteral(dateStr, ParserUtil.TimeFormatStr);
    if (null==pt) {
        EigenbaseResource res = EigenbaseResource.instance();
        String msg = res.getIllegalLiteral("TIME", s, pos.toString(),
                         res.getBadFormat(ParserUtil.TimeFormatStr));
        throw new ParseException(msg);
    }
    return SqlLiteral.createTime(pt.cal, pt.precision, pos);
}

JAVACODE SqlTimestampLiteral parseTimestampLiteral(String s, ParserPosition pos)
    throws ParseException{
    pos = getPos();
    String dateStr = ParserUtil.strip(s, "'");
    ParserUtil.PrecisionTime pt =
        ParserUtil.parsePrecisionDateTimeLiteral(dateStr, ParserUtil.TimestampFormatStr);
    if (null==pt) {
        EigenbaseResource res = EigenbaseResource.instance();
        String msg = res.getIllegalLiteral("TIMESTAMP", s, pos.toString(),
                         res.getBadFormat(ParserUtil.TimestampFormatStr));
        throw new ParseException(msg);
    }
    return SqlLiteral.createTimestamp(pt.cal, pt.precision, pos);
}

JAVACODE SqlIntervalLiteral parseIntervalLiteral(
    String s,
    SqlIntervalQualifier intervalQualifier) throws ParseException
{
    ParserPosition pos = getPos();
    String intervalStr = ParserUtil.strip(s, "'");
    return SqlLiteral.createInterval(intervalStr, intervalQualifier, pos);
}

/*****************************************
 * Syntactical Descriptions              *
 *****************************************/

/**
 * Parses either a row expression or a query expression with an optional
 * ORDER BY.
 */
SqlNode OrderedQueryOrExpr(ExprContext exprContext) :
{
    SqlNode e;
    SqlNodeList orderBy;
    ParserPosition pos;
}
{
    (

        e = QueryOrExpr(exprContext)
    )
    (
        // use the syntactic type of the expression we just parsed
        // to decide whether ORDER BY makes sense
        orderBy = OrderBy(e.isA(SqlKind.Query))
        {
            pos = getPos();
            e = opTab.orderByOperator.createCall(e,orderBy, pos);
        }
    )?
       {
            return e;
        }
}

/**
 * Parses a leaf in a query expression (SELECT or VALUES).
 */
SqlNode LeafQuery(ExprContext exprContext) :
{
    SqlNode e;
}
{
    {
        // ensure a query is legal in this context
        checkQueryExpression(exprContext);
    }
    e = SqlSelect()
        {
            return e;
        }
    | e = TableConstructor()
        {
            return e;
        }
    | e = ExplicitTable()
        {
            return e;
        }
}

/**
 * Parses a parenthesized query or single row expression.
 */
SqlNode ParenthesizedExpression(ExprContext exprContext) :
{
    SqlNode e;
}
{
    <LPAREN>
    {
        if (exprContext == EXPR_ACCEPT_SUBQUERY) {
            // we've now seen left paren, so queries inside should
            // be allowed as subqueries
            exprContext = EXPR_ACCEPT_ALL;
        }
    }
    e = OrderedQueryOrExpr(exprContext) <RPAREN>
        {
            return e;
        }
}

/**
 * Parses a parenthesized query or comma-list of row expressions.
 *
 *<p>
 *
 * REVIEW jvs 8-Feb-2004: There's a small hole in this production.  It can be
 * used to construct something like
 *
 * <code>WHERE x IN (select count(*) from t where c=d,5)</code>,
 *
 * which should be illegal.  The above is interpreted as equivalent to
 *
 * <code>WHERE x IN ((select count(*) from t where c=d),5)</code>,
 *
 * which is a legal use of a subquery.  The only way to fix the hole is to be
 * able to remember whether a subexpression was parenthesized or not, which
 * means preserving parentheses in the SqlNode tree.  This is probably
 * desirable anyway for use in purely syntactic parsing applications (e.g. SQL
 * pretty-printer).  However, if this is done, it's important to also make
 * isA() on the paren node call down to its operand so that we can
 * always correctly discriminate a query from a row expression.
 */
List ParenthesizedQueryOrCommaList(
    ExprContext exprContext) :
{
    SqlNode e;
    List list = null;
}
{
    <LPAREN>
    {
        if (exprContext == EXPR_ACCEPT_SUBQUERY) {
            // we've now seen left paren, so queries inside should
            // be allowed as subqueries
            exprContext = EXPR_ACCEPT_ALL;
        }
    }
    e = OrderedQueryOrExpr(exprContext)
        {
            list = startList(e);
        }
    (
        <COMMA> {
            // a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        }
        e = Expression(exprContext)
        {
            list.add(e);
        }
    )* <RPAREN>
        {
            return list;
        }
}

/**
 * Parses a query (SELECT, UNION, INTERSECT, EXCEPT, VALUES) followed by the
 * end-of-file symbol.
 */
SqlNode SqlQueryEof() :
{
    SqlNode query;
}
{
    query = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY) (<EOF>) { return query; }
}

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 */
SqlNode SqlStmtEof() :
{
    SqlNode stmt;
}
{
    (
        stmt = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY)
    |
        stmt = SqlExplain()
    |
        stmt = SqlInsert()
    |
        stmt = SqlDelete()
    |
        stmt = SqlUpdate()
    )
    (<EOF>)
    { return stmt; }
}

/**
 * Parses a leaf SELECT expression without ORDER BY.
 */
SqlSelect SqlSelect() :
{
    List keywords = new ArrayList();
    List selectList;
    SqlNode fromClause;
    SqlNode where;
    SqlNode groupBy;
    SqlNode having;
    SqlNodeList windowDecls;
    ParserPosition pos;
}
{
    <SELECT>
    SqlSelectKeywords(keywords)
    (
        <DISTINCT> { keywords.add(new SqlSymbol("DISTINCT", getPos())); }
    |   <ALL> { keywords.add(new SqlSymbol("ALL", getPos())); }
    |   E()
    )
    selectList = SelectList()
    {
        pos = getPos();
    }
    <FROM>
    fromClause = FromClause()
    where = WhereOpt()
    groupBy = GroupByOpt()
    having = HavingOpt()
    windowDecls = WindowOpt()
    {
        return opTab.selectOperator.createCall(
            new SqlNodeList(keywords, pos), new SqlNodeList(selectList,pos),
            fromClause, where, groupBy, having, windowDecls, null, pos);
    }
}

/*
 * Abstract production:
 *
 *    void SqlSelectKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */

/**
 * Parses an EXPLAIN PLAN statement.
 */
SqlNode SqlExplain() :
{
    SqlNode stmt;
    boolean withImplementation = true;
    ParserPosition pos;
}
{
    <EXPLAIN> <PLAN> [ withImplementation = WithImplementation() ] <FOR> (
        stmt = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY)
        {
        }
        | stmt = SqlInsert()
        {
        }
        | stmt = SqlDelete()
        {
        }
        | stmt = SqlUpdate()
        {
        }
    )
        {
            pos = getPos();
            return new SqlExplain(
                opTab.explainOperator,
                stmt,
                SqlLiteral.createBoolean(withImplementation, null), pos);
        }
}

/**
 * Parses modifier for EXPLAIN PLAN.
 */
boolean WithImplementation() :
{
}
{
    (
        <WITH> <IMPLEMENTATION>
    {
        return true;
    }
        |
        <WITHOUT> <IMPLEMENTATION>
    {
        return false;
    }
    )
}

/**
 * Parses an INSERT statement.
 */
SqlNode SqlInsert() :
{
    SqlIdentifier table;
    SqlNode source;
    List columnList = null;
    ParserPosition pos;
    ParserPosition columnListPos = null;
}
{
    <INSERT> <INTO> table = CompoundIdentifier()
        {
            pos = getPos();
        }
    (
        LOOKAHEAD(2)
        <LPAREN>
        columnList = SimpleIdentifierCommaList()
        {
            columnListPos = getPos();
        }
        <RPAREN>
    )?
        {
        }
    source = OrderedQueryOrExpr(EXPR_ACCEPT_QUERY)
        {
        }
    {
        return new SqlInsert(
            opTab.insertOperator,
            table,
            source,
            (columnList != null) ? new SqlNodeList(columnList, columnListPos) : null,
            pos);
    }
}

/**
 * Parses a DELETE statement.
 */
SqlNode SqlDelete() :
{
    SqlIdentifier table;
    SqlNode condition;
    ParserPosition pos;
}
{
    <DELETE>
        {
            pos = getPos();
        }
 <FROM> table = CompoundIdentifier()
        {

        }
    condition = WhereOpt()
        {
        }
    {
        return new SqlDelete(opTab.deleteOperator,table,condition, pos);
    }
}

/**
 * Parses an UPDATE statement.
 */
SqlNode SqlUpdate() :
{
    SqlIdentifier table;
    SqlNode condition;
    SqlNodeList sourceExpressionList;
    SqlNodeList targetColumnList;
    SqlIdentifier id;
    SqlNode exp;
    ParserPosition pos;
}
{
    <UPDATE> table = CompoundIdentifier()
        {
            pos = getPos();
            targetColumnList = new SqlNodeList(pos);
            sourceExpressionList = new SqlNodeList(pos);
        }
    <SET>
         id = SimpleIdentifier()
        {
            targetColumnList.add(id);
        }
    <EQ> exp = Expression(EXPR_ACCEPT_SUBQUERY)
        {
            // TODO:  support DEFAULT also
            sourceExpressionList.add(exp);
        }
    (
        <COMMA>
        id = SimpleIdentifier()
        {
            targetColumnList.add(id);
        }
        <EQ> exp = Expression(EXPR_ACCEPT_SUBQUERY)
        {
            sourceExpressionList.add(exp);
        }
    )*
        {
        }
    condition = WhereOpt()
        {
        }
    {
        return new SqlUpdate(
            opTab.updateOperator,
            table,
            targetColumnList,
            sourceExpressionList,
            condition, pos);
    }
}

/**
 * Parses the select list of a SELECT statement.
 */
List SelectList() :
{
    List list = new ArrayList();
    SqlNode item;
}
{
    item = SelectItem() {list.add(item);}
    ( <COMMA> item = SelectItem() {list.add(item);} )*
    { return list; }
}

/**
 * Parses one item in a select list.
 */
SqlNode SelectItem() :
{
    SqlNode e;
    SqlIdentifier id;
    ParserPosition pos;
}
{
    e = SelectExpression()
    ((<AS>)?
     id = SimpleIdentifier() {
         pos = getPos();
         e = opTab.asOperator.createCall(e, id,  pos); } )?
    {return e;}
}

/**
 * Parses one unaliased expression in a select list.
 */
SqlNode SelectExpression() :
{
    SqlNode e;
    String id;
    ParserPosition pos;
}
{
    LOOKAHEAD(3)
    id = Identifier() <DOT> <STAR>
    {
        pos = getPos();
        return new SqlIdentifier(new String[] {id, "*"}, pos); }
|
    <STAR>
        {
            pos = getPos();
            return new SqlIdentifier("*", pos); }
|
    e = Expression(EXPR_ACCEPT_SUBQUERY) { return e; }
}

// TODO jvs 15-Nov-2003:  SQL standard allows parentheses in the FROM list for
// building up non-linear join trees (e.g. OUTER JOIN two tables, and then INNER
// JOIN the result).  Also note that aliases on paranthesized FROM expressions
// "hide" all table names inside the parentheses (without aliases, they're
// visible).  Should also support UNION JOIN.  Also, CROSS JOIN shouldn't
// permit a join condition.
/**
 * Parses the FROM clause a SELECT.
 */
SqlNode FromClause() :
{
    SqlNode e, e2, condition;
    boolean isNatural;
    SqlJoinOperator.JoinType joinType;
    List list;
    ParserPosition pos;
    ParserPosition joinTypePos;
    ParserPosition naturalPos;
}
{
    e = TableRef()
    (
        (
            <NATURAL> {isNatural = true;}
        |
            {isNatural = false;}
        )
        {
            naturalPos = getPos();
        }
        (
            <JOIN>
            {joinType = SqlJoinOperator.JoinType.Inner;}
        |
            <INNER> <JOIN>
            {joinType = SqlJoinOperator.JoinType.Inner;}
        |
            <LEFT> (<OUTER>)? <JOIN>
            {joinType = SqlJoinOperator.JoinType.Left;}
        |
            <RIGHT> (<OUTER>)? <JOIN>
            {joinType = SqlJoinOperator.JoinType.Right;}
        |
            <FULL> (<OUTER>)? <JOIN>
            {joinType = SqlJoinOperator.JoinType.Full;}
        |
            <CROSS> <JOIN>
            {joinType = SqlJoinOperator.JoinType.Cross;}
        )
        {
            joinTypePos = getPos();
        }
        e2 = TableRef()
        (
            <ON> condition = Expression(EXPR_ACCEPT_SUBQUERY) {
                e = opTab.joinOperator.createCall(e,
                        SqlLiteral.createBoolean(isNatural, naturalPos),
                        SqlLiteral.createFlag(joinType, joinTypePos), e2,
                        SqlLiteral.createFlag(SqlJoinOperator.ConditionType.On, joinTypePos),
                        condition, joinTypePos);
            }
        |
            <USING> <LPAREN> list = SimpleIdentifierCommaList() <RPAREN> {
                pos = getPos();
                e = opTab.joinOperator.createCall(e,
                        SqlLiteral.createBoolean(isNatural, naturalPos),
                        SqlLiteral.createFlag(joinType, joinTypePos), e2,
                        SqlLiteral.createFlag(SqlJoinOperator.ConditionType.Using, joinTypePos),
                        new SqlNodeList(list, pos), joinTypePos);
            }
        |
            {
                e = opTab.joinOperator.createCall(e,
                        SqlLiteral.createBoolean(isNatural, naturalPos),
                        SqlLiteral.createFlag(joinType, joinTypePos), e2,
                        SqlLiteral.createFlag(SqlJoinOperator.ConditionType.On, joinTypePos),
                        null, joinTypePos);
            }
        )
    |
        // NOTE jvs 6-Feb-2004:  See comments at top of file for why
        // hint is necessary here.  I had to use this special semantic
        // lookahead form to get JavaCC to shut up, which makes
        // me even more uneasy.
        LOOKAHEAD({true})
        <COMMA> { pos = getPos(); }
        e2 = TableRef() {
            e = opTab.joinOperator.createCall(e,
                    SqlLiteral.createBoolean(false, pos),
                    SqlLiteral.createFlag(SqlJoinOperator.JoinType.Comma, null),
                    e2,
                    SqlLiteral.createFlag(SqlJoinOperator.ConditionType.On, null),
                    null,
                    pos);
        }
    )*
    {return e;}
}

// TODO jvs 15-Nov-2003: SQL standard allows column aliases on table
// references, e.g. DEPTS AS D1(DEPTNO1,DNAME1); I guess this is syntactic
// sugar to make it easier for query writers to conform to the column name
// uniqueness rules without requiring them to write a nested SELECT, but it
// seems pretty useless for non-trivial tables, since you have to supply names
// for ALL columns at once.
/**
 * Parses a table reference in a FROM clause.
 */
SqlNode TableRef() :
{
    SqlNode tableRef;
    SqlNode over;
    String alias;
    ParserPosition pos;
}
{
    (
        tableRef = CompoundIdentifier()
    |
        tableRef = ParenthesizedExpression(EXPR_ACCEPT_QUERY)
    |
        tableRef = TableConstructor()
    )
    over = TableOverOpt() {
        if (over != null) {
            pos = getPos();
            tableRef = opTab.overOperator.createCall(tableRef, over, pos);
        }
    }
    (
        (<AS>)? alias = Identifier() {
            pos = getPos();
            tableRef = opTab.asOperator.createCall(
                tableRef, new SqlIdentifier(alias, pos), pos);
        }
    )?
    { return tableRef; }
}

/*
 * Abstract production:
 *
 *    SqlNode TableOverOpt()
 *
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */

/**
 * Parses an explicit TABLE t reference.
 */
SqlNode ExplicitTable() :
{
    SqlNode tableRef;
    ParserPosition pos;
}
{
    <TABLE> tableRef = CompoundIdentifier()
        {
            pos = getPos();
            return opTab.explicitTableOperator.createCall(tableRef, pos);
        }
}

/**
 * Parses a VALUES leaf query expression.
 */
SqlNode TableConstructor() :
{
    SqlNodeList rowConstructorList;
    ParserPosition pos;
}
{
    <VALUES>
    {
         pos = getPos();
    }
         rowConstructorList = RowConstructorList(pos)
    {
        return opTab.valuesOperator.createCall(rowConstructorList.toArray(), pos);
    }
}

/**
 * Parses one or more rows in a VALUES expression.
 */
SqlNodeList RowConstructorList(ParserPosition pos) :
{
    SqlNodeList list = new SqlNodeList(pos);
    SqlNode rowConstructor;
}
{
    rowConstructor = RowConstructor() {list.add(rowConstructor);}
    (
        LOOKAHEAD(2)
        <COMMA> rowConstructor = RowConstructor() {list.add(rowConstructor);}
    )*
        {
        }
    {
        return list;
    }
}

/**
 * Parses a row constructor in the context of a VALUES expression.
 */
SqlNode RowConstructor() :
{
    List valueList;
    SqlNode value;
    ParserPosition pos;
}
{
    // hints are necessary here due to common LPAREN prefixes
    (
        // TODO jvs 8-Feb-2004: extra parentheses are accepted here as a hack
        // for unparse, but this is actually invalid SQL; should
        // fix unparse
        LOOKAHEAD(3)
        <LPAREN> <ROW> { pos = getPos(); }
        valueList = ParenthesizedQueryOrCommaList(EXPR_ACCEPT_ALL) <RPAREN>
    |
        LOOKAHEAD(3)
        { pos = getPos(); }
        [
            <ROW>
        ] valueList = ParenthesizedQueryOrCommaList(EXPR_ACCEPT_ALL)
    |
        value = Expression(EXPR_ACCEPT_ALL)
        {
            // NOTE: A bare value here is standard SQL syntax, believe it or
            // not.  Taken together with multi-row table constructors, it leads
            // to very easy mistakes if you forget the parentheses on a
            // single-row constructor.  This is also the reason for the
            // LOOKAHEAD in RowConstructorList().  It would be so much more
            // reasonable to require parentheses.  Sigh.
            valueList = Collections.singletonList(value);
            pos = value.getParserPosition();
        }
    )
        {
            // REVIEW jvs 8-Feb-2004: Should we discriminate between scalar
            // subqueries inside of ROW and row subqueries?  The standard does,
            // but the distinction seems to be purely syntactic.
            return opTab.rowConstructor.createCall(
                ParserUtil.toNodeArray(valueList), pos);
        }
}

/**
 * Parses the optional WHERE clause for SELECT, DELETE, and UPDATE.
 */
SqlNode WhereOpt() :
{
    SqlNode condition;
}
{
    <WHERE> condition = Expression(EXPR_ACCEPT_SUBQUERY) { return condition; }
|
    { return null; }
}

/**
 * Parses the optional GROUP BY clause for SELECT.
 */
SqlNode GroupByOpt() :
{
    List list;
    SqlNode e;
    ParserPosition pos;
}
{
    <GROUP> <BY> e = Expression(EXPR_ACCEPT_SUBQUERY)
    {
        pos = getPos();
        list = startList(e); }
    (
        // NOTE jvs 6-Feb-2004:  See comments at top of file for why
        // hint is necessary here.
        LOOKAHEAD(2)
        <COMMA> e = Expression(EXPR_ACCEPT_SUBQUERY) { list.add(e); }
    )* { return new SqlNodeList(list, pos); }
|
    { return null; }
}

/**
 * Parses the optional HAVING clause for SELECT.
 */
SqlNode HavingOpt() :
{
    SqlNode e;
}
{
    <HAVING> e = Expression(EXPR_ACCEPT_SUBQUERY) { return e; }
|
    { return null; }
}

/**
 * Parses the optional WINDOW clause for SELECT
 */
SqlNodeList WindowOpt() :
{
    SqlIdentifier id;
    SqlNode e;
    List list;
    ParserPosition pos;
}
{
    <WINDOW> id = SimpleIdentifier() <AS> e = WindowSpecification()
        {
            pos = getPos();
            list = startList(e);
        }
    (
        // NOTE jhyde 22-Oct-2004:  See comments at top of file for why
        // hint is necessary here.
        LOOKAHEAD(2)
        <COMMA> SimpleIdentifier() <AS> e = WindowSpecification()
        { list.add(e); }
    )*
    { return new SqlNodeList(list, pos); }
|
    { return null; }
}

/**
 * Parses a window specification.
 */
SqlNode WindowSpecification() :
{
    SqlIdentifier id;
    List list;
    SqlNodeList partitionList;
    SqlNodeList orderList;
    boolean isRows = false;
    SqlNode lowerBound = null, upperBound = null;
    ParserPosition pos;
}
{
    <LPAREN>
    (
        id = SimpleIdentifier()
    |
        { id = null; }
    )
    (
        <PARTITION> <BY> list = SimpleIdentifierCommaList()
        { partitionList = new SqlNodeList(list, getPos()); }
    |
        { partitionList = null; }
    )
    (
        orderList = OrderBy(true)
    |
        { orderList = null; }
    )
    (
        (
            <ROWS> { isRows = true; }
        |
            <RANGE> { isRows = false; }
        )
        (
            <BETWEEN> lowerBound = WindowRange()
            <AND> upperBound = WindowRange()
        |
            lowerBound = WindowRange()
        )
    )?
    <RPAREN> {
        pos = getPos();
        return opTab.windowOperator.createCall(
                id, partitionList, orderList,
                isRows, lowerBound, upperBound, pos);
    }
}

SqlNode WindowRange() :
{
    SqlLiteral literal;
    ParserPosition pos;
}
{
    <CURRENT> <ROW> {
        pos = getPos();
        return opTab.windowOperator.createCurrentRow(pos);
    }
|
    <UNBOUNDED>
    (
        <PRECEDING> {
            pos = getPos();
            return opTab.windowOperator.createUnboundedPreceding(pos);
        }
    |
        <FOLLOWING> {
            pos = getPos();
            return opTab.windowOperator.createUnboundedFollowing(pos);
        }
    )
|
    literal = StrictLiteral()
    (
        <PRECEDING> {
            pos = getPos();
            return opTab.windowOperator.createPreceding(literal, pos);
        }
    |
        <FOLLOWING> {
            pos = getPos();
            return opTab.windowOperator.createFollowing(literal, pos);
        }
    )
}

/**
 * Parses an ORDER BY clause.
 */
SqlNodeList OrderBy(boolean accept) :
{
    List list;
    SqlNode e;
    ParserPosition pos;
}
{
    <ORDER>
         {
             if (!accept) {
                 // Someone told us ORDER BY wasn't allowed here.  So why
                 // did they bother calling us?  To get the correct
                 // parser position for error reporting.
                 throw new ParseException(
                     "ORDER BY unexpected near " + getPositionString());
             }
         }
    <BY> e = OrderItem() { pos = getPos();list = startList(e); }
    (
        // NOTE jvs 6-Feb-2004:  See comments at top of file for why
        // hint is necessary here.
        LOOKAHEAD(2) <COMMA> e = OrderItem() { list.add(e); }
    )* { }
    {
        return new SqlNodeList(list, pos);
    }
}

/**
 * Parses one list item in an ORDER BY clause.
 */
SqlNode OrderItem() :
{
    SqlNode e;
    ParserPosition pos;
}
{
    e = Expression(EXPR_ACCEPT_SUBQUERY)
    (
        <ASC> { return e; }
    |   <ASCENDING> { return e; }
    |   <DESC>
        {
            pos = getPos();
            return opTab.descendingOperator.createCall(e, pos);
        }
    |   <DESCENDING>
        {
            pos = getPos();
            return opTab.descendingOperator.createCall(e, pos);
        }
    |   { return e; }
    )
}

// ----------------------------------------------------------------------------
// Expressions

/**
 * Parses a SQL expression (such as might occur in a WHERE clause) followed by
 * the end-of-file symbol.
 */
SqlNode SqlExpressionEof() :
{
    SqlNode e;
}
{
    e = Expression(EXPR_ACCEPT_SUBQUERY) (<EOF>) { return e; }
}

/**
 * Parses either a row expression or a query expression without ORDER BY.
 */
SqlNode QueryOrExpr(ExprContext exprContext) :
{
    SqlNode e;
    SqlOperator op;
    ParserPosition pos;
    List list;
}
{
    e = LeafQueryOrExpr(exprContext)
        {
            list = startList(e);
        }
    (
        {
            if (!e.isA(SqlKind.Query)) {
                // whoops, expression we just parsed wasn't a query,
                // but we're about to see something like UNION, so
                // force an exception retroactively
                checkNonQueryExpression(EXPR_ACCEPT_QUERY);
            }
        }
        op = BinaryQueryOperator()
        {
            // ensure a query is legal in this context
            pos = getPos();
            checkQueryExpression(exprContext);

        }
        e = LeafQueryOrExpr(EXPR_ACCEPT_QUERY)
        {
            list.add(new ParserUtil.ToTreeListItem(op, pos));
            list.add(e);
        }
    )*
        {
            e = ParserUtil.toTree(list);
            return e;
        }
}

/**
 * Parses either a row expression, a leaf query expression, or
 * a parenthesized expression of any kind.
 */
SqlNode LeafQueryOrExpr(ExprContext exprContext) :
{
    SqlNode e;
}
{
    e = Expression(exprContext)
        {
            return e;
        }
    | e = LeafQuery(exprContext)
        {
            return e;
        }
}

/**
 * Parses a row expression or a parenthesized expression of any kind.
 */
SqlNode Expression(ExprContext exprContext) :
{
    List list;
    SqlNode e;
}
{
    list = Expression2(exprContext)
    {
        e = ParserUtil.toTree(list);
        return e;
    }
}

// TODO jvs 15-Nov-2003:  ANY/ALL

/**
 * Parses a binary row expression, or a parenthesized expression of any
 * kind.
 *
 * <p>The result is as a flat list of operators and operands. The top-level
 * call to get an expression should call {@link #Expression}, but lower-level
 * calls should call this, to give the parser the opos to associate
 * operator calls.
 *
 * <p>For example 'a = b like c = d' should come out '((a = b) like c) = d'
 * because LIKE and '=' have the same precedence, but tends to come out as '(a
 * = b) like (c = d)' because (a = b) and (c = d) are parsed as separate
 * expressions.
 */
List Expression2(ExprContext exprContext) :
{
    List list, list2;
    SqlNode e;
    SqlOperator op;
    ParserPosition pos;
    SqlNodeList orderBy;
}
{
    e = Expression3(exprContext)
    { list = startList(e); }
    (
        (
            LOOKAHEAD(2)
            (
                // Special case for "IN", because RHS of "IN" is the only place
                // that an expression-list is allowed ("exp IN (exp1, exp2)").
                <IN>
                {
                    checkNonQueryExpression(exprContext);
                    pos = getPos();
                    list.add(new ParserUtil.ToTreeListItem(opTab.inOperator,pos));
                }
                list2 = ParenthesizedQueryOrCommaList(EXPR_ACCEPT_ALL)
                {
                    pos = getPos();
                    // special case for stuff like IN (s1 UNION s2)
                    if (list2.size() == 1) {
                        SqlNode item = (SqlNode) list2.get(0);
                        if (item.isA(SqlKind.Query)) {
                            list.add(item);
                        } else {
                            list.add(new SqlNodeList(list2, pos));
                        }
                    } else {
                        list.add(new SqlNodeList(list2, pos));
                    }
                }
            |
                LOOKAHEAD(2)
                {
                    checkNonQueryExpression(exprContext);
                }
                (
                    <NOT> <BETWEEN>
                    {
                        op = opTab.notBetweenOperator;
                        pos = getPos();
                    }
                    [
                        <SYMMETRIC> { op = opTab.symmetricNotBetweenOperator; }
                    |
                        <ASYMMETRIC>
                    ]
                |
                    <BETWEEN>
                    {
                        op = opTab.betweenOperator;
                        pos = getPos();
                    }
                    [
                        <SYMMETRIC> { op = opTab.symmetricBetweenOperator; }
                    |
                        <ASYMMETRIC>
                    ]
                )
                e = Expression3(EXPR_ACCEPT_SUBQUERY)
                {
                    list.add(new ParserUtil.ToTreeListItem(op, pos));
                    list.add(e);
                }
            |
                {
                    checkNonQueryExpression(exprContext);
                    pos = getPos();
                }
                (
                    <NOT>
                    (
                        <LIKE> { op = opTab.notLikeOperator; }
                    |
                        <SIMILAR> <TO> { op = opTab.notSimilarOperator; }
                    )
                |
                    <LIKE> { op = opTab.likeOperator; }
                |
                    <SIMILAR> <TO> { op = opTab.similarOperator; }
                )
                list2 = Expression2(EXPR_ACCEPT_SUBQUERY)
                {
                    list.add(new ParserUtil.ToTreeListItem(op, pos));
                    list.addAll(list2);
                }
                [
                LOOKAHEAD(2)
                <ESCAPE> e = Expression3(EXPR_ACCEPT_SUBQUERY)
                    {
                        pos = getPos();
                        list.add(new ParserUtil.ToTreeListItem(opTab.escapeOperator, pos));
                        list.add(e);
                    }
                ]
            |
                LOOKAHEAD(2) op = BinaryRowOperator()
                {
                    checkNonQueryExpression(exprContext);
                }
                e = Expression3(EXPR_ACCEPT_SUBQUERY)
                {
                    list.add(new ParserUtil.ToTreeListItem(op, getPos()));
                    list.add(e);
                }
            |
                {
                    checkNonQueryExpression(exprContext);
                }
                op = PostfixRowOperator() {
                    list.add(new ParserUtil.ToTreeListItem(op, getPos()));
                }
            )
        )+
        {
            return list;
        }
        |
        {
            return list;
        }
    )
}

/**
 * Parses a unary row expression, or a parenthesized expression of any
 * kind.
 */
SqlNode Expression3(ExprContext exprContext) :
{
    SqlNode e;
    List list;
    SqlPrefixOperator op;
    boolean rowSeen = false;
    ParserPosition pos;
    ParserPosition prefixRowOpPos;
}
{
    op = PrefixRowOperator() {
        prefixRowOpPos = getPos();
        checkNonQueryExpression(exprContext);
    }
    e = Expression3(EXPR_ACCEPT_SUBQUERY) {
        return op.createCall(e,prefixRowOpPos);
    }
|
    e = AtomicRowExpression() {
        checkNonQueryExpression(exprContext);
        return e;
    }
|
    { pos = getPos(); }
    [
        <ROW> {  pos = getPos(); rowSeen = true; }
    ]
    list = ParenthesizedQueryOrCommaList(exprContext) {
        if ((list.size() == 1) && !rowSeen) {
            // interpret as single value or query
            return (SqlNode) (list.get(0));
        } else {
            // interpret as row constructor
            return opTab.rowConstructor.createCall(
                    ParserUtil.toNodeArray(list), pos);
        }
    }
}


/**
 * Parses a COLLATE clause
 */
SqlCollation CollateClause() :
{
    String collation ="";
}
{
    <COLLATE> <COLLATION_NAME> {
        return new SqlCollation(
            getToken(0).image, SqlCollation.Coercibility.Explicit);
    }
}

/**
 * Parses an atomic row expression.
 */
SqlNode AtomicRowExpression() :
{
    SqlNode e;
    ParserPosition whenPos;
    ParserPosition thenPos;
    ParserPosition casePos;
}
{
    e = Literal() { return e; }
|
    e = DynamicParam() { return e; }
|
    LOOKAHEAD(2) e = FunctionCall() { return e; }
|
    e = MultisetConstructor() { return e; }
|
    e = CompoundIdentifier() { return e; }
|
    {
        SqlNode caseIdentifier=null;
        SqlNode elseClause = null;
        List whenList = new ArrayList();
        List thenList = new ArrayList();
        //sorry there is no wishlist
    }
    <CASE>
        {
            casePos = getPos();
        }
        [caseIdentifier = Expression(EXPR_ACCEPT_NONQUERY)]
        (
            <WHEN> e = Expression(EXPR_ACCEPT_NONQUERY)
            {  whenPos = getPos();whenList.add(e); }
            <THEN> e = Expression(EXPR_ACCEPT_NONQUERY)
            {  thenPos = getPos();thenList.add(e); }
        )+
        [<ELSE> elseClause = Expression(EXPR_ACCEPT_NONQUERY)]
    <END>
    {
        return opTab.caseOperator.createCall(caseIdentifier,
                                             new SqlNodeList(whenList, whenPos),
                                             new SqlNodeList(thenList, thenPos),
                                             elseClause, casePos);
    }
}

/**
 * Parses a literal expression, allowing continued string literals.
 * Usually returns an SqlLiteral, but a continued string literal
 * is an SqlCall expression, which concatenates 2 or more string
 * literals; the validator reduces this.
 */
SqlNode Literal() :
{
    SqlNode e;
    ParserPosition pos = getPos();
}
{
    e = NumericLiteral(pos)       { return e; }
|   e = StringLiteral(pos,false)  { return e; }
|   e = SpecialLiteral(pos)       { return e; }
|   e = DateTimeLiteral(pos)      { return e; }
|   e = IntervalLiteral()         { return e; }
}


/**
 * Parses a literal expression, not allowing a continued string literal.
 * Always returns an SqlLiteral. (Some places in the DDL parser expect a simple
 * SqlLiteral.)
 */
SqlLiteral StrictLiteral() :
{
    SqlLiteral lit;
    SqlNode e;
    ParserPosition pos = getPos();
}
{
    lit = NumericLiteral(pos)     { return lit; }
|   e   = StringLiteral(pos,true) { return (SqlLiteral) e; }
|   lit = SpecialLiteral(pos)     { return lit; }
|   lit = DateTimeLiteral(pos)    { return lit; }
|   lit = IntervalLiteral()       { return lit; }
}


/** Parses a numeric literal */
SqlLiteral NumericLiteral(ParserPosition pos) :
{
}
{
    <UNSIGNED_INTEGER_LITERAL> {
        return SqlLiteral.Numeric.createExact(token.image, pos);
    }
|
    <DECIMAL_NUMERIC_LITERAL> {
        return SqlLiteral.Numeric.createExact(token.image, pos);
    }
|
    <APPROX_NUMERIC_LITERAL> {
        return SqlLiteral.Numeric.createApprox(token.image, pos);
    }
}

/** Parse a special literal keyword */
SqlLiteral SpecialLiteral(ParserPosition pos) :
{
}
{
    <TRUE> { return SqlLiteral.createBoolean(true, pos); }
|
    <FALSE> { return SqlLiteral.createBoolean(false, pos); }
|
    <UNKNOWN> { return SqlLiteral.createUnknown(pos); }
|
    <NULL> { return SqlLiteral.createNull(pos); }
}

/**
 * Parses a string literal. Optionally parses a literal continued onto several
 * lines.  For a simple literal, the result is an SqlLiteral.  For a continued
 * literal, the result is an SqlCall expression, which concatenates 2 or more
 * string literals; the validator reduces this.
 * @param pos ParserPosition at start.
 * @param strict when false, allow continued literals; when true, forbid them.
 * @return a literal expression. When strict, returns an SqlLiteral.
 */
SqlNode StringLiteral(ParserPosition pos, boolean strict) :
{
    String p;
    int nfrags = 0;
    List frags = null;
}
{

    // A continued string literal consists of a head fragment and one or more
    // tail fragments. Since comments may occur between the fragments, and
    // comments are special tokens, each fragment is a token. But since spaces
    // or comments may not occur between the prefix and the first quote, the
    // head fragment, with any prefix, is one token.

    <BIT_STRING_LITERAL>
        {
            p = ParserUtil.trim(token.image, "bB'");
            frags = startList(SqlLiteral.BitStringLiteral.create(p, pos));
            nfrags++;
        }
    (
        <QUOTED_STRING>
        {
            try {
                p = ParserUtil.trim(token.image, "'"); // no embedded quotes
                frags.add(SqlLiteral.BitStringLiteral.create(p, getPos()));
                nfrags++;
            } catch (NumberFormatException ex) {
                throw new ParseException(
                    EigenbaseResource.instance().getInvalidBitLiteral(
                        token.image,
                        getPositionString()));
            }
        }
    )*
        {
            assert (nfrags > 0);
            if (nfrags == 1)
                return (SqlLiteral) frags.get(0); // just the head fragment
            else {
                SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]);
                return opTab.litChainOperator.createCall(rands, pos);
            }
        }

|
    <BINARY_STRING_LITERAL> {
        p = ParserUtil.trim(token.image, "xX'");
        frags = startList(SqlLiteral.BinaryStringLiteral.create(p, pos));
        nfrags++;
    }
    (
        <QUOTED_STRING>
       {
           try {
               p = ParserUtil.trim(token.image, "'"); // no embedded quotes
               frags.add(SqlLiteral.BinaryStringLiteral.create(p, getPos()));
               nfrags++;
           } catch (NumberFormatException ex) {
                throw new ParseException(
                    "Invalid binary string "+token.image+ " near "+getPositionString());
           }
       }
    )*
        {
            assert (nfrags > 0);
            if (nfrags == 1)
                return (SqlLiteral) frags.get(0); // just the head fragment
            else {
                SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]);
                return opTab.litChainOperator.createCall(rands, pos);
            }
        }

|
    {
        SqlCollation collation = null;
        String charSet = null;
    }
    (    <PREFIXED_STRING_LITERAL> { charSet = ParserUtil.getCharacterSet(token.image); }
       | <QUOTED_STRING>
    )
        {
            p = ParserUtil.parseString(token.image);
            frags = startList(SqlLiteral.CharString.create(p, charSet, pos));
            nfrags++;
        }
    (
        <QUOTED_STRING>
        {
            p = ParserUtil.parseString(token.image);
            frags.add(SqlLiteral.CharString.create(p, charSet, getPos()));
            nfrags++;
        }
    )*
    [ collation = CollateClause()
        {
            // set the collation of the head fragment: validator will propagate it
            ((SqlLiteral.CharString) frags.get(0)).setCollation(collation);
        }
    ]
        {
            assert (nfrags > 0);
            if (nfrags == 1)
                return (SqlLiteral) frags.get(0); // just the head fragment
            else {
                SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]);
                return opTab.litChainOperator.createCall(rands, pos);
            }
        }
}


/**
 * Parses a date/time literal.
 */
SqlLiteral DateTimeLiteral(ParserPosition pos) :
{
    String  p;
}
{
    <LBRACE_D> <QUOTED_STRING> { p = token.image; } <RBRACE> {
        return parseDateLiteral(p, pos);
    }
|
    <LBRACE_T> <QUOTED_STRING> { p = token.image; } <RBRACE> {
        return parseTimeLiteral(p, pos);
    }
|
    <LBRACE_TS> <QUOTED_STRING> { p = token.image; } <RBRACE> {
        return parseTimestampLiteral(p, pos);
    }
|
    <DATE> <QUOTED_STRING> {
        return parseDateLiteral(token.image, pos);
    }
|
    <TIME> <QUOTED_STRING> {
        return parseTimeLiteral(token.image, pos);
    }
|
    <TIMESTAMP> <QUOTED_STRING> {
        return parseTimestampLiteral(token.image, pos);
    }
}

/** Parse a MULTISET constructor */
SqlNode MultisetConstructor() :
{
    List args;
    SqlNode e;
}
{
    <MULTISET>
    //by enumeration "MULTISET[e0, e1, ..., eN]"
    <LBRACKET> //todo do trigraph aswell ??( ??)
    e = Expression(EXPR_ACCEPT_NONQUERY) { args = startList(e); }
    (
        <COMMA> e = Expression(EXPR_ACCEPT_NONQUERY) { args.add(e); }
    )*
    <RBRACKET>
    {return opTab.multisetOperator.createCall(
                ParserUtil.toNodeArray(args), getPos());}
}

/**
 * Parses an interval literal.
 */
SqlLiteral IntervalLiteral() :
{
    String p;
    SqlIntervalQualifier intervalQualifier;
}
{
    <INTERVAL> <QUOTED_STRING> { p = token.image; }
    intervalQualifier = IntervalQualifer() {
        return parseIntervalLiteral(p, intervalQualifier);
    }
}

SqlIntervalQualifier IntervalQualifer() :
{
    SqlIntervalQualifier.TimeUnit start;
    SqlIntervalQualifier.TimeUnit end = null;
    int startPrec = 0;
    int secondFracPrec = 0;
}
{
(
    <YEAR> [ <LPAREN> startPrec = IntLiteral() <RPAREN> ]
    [ <TO> <MONTH> { end = SqlIntervalQualifier.TimeUnit.Month; } ]
    { start = SqlIntervalQualifier.TimeUnit.Year; }
|
    <MONTH> [ <LPAREN> startPrec = IntLiteral() <RPAREN> ]
    { start = SqlIntervalQualifier.TimeUnit.Month; }
|
    <DAY> [ <LPAREN> startPrec = IntLiteral() <RPAREN> ]
    [ <TO>
    (
      <HOUR> { end = SqlIntervalQualifier.TimeUnit.Hour; }
    | <MINUTE> { end = SqlIntervalQualifier.TimeUnit.Minute; }
    | <SECOND> { end = SqlIntervalQualifier.TimeUnit.Second; }
      [ <LPAREN> secondFracPrec = IntLiteral() <RPAREN> ]
    )
    ]
    { start = SqlIntervalQualifier.TimeUnit.Day; }
|
    <HOUR> [ <LPAREN> startPrec = IntLiteral() <RPAREN> ]
    [ <TO>
    (
      <MINUTE> { end = SqlIntervalQualifier.TimeUnit.Minute; }
    | <SECOND> { end = SqlIntervalQualifier.TimeUnit.Second; }
      [ <LPAREN> secondFracPrec = IntLiteral() <RPAREN> ]
    )
    ]
    { start = SqlIntervalQualifier.TimeUnit.Hour; }
|
    <MINUTE> [ <LPAREN> startPrec = IntLiteral() <RPAREN> ]
    [ <TO>
    (
      <SECOND> { end = SqlIntervalQualifier.TimeUnit.Second; }
      [ <LPAREN> secondFracPrec = IntLiteral() <RPAREN> ]
    )
    ]
    { start = SqlIntervalQualifier.TimeUnit.Minute; }
|
    <SECOND>
    [   <LPAREN> startPrec = IntLiteral()
        [ <COMMA> secondFracPrec = IntLiteral() ]
        <RPAREN>
    ]
    { start = SqlIntervalQualifier.TimeUnit.Second; }
)
    { return new SqlIntervalQualifier(start, startPrec, end, secondFracPrec); }

}

/**
 * Parses a dynamic parameter marker.
 */
SqlDynamicParam DynamicParam() :
{
    ParserPosition pos;
}
{
    <HOOK>
        {
            pos = getPos();
            return new SqlDynamicParam(nDynamicParams++, pos);
        }
}


/**
 * Parses a simple identifier as a string.
 */
String Identifier() :
{
    String kw;
}
{
    (<A> | <IDENTIFIER>) {return getToken(0).image.toUpperCase();}
|
    <QUOTED_IDENTIFIER> { return ParserUtil.strip(getToken(0).image, "\""); }
|
    kw = NonReservedKeyWord() {return kw;}
}

/**
 * Parses a simple identifier as an SqlIdentifier.
 */
SqlIdentifier SimpleIdentifier() :
{
    String p;
    SqlCollation collation=null;
    ParserPosition pos;
}
{
    p = Identifier(){pos = getPos();}
        [collation = CollateClause()]

    {return new SqlIdentifier(p,collation, pos);}
}

/**
 * Parses a comma-separated list of simple identifiers.
 */
List SimpleIdentifierCommaList() :
{
    List list = new ArrayList();
    SqlIdentifier id;
}
{
    id = SimpleIdentifier() {list.add(id);}
    (<COMMA> id = SimpleIdentifier() {list.add(id);})*
    {return list;}
}

/**
 * Parses a compound identifier.
 */
SqlIdentifier CompoundIdentifier() :
{
    List list = new ArrayList();
    String p;
    SqlCollation collation=null;
    ParserPosition pos;
}
{
    (p = Identifier() {pos = getPos();list.add(p);})
    (<DOT> p = Identifier() {list.add(p);})*
    [collation = CollateClause()]
    {return new SqlIdentifier(ParserUtil.toStringArray(list),collation, pos);}
}

//TODO: real parse errors.
int IntLiteral() :
{
    Token t;
}
{
    t = <UNSIGNED_INTEGER_LITERAL>
        {
            try {
                return Integer.parseInt(t.image);
            } catch (NumberFormatException ex) {
                 throw generateParseException();
            }
        }
}

// Type name with optional scale and precision
SqlDataType DataType() :
{
    SqlIdentifier typeName;
    int scale = 0;
    int precision = 0;
    String charSetName = null;
    ParserPosition pos;
}
{
    (
        typeName = TypeName()
        {
            pos = getPos();
        }
        (
            <LPAREN>
            precision = IntLiteral()
            (
                <COMMA>
                scale = IntLiteral()
            )? <RPAREN>
        )?
        (
            <CHARACTER> <SET>
            charSetName = Identifier()
        )?
    )
    {
        return new SqlDataType(typeName, precision, scale, charSetName, pos);
    }
}

// Some SQL type names need special handling due to the fact that they have
// spaces in them but are not quoted.  Note that
// whenever a typename is also a keyword (like CHARACTER), it has to be added
// here.
SqlIdentifier TypeName() :
{
    SqlIdentifier typeName = null;
    ParserPosition pos = getPos();
}
{
    (
        ( <CHARACTER> | <CHAR> { typeName = new SqlIdentifier(SqlTypeName.Char.name, pos); })
        [ <VARYING> { typeName = new SqlIdentifier(SqlTypeName.Varchar.name, pos); } ]
    |   <VARCHAR> { typeName = new SqlIdentifier(SqlTypeName.Varchar.name, pos); }
    |   <DATE> { typeName = new SqlIdentifier(SqlTypeName.Date.name,pos); }
    |   <TIME> { typeName = new SqlIdentifier(SqlTypeName.Time.name,pos); }
    |   <TIMESTAMP> { typeName = new SqlIdentifier(SqlTypeName.Timestamp.name,pos); }
    |   <DECIMAL> { typeName = new SqlIdentifier(SqlTypeName.Decimal.name,pos); }
    |   <BOOLEAN> { typeName = new SqlIdentifier(SqlTypeName.Boolean.name,pos); }
    |   <INTEGER> { typeName = new SqlIdentifier(SqlTypeName.Integer.name,pos); }
    |   <BINARY> { typeName = new SqlIdentifier(SqlTypeName.Binary.name,pos); }
    |   <VARBINARY> { typeName = new SqlIdentifier(SqlTypeName.Varbinary.name,pos); }
    |   <TINYINT> { typeName = new SqlIdentifier(SqlTypeName.Tinyint.name,pos); }
    |   <SMALLINT> { typeName = new SqlIdentifier(SqlTypeName.Smallint.name,pos); }
    |   <BIGINT> { typeName = new SqlIdentifier(SqlTypeName.Bigint.name,pos); }
    |   <REAL> [ <PRECISION> ] { typeName = new SqlIdentifier(SqlTypeName.Real.name,pos); }
    |   <DOUBLE> [ <PRECISION> ] { typeName = new SqlIdentifier(SqlTypeName.Double.name,pos); }
    |   <BIT> { typeName = new SqlIdentifier(SqlTypeName.Bit.name,pos); }
    |   <MULTISET> { typeName = new SqlIdentifier(SqlTypeName.Multiset.name,pos); }

    |   typeName = SimpleIdentifier()

    )
    {
        return typeName;
    }
}


/**
 * Parses a function call expression.
 */
SqlNode FunctionCall() :
{
    String name;
    List args;
    SqlNode e;
    ParserPosition pos;
    ParserPosition starPos;
    ParserPosition namePos;
    SqlDataType dt;
}
{
    //~ FUNCTIONS WITH SPECIAL SYNTAX ---------------------------------------

    (   ("CAST" | "\"CAST\"")
    {
        pos = getPos();
    }
        <LPAREN> e = Expression(EXPR_ACCEPT_SUBQUERY) { args = startList(e); }
                   <AS> dt = DataType() { args.add(dt); }
                   <RPAREN>  {
                        return opTab.castFunc.createCall(
                            ParserUtil.toNodeArray(args), pos);
                    }

    )
|
    (   ("POSITION" | "\"POSITION\"")
    {
        pos = getPos();
    }
        <LPAREN> e = AtomicRowExpression() { args = startList(e); }
                   <IN>    e = Expression(EXPR_ACCEPT_SUBQUERY) { args.add(e);}
                   <RPAREN> {
                        return opTab.positionFunc.createCall(
                            ParserUtil.toNodeArray(args), pos);
                   }
    )
|
    (   ("CONVERT" | "\"CONVERT\"")
    {
        pos = getPos();
    }
        <LPAREN> e = Expression(EXPR_ACCEPT_SUBQUERY)
                            { args = startList(e); }
                   <USING>  name = Identifier()
        {    namePos = getPos();
                                args.add(new SqlIdentifier(name, namePos)); }
                   <RPAREN> {
                        return opTab.convertFunc.createCall(
                            ParserUtil.toNodeArray(args), pos);
                   }
    )
|
    (  ("TRANSLATE" | "\"TRANSLATE\"")
    {
        pos = getPos();
    }
       <LPAREN> e = Expression(EXPR_ACCEPT_SUBQUERY)
                            { args = startList(e); }
                   <USING>  name = Identifier()
                            {  namePos = getPos();
                              args.add(new SqlIdentifier(name, namePos)); }
                   <RPAREN> {
                        return opTab.translateFunc.createCall(
                            ParserUtil.toNodeArray(args),pos);
                   }
    )
|
    (  ("OVERLAY" | "\"OVERLAY\"")
    {
        pos = getPos();
    }
       <LPAREN>  e = Expression(EXPR_ACCEPT_SUBQUERY)
                             { args = startList(e); }
                   <PLACING> e = Expression(EXPR_ACCEPT_SUBQUERY)
                             { args.add(e); }
                   <FROM>    e = Expression(EXPR_ACCEPT_SUBQUERY)
                             { args.add(e); }
                   [<FOR>    e = Expression(EXPR_ACCEPT_SUBQUERY)
                             { args.add(e); }
                   ]
                   <RPAREN> {
                        return opTab.overlayFunc.createCall(
                            ParserUtil.toNodeArray(args),pos);
                   }
    )
|
    (   ("SUBSTRING" | "\"SUBSTRING\"")
    {
        pos = getPos();
    }
        <LPAREN> e = Expression(EXPR_ACCEPT_SUBQUERY)
                             { args = startList(e); }
                    ( <FROM> | <COMMA>)   e = Expression(EXPR_ACCEPT_SUBQUERY)
                                          { args.add(e); }
                    [ (<FOR> | <COMMA>)   e = Expression(EXPR_ACCEPT_SUBQUERY)
                                          { args.add(e); }
                    ]
                    <RPAREN> {
                        return opTab.substringFunc.createCall(
                            ParserUtil.toNodeArray(args), pos);
                    }
    )
|
    {
        SqlLiteral flag = null;
        SqlNode trimChars = null;
    }
    (  ("TRIM" | "\"TRIM\"")
    {
        pos = getPos();
    }
        <LPAREN>
                   [    LOOKAHEAD(2)
                        [   <BOTH> {
                                pos = getPos();
                                flag = org.eigenbase.sql.fun.SqlTrimFunction.Flag.createBoth(pos);
                            }
                        |
                            <TRAILING> {
                                pos = getPos();
                                flag = org.eigenbase.sql.fun.SqlTrimFunction.Flag.createTrailing(pos);
                            }
                        |
                            <LEADING> {
                                pos = getPos();
                                flag = org.eigenbase.sql.fun.SqlTrimFunction.Flag.createLeading(pos);
                            }
                        ]
                        [ trimChars = AtomicRowExpression() ]
                        <FROM> {
                            if (null == flag && null == trimChars) {
                                throw new ParseException(
                                    "'FROM' near " + getPositionString() +
                                    ", without operands preceding it is illegal");
                            }
                        }
                   ]

                   e = AtomicRowExpression()
                   {
                      args = startList(flag);
                      args.add(trimChars);
                      args.add(e);
                   }
                   <RPAREN> {
                        return opTab.trimFunc.createCall(
                            ParserUtil.toNodeArray(args), pos);
                   }
    )
|
    //~ "NORMAL" FUNCTIONS WITHOUT SPECIAL SYNTAX -----------------------------
    (
        name = Identifier()
        {
            pos = getPos();
        }
        (
            LOOKAHEAD(2) <LPAREN> <STAR> { starPos = getPos();} <RPAREN>
            { args = startList(new SqlIdentifier("*", starPos)); }
          | LOOKAHEAD(2) <LPAREN> <RPAREN>
            { args = ParserUtil.emptyList; }
          | args = ParenthesizedQueryOrCommaList(EXPR_ACCEPT_SUBQUERY)

        )

        {
            return opTab.createCall(name, ParserUtil.toNodeArray(args), pos);
        }
    )
|
    //~ JDBC FUNCTION SYNTAX
    (
        <LBRACE_FN>
    {
        pos = getPos();
    }
        (
            // SPECIAL CASE WHEN WE HAVE a {fn insert} call
            <INSERT> { name = getToken(0).image.toUpperCase(); }
            |
            name = Identifier()
        )
        (
            LOOKAHEAD(2) <LPAREN> <STAR> {starPos = getPos();} <RPAREN>
            { args = startList(new SqlIdentifier("*", starPos)); }
          | LOOKAHEAD(2) <LPAREN> <RPAREN>
            { args = ParserUtil.emptyList; }
          | args = ParenthesizedQueryOrCommaList(EXPR_ACCEPT_SUBQUERY)
        )
        <RBRACE>
        {
            return new org.eigenbase.sql.SqlJdbcFunctionCall(name).createCall(
                    ParserUtil.toNodeArray(args), pos);
        }
    )
}

/**
 * Parses a binary query operator like UNION.
 */
SqlBinaryOperator BinaryQueryOperator() :
{
    SqlBinaryOperator op;
}
{
    /* If both the ALL or DISTINCT keywords are missing, DISTINCT is implicit */
    (
    <UNION> { op = opTab.unionOperator; }
        [   <ALL> { op = opTab.unionAllOperator; } |
            <DISTINCT> { op = opTab.unionOperator; }
        ]
    |
    <INTERSECT> { op = opTab.intersectOperator; }
        [   <ALL> { op = opTab.intersectAllOperator; } |
            <DISTINCT> { op = opTab.intersectOperator; }
        ]
    |
    <EXCEPT> { op = opTab.exceptOperator; }
        [   <ALL> { op = opTab.exceptAllOperator; }
         |  <DISTINCT> { op = opTab.exceptOperator; }
        ]
    )
    { return op; }
}

/**
 * Parses a binary multiset operator.
 */
SqlBinaryOperator BinaryMultisetOperator() :
{
    SqlBinaryOperator op;
}
{
    /* If both the ALL or DISTINCT keywords are missing, DISTINCT is implicit */
    (
    <MULTISET>
        (
        <UNION> { op = opTab.multisetUnionOperator; }
            [   <ALL> { op = opTab.multisetUnionAllOperator; } |
                <DISTINCT> { op = opTab.multisetUnionOperator; }
            ]
        |
        <INTERSECT> { op = opTab.multisetIntersectOperator; }
            [   <ALL> { op = opTab.multisetIntersectAllOperator; } |
                <DISTINCT> { op = opTab.multisetIntersectOperator; }
            ]
        |
        <EXCEPT> { op = opTab.multisetExceptOperator; }
            [   <ALL> { op = opTab.multisetExceptAllOperator; }
             |  <DISTINCT> { op = opTab.multisetExceptOperator; }
            ]
        )
    )
    { return op; }
}

/**
 * Parses a binary row operator like AND.
 */
SqlBinaryOperator BinaryRowOperator() :
{
}
{
  <EQ> { return opTab.equalsOperator; }
| <GT> { return opTab.greaterThanOperator; }
| <LT> { return opTab.lessThanOperator; }
| <LE> { return opTab.lessThanOrEqualOperator; }
| <GE> { return opTab.greaterThanOrEqualOperator; }
| <NE> { return opTab.notEqualsOperator; }
| <PLUS> { return opTab.plusOperator; }
| <MINUS> { return opTab.minusOperator; }
| <STAR> { return opTab.multiplyOperator; }
| <SLASH> { return opTab.divideOperator; }
| <CONCAT> { return opTab.concatOperator; }
| <AND> { return opTab.andOperator; }
| <OR> { return opTab.orOperator; }
| <OVERLAPS> { return opTab.overlapsOperator; }
| <IS> <DISTINCT> <FROM> { return opTab.isDistinctFromOperator; }
// <IN> is handled as a special case
| <MEMBER> <OF> { return opTab.memberOfOperator; }
| <SUBMULTISET> <OF> { return opTab.subMultisetOfOperator; }
| { SqlBinaryOperator op;} op = BinaryMultisetOperator() { return op; }
}

/**
 * Parses a prefix row operator like NOT.
 */
SqlPrefixOperator PrefixRowOperator() :
{}
{
  <PLUS> { return opTab.prefixPlusOperator; }
| <MINUS> { return opTab.prefixMinusOperator; }
| <NOT> { return opTab.notOperator; }
| <EXISTS> { return opTab.existsOperator; }
}

/**
 * Parses a postfix row operator like IS NOT NULL.
 */
SqlPostfixOperator PostfixRowOperator() :
{}
{

    <IS>
    (
        <A> <SET> { return opTab.isASetOperator; }
    |
        <NOT>
        (
            <NULL> { return opTab.isNotNullOperator; }
        |   <TRUE> { return opTab.isNotTrueOperator; }
        |   <FALSE> { return opTab.isNotFalseOperator; }
        |   <UNKNOWN> { return opTab.isNotUnknownOperator; }
        )
    |
        (
            <NULL> { return opTab.isNullOperator; }
        |   <TRUE> { return opTab.isTrueOperator; }
        |   <FALSE> { return opTab.isFalseOperator; }
        |   <UNKNOWN> { return opTab.isUnknownOperator; }
        )
    )
}


/* KEYWORDS:  anything in this list is a reserved word unless it appears
   in the NonReservedKeyWord() production. */

TOKEN :
{
  < A: "a" >
| < ALL: "all" >
| < AND: "and" >
| < AS: "as" >
| < ASC: "asc" >
| < ASCENDING: "ascending" >
| < ASYMMETRIC: "asymmetric" >
| < BETWEEN: "between" >
| < BIGINT: "bigint" >
| < BINARY: "binary" >
| < BIT: "bit" >
| < BOOLEAN: "boolean" >
| < BOTH: "both" >
| < BY: "by" >
| < CASE: "case" >
| < CHAR: "char" >
| < CHARACTER: "character" >
| < COLLATE: "collate" >
| < COLLECT: "collect" >
| < CROSS: "cross" >
| < CURRENT: "current" >
| < DATE: "date" >
| < DAY: "day" >
| < DECIMAL: "decimal" >
| < DELETE: "delete" >
| < DESC: "desc" >
| < DESCENDING: "descending" >
| < DISTINCT: "distinct" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < END: "end" >
| < ESCAPE: "escape" >
| < EXCEPT: "except" >
| < EXISTS: "exists" >
| < EXPLAIN: "explain" >
| < FALSE: "false" >
| < FOLLOWING: "following" >
| < FOR: "for" >
| < FROM: "from" >
| < FULL: "full" >
| < GROUP: "group" >
| < HAVING: "having" >
| < HOUR: "hour" >
| < IMPLEMENTATION: "implementation" >
| < IN: "in" >
| < INNER: "inner" >
| < INSERT: "insert" >
| < INTEGER: "integer" >
| < INTERSECT: "intersect" >
| < INTERVAL: "interval" >
| < INTO: "into" >
| < IS: "is" >
| < JOIN: "join" >
| < LEADING: "leading" >
| < LEFT: "left" >
| < LIKE: "like" >
| < MEMBER: "member" >
| < MINUTE: "minute" >
| < MONTH: "month" >
| < MULTISET: "multiset" >
| < NATURAL: "natural" >
| < OF: "of" >
| < OR: "or" >
| < ORDER: "order" >
| < OUTER: "outer" >
| < OVER: "over" >
| < OVERLAPS: "overlaps" >
| < PARTITION: "partition" >
| < PLACING: "placing" >
| < PLAN: "plan" >
| < PRECEDING: "preceding" >
| < PRECISION: "precision" >
| < RANGE: "range" >
| < REAL: "real" >
| < RIGHT: "right" >
| < ROW: "row" >
| < ROWS: "rows" >
| < SECOND: "second" >
| < SELECT: "select" >
| < SET: "set" >
| < SIMILAR: "similar" >
| < SMALLINT: "smallint" >
| < SUBMULTISET: "submultiset" >
| < SYMMETRIC: "symmetric" >
| < TABLE: "table" >
| < THEN: "then" >
| < TIME: "time" >
| < TIMESTAMP: "timestamp" >
| < TIMEZONE_HOUR: "timezone_hour" >
| < TIMEZONE_MINUTE: "timezone_minute" >
| < TINYINT: "tinyint" >
| < TO: "to" >
| < TRAILING: "trailing" >
| < TRUE: "true" >
| < UNBOUNDED: "unbounded" >
| < UNION: "union" >
| < UNKNOWN: "unknown" >
| < UPDATE: "update" >
| < USING: "using" >
| < VALUES: "values" >
| < VARCHAR: "varchar" >
| < VARBINARY: "varbinary" >
| < VARYING: "varying" >
| < WHEN: "when" >
| < WHERE: "where" >
| < WINDOW: "window" >
| < WITH: "with" >
| < WITHOUT: "without" >
| < YEAR: "year" >
| < ZONE: "zone" >
}

/**
 * Parses a non-reserved keyword for use as an identifier.  Specializations
 * of this parser can use this as a base for implementing the
 * NonReservedKeyWord() production.
 */
String CommonNonReservedKeyWord() :
{
}
{
    (
        <ASC>
        | <ASCENDING>
        | <IMPLEMENTATION>
        | <PLAN>
    )
        {
            return getToken(0).image.toUpperCase();
        }
}

/* LITERALS */

TOKEN :
{
    < UNSIGNED_INTEGER_LITERAL: (["0"-"9"])+ >
|
    < APPROX_NUMERIC_LITERAL:
        (<UNSIGNED_INTEGER_LITERAL> | <DECIMAL_NUMERIC_LITERAL>) <EXPONENT> >
|
    < DECIMAL_NUMERIC_LITERAL:
       (["0"-"9"])+(".")?(["0"-"9"])*
      | "."(["0"-"9"])+
    >
|
    < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
    < #HEXDIGIT: ["0"-"9","a"-"f","A"-"F"] >
|
    < #WHITESPACE:
        [ " ","\t","\n","\r","\f" ]
    >
|
    < BIT_STRING_LITERAL: ["b","B"] <QUOTE> (["0","1"])* <QUOTE> >
|
    < BINARY_STRING_LITERAL: ["x","X"] <QUOTE> (<HEXDIGIT>)* <QUOTE> >
|
    < QUOTED_STRING: <QUOTE> ( (~["'","\n","\r"]) | ("''"))* <QUOTE> >
|
    < PREFIXED_STRING_LITERAL: ("_" <CHARSETNAME> | "N") <QUOTED_STRING> >
|
    < #CHARSETNAME: (["a"-"z","A"-"Z","0"-"9"])
                    (["a"-"z","A"-"Z","0"-"9",":",".","-","_"])*
    >
}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(">
| < RPAREN: ")">
| < LBRACE_D: "{" (" ")* ["d","D"] >
| < LBRACE_T: "{" (" ")* ["t","T"] >
| < LBRACE_TS: "{" (" ")* ["t","T"] ["s","S"] >
| < LBRACE_FN: "{" (" ")* ["f","F"] ["n","N"] >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < DOT: "." >
| < COMMA: "," >
}

/* OPERATORS */

TOKEN :
{
  < EQ: "=" >
| < GT: ">" >
| < LT: "<" >
| < HOOK: "?" >
| < COLON: ":" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "<>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < CONCAT: "||" >
| < DOUBLE_PERIOD: ".." >
| < QUOTE: "'" >
}


/*****************************************
 * Lexical Descriptions                  *
 *****************************************/

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
    <"/**" ~["/"]> : IN_FORMAL_COMMENT
}

MORE :
{
    "//" : IN_SINGLE_LINE_COMMENT
|
    "--" : IN_SINGLE_LINE_COMMENT
|
    "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
    <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
    <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
    <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
    < ~[] >
}


/* common words */
TOKEN :
{
  < NOT: "not" >
| < NULL: "null" >
| < UNIQUE: "unique" >
| < ON: "on" >
}


/* IDENTIFIERS */

TOKEN :
{
< COLLATION_NAME:
    (<LETTER>|<DIGIT>)+ (<LETTER>|<DIGIT>|":"|"."|"-"|"_")*
    "$"
    (<LETTER>|"_")+
    ("$" (<LETTER>|<DIGIT>|"_")+)?
  >
|
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < QUOTED_IDENTIFIER:
      "\""
      (   (~["\"","\n","\r"])
        | ("\"\"")
      )*
      "\""
  >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

