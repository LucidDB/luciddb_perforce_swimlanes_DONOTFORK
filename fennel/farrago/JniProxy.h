/*
// $Id$
// Fennel is a relational database kernel.
// Copyright (C) 1999-2004 John V. Sichi.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef Fennel_JniProxy_Included
#define Fennel_JniProxy_Included

#include "fennel/farrago/JniUtil.h"

#include <map>

FENNEL_BEGIN_NAMESPACE

// This file contains the generic support for proxies generated by
// net.sf.farrago.fennel.ProxyGen.

/**
 * JniProxy is the virtual base class for all generated proxies.
 *
 *<p>
 *
 * NOTE: A JniProxy will NOT always have the correct polymorphic type, so it
 * should never be downcast.  Instead, if you need polymorphism, use the
 * visitor infrastructure (see CmdInterpreter and TupleStreamBuilder for
 * examples).
 */
class JniProxy
{
protected:
    // helper for methods which return strings
    std::string constructString(jobject jStringObj)
    {
        jstring jString = reinterpret_cast<jstring>(jStringObj);
        return JniUtil::toStdString(pEnv,jString);
    }
    
public:
    /**
     * The JniEnvRef for the thread in which this proxy operates.
     */
    JniEnvRef pEnv;

    /**
     * The Java object being proxied.
     */
    jobject jObject;
    
    explicit JniProxy();
    
    virtual ~JniProxy();

    /**
     * Initializes this proxy.
     *
     * @param pEnv the JniEnvRef in which this proxy will operate
     *
     * @param jObject the Java object to be proxied
     */
    void init(JniEnvRef pEnv,jobject jObject);

    /**
     * @return name of the Java class instantiated by this proxy
     */
    std::string getClassName()
    {
        jclass jClass = pEnv->GetObjectClass(jObject);
        return JniUtil::getClassName(jClass);
    }
};

/**
 * JniProxyIter is used to access a JniProxy by reference.  Instances are
 * returned by generated accessor methods (for either
 * non-primitive type attributes or association ends).  When the declared
 * cardinality is 0..1, the returned iter may be singular.  When the declared
 * cardinality is 1..1, the returned iter will never be singular.
 *
 *<p>
 *
 * When the returned iter references a collection (either a multi-valued
 * attribute or an association end with cardinality 0..n), it behaves as a
 * forward iterator via operator++.  It becomes singular when the collection is
 * exhausted.
 */
template <class T>
class JniProxyIter : public boost::shared_ptr<T>
{
public:
    jobject jIter;

    explicit JniProxyIter()
        : boost::shared_ptr<T>(new T)
    {
        // by default, no iteration support
        jIter = NULL;
    }

    void operator ++ ()
    {
        assert(jIter);
        get()->jObject = JniUtil::getNextFromIter(get()->pEnv,jIter);
        if (!(get()->jObject)) {
            // iteration exhausted, so become singular
            reset();
        }
    }
};

/**
 * JniProxyVisitor is the base for all classes which need to visit one or more
 * instances of JniProxy polymorphically.
 */
class JniProxyVisitor 
{
public:
    virtual ~JniProxyVisitor();

    /**
     * Handles case when a visitor attempts to visit a proxy whose type's
     * visit method has not been overridden.  Default action is to throw
     * an assertion failure; subclasses may override to ignore or whatever.
     */
    virtual void unhandledVisit();
};

class JniProxyVisitTableBase
{
public:
    /**
     * Abstract functor for calling the correct visit method.
     */
    struct VisitorMethod
    {
        virtual ~VisitorMethod()
        {
        }
        
        virtual void execute(JniProxyVisitor &visitor,JniProxy &) = 0;
    };
    
    /**
     * Use shared_ptr to manage allocation of VisitorMethods.
     */
    typedef boost::shared_ptr<VisitorMethod> SharedVisitorMethod;

    /**
     * Dispatch table type.  The key is the Java class name, and the
     * value is the corresponding visit functor to be called.
     */
    typedef std::map<std::string,SharedVisitorMethod> MethodMap;

    /**
     * The dispatch table.
     */
    MethodMap methodMap;
    
    /**
     * Called by generated code once for each proxy class.
     *
     * @param jClass java.lang.Class for the Java interface being proxied
     *
     * @param pMethod corresponding visit method to call
     */
    void addMethod(jclass jClass,SharedVisitorMethod pMethod)
    {
        // TODO:  make this less MDR-dependent.  ProxyGen passes in a
        // JMI interface, but at runtime we're going to see the name of the
        // real implementation class, so use the class name in the map.
        assert(pMethod);
        methodMap[JniUtil::getClassName(jClass)+"$Impl"] = pMethod;
    }


    /**
     * Accepts a visitor to a proxy object, redirecting it to the correct
     * visit method.
     *
     * @param visitor the visitor to call
     *
     * @param proxy the proxy object to visit; the type of this object
     * determines the visit overload to call
     */
    void accept(JniProxyVisitor &visitor,JniProxy &proxy)
    {
        // NOTE:  it's OK to use operator [] here since it's an error to call
        // with the wrong proxy type, so in the non-error case we should always
        // find something
        std::string className = proxy.getClassName();
        SharedVisitorMethod pMethod = methodMap[className];
        if (!pMethod) {
            throw std::string("error: unknown method for proxy class '") +
                className + "'";
        }
        pMethod->execute(visitor,proxy);
    }
};

/**
 * JniProxyVisitTable implements a template-driven dispatch table for binding
 * proxy types to visit methods.  The Visitor parameter is instantiated by code
 * generation to be a class derived from JniProxyVisitor that declares virtual
 * visit methods for all proxy types.
 *
 *<p>
 *
 * TODO:  see if boost can provide some of this machinery, maybe generalizing
 * to multiple parameters and a return type
 */
template <class Visitor>
class JniProxyVisitTable : public JniProxyVisitTableBase
{
public:
    /**
     * Functor implementation binding a JniProxy subclass (instantiating
     * ProxyImpl) to a Visitor::visit method.
     */
    template<class ProxyImpl>
    struct VisitorMethodImpl : public VisitorMethod
    {
        virtual void execute(JniProxyVisitor &visitor,JniProxy &proxy)
        {
            // This accomplishes an effective downcast by reinstantiating proxy
            // as the correct type.  The abstract proxy and the specific proxy
            // alias the same underlying Java object, but it's important to
            // realize that the proxies themselves don't share the same
            // identity.
            ProxyImpl proxyImpl;
            proxyImpl.init(proxy.pEnv,proxy.jObject);
            // This binds to the correct visit overload.
            Visitor &visitorImpl = dynamic_cast<Visitor &>(visitor);
            visitorImpl.visit(proxyImpl);
        }
    };
};

FENNEL_END_NAMESPACE

#endif

// End JniProxy.h
