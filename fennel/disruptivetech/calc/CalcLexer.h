/*
// $Id$
// Fennel is a library of data storage and processing components.
// Copyright (C) 2004-2005 Disruptive Tech
// Copyright (C) 2005-2005 The Eigenbase Project
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2 of the License, or (at your option)
// any later version approved by The Eigenbase Project.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef Fennel_CalcLexer_Included
#define Fennel_CalcLexer_Included

#include "fennel/disruptivetech/calc/CalcCommon.h"
#include "fennel/disruptivetech/calc/InstructionCommon.h"
#include "fennel/disruptivetech/calc/CalcTypedefs.h"

#ifdef DONOT_INCLUDE_FLEX_HEADER
class CalcYYFlexLexer;
#else
#undef yyFlexLexer
#define yyFlexLexer CalcYYFlexLexer
#include <FlexLexer.h>
#endif

/*FENNEL_BEGIN_NAMESPACE*/

using namespace fennel;

/**
 * CalcTokenUnion is an union of the possible basic types that
 * a token/expression can be in the calculator grammar.
 * CalcTokenUnion is not used directly but as part of the
 * CalcTokenValue.
 */

/* NOTE: Objects with constructor/desctructor/copy not 
 * allowed in union. */
typedef union
{
    double      v_double;
    int64_t     v_int64;
    uint64_t    v_uint64;
    TProgramCounter                 v_pc;
    StandardTypeDescriptorOrdinal   v_type;
    RegisterReference::ERegisterSet v_regset;
    RegisterReference*              p_regref;
    Instruction*                    p_inst;
} CalcTokenUnion;

/**
 * CalcTokenValue is the data type of the sematic values of the tokens.
 * It is used as the YYLTYPE in bison.  Data types that can be part 
 * of a union are defined inside CalcTokenUnion to save space.
 *
 * We use struct instead of the normal union so that we can store 
 * all objects on the stack and don't need to worry about memory allocation.
 */
typedef struct
{
    //! Union of possible data types 
    CalcTokenUnion u;
    //! String representing the OPCODE of the instruction
    //! This is not part of the union because strings cannot be part of a union.
    std::string    v_opcode;
    std::string    v_string;
    std::vector<RegisterReference*> v_register_list;
} CalcTokenValue;

//! CalcYYLocType is now in CalcYYLocType.h

/**
 * CalcLexer is the scanner class used by the assembler to tokenize a
 * calculator program.  The class is automatically generated by flex
 * from CalcLexer.lpp.
 */
class CalcLexer : public CalcYYFlexLexer
{
  public:
      explicit
      //! Constructs a new Calculator Lexer object
      CalcLexer(): CalcYYFlexLexer(), yycolno(1), yylineno(1), yypos(0) {}

      //! The lexical analzyer function.  It scans the input stream, 
      //! consuming tokens, until a rule's action returns a value
      int yylex();

      //! Returns the character position of the next token
      int getPosition() const       { return yypos;   }
      //! Returns the column number of the next token
      int getColumn() const         { return yycolno; }
      //! Returns the location of the current token
      CalcYYLocType&  getLocation() { return yyloc;   }
      //! Returns the semantic value of the current token
      CalcTokenValue& getValue()    { return yylval;  }

      //! Reports a fatal error message by throwing a CalcAssemblerException
      void LexerError(const char* msg);

  protected:
      //! Updates the location of the current token.
      //! The location of the current token is calculated prior to every matched
      //! rule's action as part of the YY_USER_ACTION macro.
      void updateLocation();

      int hex(char ch);
      string hex2string(const char* buf, uint buflen);

      //! The column number of the next token
      int yycolno;
      //! The line number of the next token
      int yylineno;
      //! The character position (starting from 0) of the next token
      int yypos;
      //! The sematic value of the current token
      CalcTokenValue yylval;
      //! The location of the current token
      CalcYYLocType  yyloc;
};

/*FENNEL_END_NAMESPACE */

#endif

// End CalcLexer
