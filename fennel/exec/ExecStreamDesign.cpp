/*
// $Id$
// Fennel is a relational database kernel.
// Copyright (C) 2004-2004 John V. Sichi.
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public License
// as published by the Free Software Foundation; either version 2.1
// of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

FENNEL_BEGIN_CPPFILE("$Id$");

/**
   
<h3>Overview</h3>

This document describes the components making up the ExecStream library,
which is Fennel's infrastructure for execution of queries and 
data manipulation.  The focus is on theory; for practice, see
ExecStreamHowTo.

<h3>ExecStreamGraph Structure</h3>

Fennel queries are physically implemented as dataflow graphs, where
each graph vertex is a specialized execution processor called an
ExecStream (sometimes also referred to as an execution object or XO).
A related collection of streams is manipulated as a unit called an
ExecStreamGraph.  

<p>

Traditional DBMS executors use a tree dataflow structure together with
a simple "iterator" model, where a fetch request on a top-level stream
is implemented by recursively fetching from lower-level streams until
leaves are reached.  Fennel departs from this in two important ways:

<ul>

<li>Non-tree graph structures such as DAG's are allowed.  Currently
cycles are prohibited, but that may change when CONNECT BY query
processing is implemented.  This makes possible non-traditional query
processing such as global query optimization (commonly used subqueries
can be shared by multiple user-level queries).

<li>Instead of relying on implicit scheduling by allowing streams to
invoke each other directly, Fennel streams are completely passive and
never call other streams.  Instead, a separate scheduler object is
responsible for governing dataflow order and invoking streams in
series or in parallel.  This enables a variety of features such
as efficient TOP N query processing, latency/throughput tradeoffs, and
adaptive vertical parallelism.

</ul>

<p>

The diagram below illustrates a graph for carrying out a join query:

<hr>
\image html StreamGraphNoBuffers.gif
<hr>

In this case, the graph structure is a tree, where the "leaves" read
from table storage and produce tuples.  These tuples flow rightward,
getting combined and transformed, until they are emitted by the "root"
node (the <code>Calc</code> stream) and returned to the user who issued
the query.  

<p>

NOTE: the <code>DiskBuffer</code> stream implies additional dataflow
to and from disk, but this external flow is not managed or understood
by the ExecStreamGraph.  It is entirely encapsulated by the 
<code>DiskBuffer</code> stream.

<p>

Here is some common ExecStreamGraph terminology:

<ul>

<em>stream</em>:  a vertex in an ExecStreamGraph.

<em>dataflow</em>:  a directed edge in an ExecStreamGraph.  Streams are
connected by dataflow edges.  In the exapmle diagram, there is no
dataflow between the <code>CartesianJoin</code> and the
<code>Calc</code>, but there is no dataflow between the two instances
of <code>BTreeScan</code>.

<em>upstream</em>:  reachable by traversing dataflow edges in the
opposite direction of the arrows.

<em>downstream</em>:  reachable by traversing dataflow edges in the
direction of the arrows.

<em>producer</em>:  in a dataflow edge, the stream which produces the
data.  In diagrams, the dataflow arrow is oriented so that it
originates with the producer and terminates with the consumer (pointed
to by the arrowhead).  In the example diagram, the
<code>CartesianJoin</code> stream is a producer with respect to the
<code>Calc</code>.  A producer is upstream from its consumer.

<em>consumer</em>:  in a dataflow edge, the stream which consumes the
data generated by the producer.  In the example diagram, the
<code>Calc</code> stream is a consumer with respect to the
<code>CartesianJoin</code>.  A consumer is downstream from its producer.

<em>source</em>:  a vertex which is not a consumer.  In the example
diagram, both instances of <code>BTreeScan</code> are sources.  When
the graph structure is a tree, sources are also referred to as leaves.

<em>sink</em>:  a vertex which is not a producer.  In the example
diagram, the <code>Calc</code> stream is a sink.  When the graph
structure is a tree, the (unique) sink is also referred to as the root.

<em>input</em>: a dataflow edge as seen by its consumer.  Somtimes
also used to refer to the corresponding producer.  In the example
diagram, the edge originating from the <code>CartesianJoin</code> is
an input to the <code>Calc</code>.

<em>output</em>: a dataflow edge as seen by its producer.  Sometimes
also used to refer to the corresponding consumer.  In the example
diagram, the edge originating from a <code>BTreeScan</code> is an
output of that scan.

</ul>

<h3>ExecStream Classes</h3>

The diagram below shows some typical vertex types used in
building query graphs.  These are common enough that they have
corresponding abstract base classes from which concrete stream
implementations derive:

<hr>
\image html StreamClasses.gif
<hr>

<h3>Memory Buffers</h3>

Streams consume tuple data from input buffers and produce tuple data
into output buffers.  This interaction is mediated by objects known
as buffer accessors (encapsulated by class ExecStreamBufAccessor).
The buffer access design allows for both by-value and by-reference
semantics, with the goal being to minimize the number of copy operations
required throughout the tree.

<p>

Below is the same graph from the earlier example, but this time
embellished with extra buffers and buffer accessors: 

<hr>
\image html StreamGraphWithBuffers.gif
<hr>

The small rectangles are buffer accessors.  One buffer accessor is
associated with each dataflow edge, and for each such edge, the
producer and consumer streams retain references to the corresponding
accessor.  Also note that two extra <code>MemBuffer</code> streams
have been added to the graph.  The job of these "adapter" streams is
to allocate memory to be written and read by the adjacent streams.
For example, as the <code>CartesianJoin</code> stream produces join
tuples, it writes them into the downstream <code>MemBuffer</code>.
The <code>Calc</code> stream reads them from that same
<code>MemBuffer</code>.

<p>

There are no <code>MemBuffer</code> streams adjacent to the
<code>DiskBuffer</code> stream.  The reason is that the
<code>DiskBuffer</code> stream is capable of allocating pages directly
from the cache for I/O purposes.  It can provide these pages to the 
<code>BTreeScan</code> for writing, and to the
<code>CartesianJoin</code> for reading.  This way, two extra copies
are avoided.  Each stream is responsible for declaring its buffer 
provisioning requirements so that each dataflow can be optimized
automatically.

<h3>ExecStream Lifecycle</h3>

The ExecStream and ExecStreamGraph classes share a common lifecycle:

<hr>
\image html StreamLifecycle.gif
<hr>

<ul>

<li>After construction, the stream starts out in "embryonic" form,
meaning that it is not yet fully ready to execute, but all of its
parameters are defined.  This state is represented via the
ExecStreamEmbryo class (and corresponding ExecStreamGraphEmbryo).

<li>Embryonic streams are constructed and added to an embryonic graph,
and then dataflow edges are added.  As dataflow is defined, extra
adapter streams are inserted automatically as needed.

<li>Once the graph is fully defined, it can be prepared.  This
involves 

<ol>
<li>performing a topological sort by dataflow dependencies
<li>creating buffer accessors for each dataflow edge
<li>binding buffer accessors to the adjacent streams which will
employ them during execution
<li>preparing each stream in dataflow order (from sources to sinks);
stream implementations provide a <code>prepare</code> method which precomputes
data structures needed during execution
</ol>

<li>Before execution, a prepared graph must be opened.  Opening a
graph clears the state of all buffer accessors and opens each of
the constituent streams; stream implementations provide an <code>open</code>
method which clears stream-specific state and allocates any resources
(such as memory, connections, or threads) needed during execution.

<li>Once opened, a graph can be executed via an ExecStreamScheduler.

<li>While open, streams can be reopened individually (usually by
adjacent streams).  For example, a nested loop join needs to reset the
state of its "inner" input for each row from its "outer" input.

<li>Once execution completes or is aborted, the graph should be closed
to release all resources acquired during execution.

<li>A graph can be closed and then opened again repeatedly.

<li>A graph which is currently closed (possibly never opened) can be
deleted.

</ul>

<h3>ExecStream Execution</h3>

For details on how ExecStreams are executed, please see the SchedulerDesign.

 */
struct ExecStreamDesign 
{
    // NOTE:  dummy class for doxygen
};

FENNEL_END_CPPFILE("$Id$");

// End ExecStreamDesign.cpp
