0: jdbc:luciddb:> --
0: jdbc:luciddb:> -- negJoinFiltExp.sql - join filter tests for queries where join Filter should
0: jdbc:luciddb:> -- NOT be used
0: jdbc:luciddb:> --
0: jdbc:luciddb:> 
0: jdbc:luciddb:> set schema 's';
0: jdbc:luciddb:> !set outputformat csv
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- a case where it's not worth it to join filter
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.deptno=dept.deptno and dept.dname<'Marketing';
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[=($t4, $t10)], proj#0..12=[{exprs}], $condition=[$t13])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'        LcsIndexMergeRel'
'          LcsIndexSearchRel(table=[[LOCALDB, S, EMP]], projection=[*], index=[EMP_DEPTNO], uniqueKey=[true], preserveOrder=[false], outer=[false], inputKeyProj=[*], inputJoinProj=[[]], inputDirectiveProj=[[]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelSortRel(key=[[0]], discardDuplicates=[true])'
'              FennelCalcRel(expr#0..2=[{inputs}], expr#3=[CAST($t0):INTEGER], DEPTNO=[$t3])'
'                LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'                  LcsIndexMergeRel'
'                    LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'                      FennelValuesRel(tuples=[[{ '(', null, ')', _ISO-8859-1'Marketing' }]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'        LcsIndexMergeRel'
'          LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'            FennelValuesRel(tuples=[[{ '(', null, ')', _ISO-8859-1'Marketing' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- this isn't worth it since the rows from emp are limited
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.deptno=dept.deptno
. . . . . . . . > and dept.dname='Marketing'
. . . . . . . . > and emp.empno=100;
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[=($t4, $t10)], proj#0..12=[{exprs}], $condition=[$t13])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'        LcsIndexSearchRel(table=[[LOCALDB, S, EMP]], projection=[*], index=[SYS$CONSTRAINT_INDEX$EMP$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', 100, ']', 100 }]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'        LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', _ISO-8859-1'Marketing', ']', _ISO-8859-1'Marketing' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- this shouldn't do it because the filter condition's on the big table
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.deptno=dept.deptno and emp.fname='Bill';
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[=($t4, $t10)], proj#0..12=[{exprs}], $condition=[$t13])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      FennelCalcRel(expr#0..9=[{inputs}], expr#10=[_ISO-8859-1'Bill'], expr#11=[=($t1, $t10)], proj#0..9=[{exprs}], $condition=[$t11])'
'        LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- this shouldn't do it because it's not an equi-join
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.deptno>dept.deptno and dept.dname='Marketing';
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[>($t4, $t10)], proj#0..12=[{exprs}], $condition=[$t13])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'        LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', _ISO-8859-1'Marketing', ']', _ISO-8859-1'Marketing' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- this shouldn't do it because the equi join is not accessible top level
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where (emp.deptno=dept.deptno or dept.deptno > 5) and dept.dname='Marketing';
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[=($t4, $t10)], expr#14=[5], expr#15=[>($t10, $t14)], expr#16=[OR($t13, $t15)], proj#0..12=[{exprs}], $condition=[$t16])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'        LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', _ISO-8859-1'Marketing', ']', _ISO-8859-1'Marketing' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- this shouldn't do it because the filter condition is not accessible top level
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.deptno=dept.deptno and (emp.fname='Bill' or dept.dname='Marketing');
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[=($t4, $t10)], expr#14=[_ISO-8859-1'Bill'], expr#15=[=($t1, $t14)], expr#16=[_ISO-8859-1'Marketing'], expr#17=[=($t11, $t16)], expr#18=[OR($t15, $t17)], expr#19=[AND($t13, $t18)], proj#0..12=[{exprs}], $condition=[$t19])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- this shouldn't do it since emp does not have an index on column hobby
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.hobby=dept.dname and dept.dname='Marketing';
'column0'
'FennelToIteratorConverter'
'  LhxJoinRel(leftKeys=[[9]], rightKeys=[[1]])'
'    LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'    LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'      LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'        FennelValuesRel(tuples=[[{ '[', _ISO-8859-1'Marketing', ']', _ISO-8859-1'Marketing' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- pre filter should happen here, but we still need to join to location since
0: jdbc:luciddb:> -- location.state is not unique
0: jdbc:luciddb:> explain plan for select emp.* from emp,location
. . . . . . . . > where emp.fname=location.state and location.locid='00';
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..14=[{inputs}], expr#15=[=($t1, $t13)], proj#0..9=[{exprs}], $condition=[$t15])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'      LcsRowScanRel(table=[[LOCALDB, S, LOCATION]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$LOCATION$CITY, SYS$CLUSTERED_INDEX$S$LOCATION$LOCID, SYS$CLUSTERED_INDEX$S$LOCATION$STATE, SYS$CLUSTERED_INDEX$S$LOCATION$STREET, SYS$CLUSTERED_INDEX$S$LOCATION$ZIP]])'
'        LcsIndexSearchRel(table=[[LOCALDB, S, LOCATION]], projection=[*], index=[SYS$CONSTRAINT_INDEX$LOCATION$SYS$PRIMARY_KEY], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', _ISO-8859-1'00', ']', _ISO-8859-1'00' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> -- can't handle non-simple equi join case
0: jdbc:luciddb:> explain plan for select * from emp,dept
. . . . . . . . > where emp.deptno+1=dept.deptno+1 and dept.dname='Marketing';
'column0'
'FennelToIteratorConverter'
'  FennelCalcRel(expr#0..12=[{inputs}], expr#13=[1], expr#14=[+($t4, $t13)], expr#15=[+($t10, $t13)], expr#16=[=($t14, $t15)], proj#0..12=[{exprs}], $condition=[$t16])'
'    FennelCartesianProductRel(leftouterjoin=[false])'
'      LcsRowScanRel(table=[[LOCALDB, S, EMP]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$EMP$COMMISSION, SYS$CLUSTERED_INDEX$S$EMP$DEPTNO, SYS$CLUSTERED_INDEX$S$EMP$EMPNO, SYS$CLUSTERED_INDEX$S$EMP$FNAME, SYS$CLUSTERED_INDEX$S$EMP$HOBBY, SYS$CLUSTERED_INDEX$S$EMP$LNAME, SYS$CLUSTERED_INDEX$S$EMP$LOCID, SYS$CLUSTERED_INDEX$S$EMP$MANAGER, SYS$CLUSTERED_INDEX$S$EMP$SAL, SYS$CLUSTERED_INDEX$S$EMP$SEX]])'
'      LcsRowScanRel(table=[[LOCALDB, S, DEPT]], projection=[*], clustered indexes=[[SYS$CLUSTERED_INDEX$S$DEPT$DEPTNO, SYS$CLUSTERED_INDEX$S$DEPT$DNAME, SYS$CLUSTERED_INDEX$S$DEPT$LOCID]])'
'        LcsIndexSearchRel(table=[[LOCALDB, S, DEPT]], projection=[*], index=[SYS$CONSTRAINT_INDEX$DEPT$SYS$UNIQUE_KEY$DNAME], uniqueKey=[false], preserveOrder=[false], outer=[false], inputKeyProj=[[1, 3]], inputJoinProj=[[]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0])'
'          FennelValuesRel(tuples=[[{ '[', _ISO-8859-1'Marketing', ']', _ISO-8859-1'Marketing' }]])'
0: jdbc:luciddb:> 
0: jdbc:luciddb:> !set outputformat table
0: jdbc:luciddb:> !quit
