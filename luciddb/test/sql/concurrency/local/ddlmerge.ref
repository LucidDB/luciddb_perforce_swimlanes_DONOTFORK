-- setup
> set schema 's';
0 rows affected.
> create table t1m      ("kseq" bigint primary key,
> "k2" bigint,
> "k4" bigint,
> "k5" bigint,
> "k10" bigint,
> "k25" bigint,
> "k100" bigint,
> "k1k" bigint,
> "k10k" bigint,
> "k40k" bigint,
> "k100k" bigint,
> "k250k" bigint,
> "k500k" bigint);
0 rows affected.
> insert into t1m select * from bench1m;
1000000 rows affected.
-- end of setup

-- thread comp
> set schema 's';
0 rows affected.
> drop index k2idx;
0 rows affected.
> drop table t1m;
0 rows affected.
-- end of thread comp

-- thread w1
> set schema 's';
0 rows affected.
> create index k2idx on t1m("k2");
0 rows affected.
-- end of thread w1

-- thread w2
> set schema 's';
0 rows affected.
> explain plan for
> merge into t1m as tr
> using (select * from t1m where "k2"=1) as rf
> on rf."kseq" = tr."kseq"
> when matched then update set "k2"=-1
> when not matched then insert ("kseq") values(0);
+---------+
| column0 |
+---------+
| FennelToIteratorConverter |
|   LcsTableMergeRel(table=[[LOCALDB, S, T1M]]) |
|     FennelCalcRel(expr#0..13=[{inputs}], expr#14=[null], expr#15=[CAST($t14):VARBINARY(512)], expr#16=[IS NULL($t13)], expr#17=[0], expr#18=[CASE($t16, $t17, $t1)], expr#19=[-1], expr#20=[CASE($t16, $t14, $t19)], expr#21=[CASE($t16, $t14, $t2)], expr#22=[CASE($t16, $t14, $t3)], expr#23=[CASE($t16, $t14, $t4)], expr#24=[CASE($t16, $t14, $t5)], expr#25=[CASE($t16, $t14, $t6)], expr#26=[CASE($t16, $t14, $t7)], expr#27=[CASE($t16, $t14, $t8)], expr#28=[CASE($t16, $t14, $t9)], expr#29=[CASE($t16, $t14, $t10)], expr#30=[CASE($t16, $t14, $t11)], expr#31=[CASE($t16, $t14, $t12)], expr#32=[CAST($t18):BIGINT NOT NULL], expr#33=[CAST($t20):BIGINT], rid=[$t13], descriptor=[$t15], segment=[$t15], kseq=[$t32], k2=[$t33], k4=[$t21], k5=[$t22], k10=[$t23], k25=[$t24], k100=[$t25], k1k=[$t26], k10k=[$t27], k40k=[$t28], k100k=[$t29], k250k=[$t30], k500k=[$t31]) |
|       LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT]) |
|         FennelCalcRel(expr#0..1=[{inputs}], expr#2=[1], expr#3=[=($t1, $t2)], kseq=[$t0], $condition=[$t3]) |
|           LcsRowScanRel(table=[[LOCALDB, S, T1M]], projection=[[0, 1]], clustered indexes=[[SYS$CLUSTERED_INDEX$S$T1M$k2, SYS$CLUSTERED_INDEX$S$T1M$kseq]]) |
|         LcsRowScanRel(table=[[LOCALDB, S, T1M]], projection=[[0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$S$T1M$k10, SYS$CLUSTERED_INDEX$S$T1M$k100, SYS$CLUSTERED_INDEX$S$T1M$k100k, SYS$CLUSTERED_INDEX$S$T1M$k10k, SYS$CLUSTERED_INDEX$S$T1M$k1k, SYS$CLUSTERED_INDEX$S$T1M$k25, SYS$CLUSTERED_INDEX$S$T1M$k250k, SYS$CLUSTERED_INDEX$S$T1M$k4, SYS$CLUSTERED_INDEX$S$T1M$k40k, SYS$CLUSTERED_INDEX$S$T1M$k5, SYS$CLUSTERED_INDEX$S$T1M$k500k, SYS$CLUSTERED_INDEX$S$T1M$kseq]]) |
+---------+

> select count(*) from t1m where "k2"=1;
+---------------------+
| EXPR$0              |
+---------------------+
| 499598              |
+---------------------+

> explain plan for
> merge into t1m as tr
> using (select * from t1m where "k2"=1) as rf
> on rf."kseq" = tr."kseq"
> when matched then update set "k2"=-1
> when not matched then insert ("kseq") values(0);
+---------+
| column0 |
+---------+
| FennelToIteratorConverter |
|   LcsTableMergeRel(table=[[LOCALDB, S, T1M]]) |
|     FennelCalcRel(expr#0..13=[{inputs}], expr#14=[null], expr#15=[CAST($t14):VARBINARY(512)], expr#16=[IS NULL($t13)], expr#17=[0], expr#18=[CASE($t16, $t17, $t1)], expr#19=[-1], expr#20=[CASE($t16, $t14, $t19)], expr#21=[CASE($t16, $t14, $t2)], expr#22=[CASE($t16, $t14, $t3)], expr#23=[CASE($t16, $t14, $t4)], expr#24=[CASE($t16, $t14, $t5)], expr#25=[CASE($t16, $t14, $t6)], expr#26=[CASE($t16, $t14, $t7)], expr#27=[CASE($t16, $t14, $t8)], expr#28=[CASE($t16, $t14, $t9)], expr#29=[CASE($t16, $t14, $t10)], expr#30=[CASE($t16, $t14, $t11)], expr#31=[CASE($t16, $t14, $t12)], expr#32=[CAST($t18):BIGINT NOT NULL], expr#33=[CAST($t20):BIGINT], rid=[$t13], descriptor=[$t15], segment=[$t15], kseq=[$t32], k2=[$t33], k4=[$t21], k5=[$t22], k10=[$t23], k25=[$t24], k100=[$t25], k1k=[$t26], k10k=[$t27], k40k=[$t28], k100k=[$t29], k250k=[$t30], k500k=[$t31]) |
|       LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT]) |
|         LcsRowScanRel(table=[[LOCALDB, S, T1M]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$S$T1M$kseq]]) |
|           LcsIndexSearchRel(table=[[LOCALDB, S, T1M]], index=[K2IDX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0]) |
|             FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]]) |
|         LcsRowScanRel(table=[[LOCALDB, S, T1M]], projection=[[0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$S$T1M$k10, SYS$CLUSTERED_INDEX$S$T1M$k100, SYS$CLUSTERED_INDEX$S$T1M$k100k, SYS$CLUSTERED_INDEX$S$T1M$k10k, SYS$CLUSTERED_INDEX$S$T1M$k1k, SYS$CLUSTERED_INDEX$S$T1M$k25, SYS$CLUSTERED_INDEX$S$T1M$k250k, SYS$CLUSTERED_INDEX$S$T1M$k4, SYS$CLUSTERED_INDEX$S$T1M$k40k, SYS$CLUSTERED_INDEX$S$T1M$k5, SYS$CLUSTERED_INDEX$S$T1M$k500k, SYS$CLUSTERED_INDEX$S$T1M$kseq]]) |
+---------+

> merge into t1m as tr
> using (select * from t1m where "k2"=1) as rf
> on rf."kseq" = tr."kseq"
> when matched then update set "k2"=-1
> when not matched then insert ("kseq") values(0);
499598 rows affected.
> select count(*) from t1m;
+---------------------+
| EXPR$0              |
+---------------------+
| 1000000             |
+---------------------+

> explain plan for
> merge into t1m as tr
> using (select * from t1m where "k2"=1) as rf
> on rf."kseq" = tr."kseq"
> when matched then update set "k2"=-1
> when not matched then insert ("kseq") values(0);
+---------+
| column0 |
+---------+
| FennelToIteratorConverter |
|   LcsTableMergeRel(table=[[LOCALDB, S, T1M]]) |
|     FennelCalcRel(expr#0..13=[{inputs}], expr#14=[null], expr#15=[CAST($t14):VARBINARY(512)], expr#16=[IS NULL($t13)], expr#17=[0], expr#18=[CASE($t16, $t17, $t1)], expr#19=[-1], expr#20=[CASE($t16, $t14, $t19)], expr#21=[CASE($t16, $t14, $t2)], expr#22=[CASE($t16, $t14, $t3)], expr#23=[CASE($t16, $t14, $t4)], expr#24=[CASE($t16, $t14, $t5)], expr#25=[CASE($t16, $t14, $t6)], expr#26=[CASE($t16, $t14, $t7)], expr#27=[CASE($t16, $t14, $t8)], expr#28=[CASE($t16, $t14, $t9)], expr#29=[CASE($t16, $t14, $t10)], expr#30=[CASE($t16, $t14, $t11)], expr#31=[CASE($t16, $t14, $t12)], expr#32=[CAST($t18):BIGINT NOT NULL], expr#33=[CAST($t20):BIGINT], rid=[$t13], descriptor=[$t15], segment=[$t15], kseq=[$t32], k2=[$t33], k4=[$t21], k5=[$t22], k10=[$t23], k25=[$t24], k100=[$t25], k1k=[$t26], k10k=[$t27], k40k=[$t28], k100k=[$t29], k250k=[$t30], k500k=[$t31]) |
|       LhxJoinRel(leftKeys=[[0]], rightKeys=[[0]], joinType=[LEFT]) |
|         LcsRowScanRel(table=[[LOCALDB, S, T1M]], projection=[[0]], clustered indexes=[[SYS$CLUSTERED_INDEX$S$T1M$kseq]]) |
|           LcsIndexSearchRel(table=[[LOCALDB, S, T1M]], index=[K2IDX], projection=[*], inputKeyProj=[[1, 3]], inputDirectiveProj=[[0, 2]], startRidParamId=[0], rowLimitParamId=[0]) |
|             FennelValuesRel(tuples=[[{ _ISO-8859-1'[', 1, _ISO-8859-1']', 1 }]]) |
|         LcsRowScanRel(table=[[LOCALDB, S, T1M]], projection=[[0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, LCS_RID]], clustered indexes=[[SYS$CLUSTERED_INDEX$S$T1M$k10, SYS$CLUSTERED_INDEX$S$T1M$k100, SYS$CLUSTERED_INDEX$S$T1M$k100k, SYS$CLUSTERED_INDEX$S$T1M$k10k, SYS$CLUSTERED_INDEX$S$T1M$k1k, SYS$CLUSTERED_INDEX$S$T1M$k25, SYS$CLUSTERED_INDEX$S$T1M$k250k, SYS$CLUSTERED_INDEX$S$T1M$k4, SYS$CLUSTERED_INDEX$S$T1M$k40k, SYS$CLUSTERED_INDEX$S$T1M$k5, SYS$CLUSTERED_INDEX$S$T1M$k500k, SYS$CLUSTERED_INDEX$S$T1M$kseq]]) |
+---------+

> select count(*) from t1m where "k2"=1;
+---------------------+
| EXPR$0              |
+---------------------+
| 0                   |
+---------------------+

-- end of thread w2

