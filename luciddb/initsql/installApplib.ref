> -- $Id$
> create or replace schema localdb.applib;
> set schema 'localdb.applib';
> set path 'localdb.applib';
> 
> create or replace jar applib.applibJar
> library 'file:${FARRAGO_HOME}/plugin/applib.jar'
> options(0);
> 
> -- UDFs
> -- define CharReplace functions
> create or replace function applib.char_replace(str varchar(128), oldC varchar(128), newC varchar(128)) 
> returns varchar(128)
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.CharReplaceUdf.execute';
> 
> create or replace function applib.char_replace(str varchar(128), oldC integer, newC integer) 
> returns varchar(128)
> language java
> specific char_replace_int
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.CharReplaceUdf.execute';
> 
> -- define CleanPhoneInternational functions
> create or replace function applib.clean_phone_international(str varchar(128), b boolean)
> returns varchar(128)
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.phone.CleanPhoneInternationalUdf.execute';
> 
> -- define CleanPhone functions
> create or replace function applib.clean_phone(str varchar(128))
> returns varchar(128)
> language java
> specific clean_phone_no_format
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.phone.CleanPhoneUdf.execute';
> 
> create or replace function applib.clean_phone(inStr varchar(128), format integer)
> returns varchar(128)
> language java
> specific clean_phone_int_format
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.phone.CleanPhoneUdf.execute';
> 
> create or replace function applib.clean_phone(inStr varchar(128), format integer, reject boolean)
> returns varchar(128)
> language java
> specific clean_phone_int_format_rejectable
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.phone.CleanPhoneUdf.execute';
> 
> create or replace function applib.clean_phone(inStr varchar(128), format varchar(128), reject boolean)
> returns varchar(128)
> language java
> specific clean_phone_str_format_rejectable
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.phone.CleanPhoneUdf.execute';
> 
> -- define ContainsNumber function
> create or replace function applib.contains_number(str varchar(128))
> returns boolean
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.ContainsNumberUdf.execute';
> 
> -- define CYQuarter functions
> create or replace function applib.calendar_quarter(dt date)
> returns varchar(128)
> language java
> specific calendar_quarter_date
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.CalendarQuarterUdf.execute';
> 
> create or replace function applib.calendar_quarter(ts timestamp)
> returns varchar(128)
> language java
> specific calendar_quarter_ts
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.CalendarQuarterUdf.execute';
> 
> -- define internalDate function (example function)
> create or replace function applib.internal_date(indate bigint)
> returns varchar(128)
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.contrib.InternalDateUdf.execute';
> 
> -- define DAYINYEAR function
> create or replace function applib.day_in_year(dt date)
> returns integer
> language java
> specific DAYINYEAR_DATE
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.DayInYearUdf.execute';
> 
> create or replace function applib.day_in_year(ts timestamp)
> returns integer
> language java
> specific DAYINYEAR_TS
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.DayInYearUdf.execute';
> 
> create or replace function applib.day_in_year(yr integer, mth integer, dt integer)
> returns integer
> language java
> specific DAYINYEAR_YMD
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.DayInYearUdf.execute';
> 
> -- define dayNumberOverall functions
> create or replace function applib.day_number_overall(dt Date)
> returns integer
> language java
> specific DAYNUMBEROVERALL_DATE
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.DayNumberOverallUdf.execute';
> 
> create or replace function applib.day_number_overall(ts timestamp)
> returns integer
> language java
> specific DAYNUMBEROVERALL_TS
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.DayNumberOverallUdf.execute';
> 
> -- define FYMonth functions
> create or replace function applib.fiscal_month(dt date, fm integer)
> returns integer
> language java
> specific FYMONTH_DATE
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalMonthUdf.execute';
> 
> create or replace function applib.fiscal_month(ts timestamp, fm integer)
> returns integer
> language java
> specific FYMONTH_TS
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalMonthUdf.execute';
> 
> -- define FYQuarter functions
> create or replace function applib.fiscal_quarter(yr integer, mth integer, fm integer)
> returns varchar(10)
> language java
> specific FYQUARTER_YMFM
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalQuarterUdf.execute';
> 
> create or replace function applib.fiscal_quarter(dt date, fm integer)
> returns varchar(10)
> language java
> specific FYQUARTER_DATE
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalQuarterUdf.execute';
> 
> create or replace function applib.fiscal_quarter(ts timestamp, fm integer)
> returns varchar(10)
> language java
> specific FYQUARTER_TS
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalQuarterUdf.execute';
> 
> -- define FYYear functions
> create or replace function applib.fiscal_year(dt date, fm integer)
> returns integer
> language java
> specific FYYEAR_DATE
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalYearUdf.execute';
> 
> create or replace function applib.fiscal_year(ts timestamp, fm integer)
> returns integer
> language java
> specific FYYEAR_TS
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalYearUdf.execute';
> 
> -- define leftN functions
> create or replace function applib.leftn(str varchar(128), len integer)
> returns varchar(128)
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.LeftNUdf.execute';
> 
> -- define rand functions
> create or replace function applib.rand(minVal integer, maxVal integer)
> returns integer
> language java
> not deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.numeric.RandUdf.execute';
> 
> -- define repeater function
> create or replace function applib.REPEATER(str varchar(128), times integer)
> returns varchar(128)
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.RepeaterUdf.execute';
> 
> -- define rightn function
> create or replace function applib.RIGHTN(str varchar(128), len integer)
> returns varchar(128)
> language java
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.RightNUdf.execute';
> 
> -- define StrReplace function
> create or replace function applib.str_replace(inStr varchar(128), oldStr varchar(128), newStr varchar(128))
> returns varchar(128)
> language java
> deterministic
> no sql
> external name "applib.applibJar:com.lucidera.luciddb.applib.string.StrReplaceUdf.execute";
> 
> -- define convert_date function
> create or replace function applib.convert_date(str varchar(128), mask varchar(50), rej boolean)
> returns date
> language java
> specific convert_date_rejectable
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.ConvertDateUdf.execute';
> 
> create or replace function applib.convert_date(str varchar(128), mask varchar(50))
> returns date
> language java
> specific convert_date_not_rejectable
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.ConvertDateUdf.execute';
> 
> -- converts a string to a date, according to the specified format string
> create or replace function applib.char_to_date(format varchar(50), dateString varchar(128))
> returns date
> language java
> specific applib_std_char_to_date
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.StdConvertDateUdf.char_to_date';
> 
> create or replace function applib.char_to_time(format varchar(50), timeString varchar(128))
> returns time
> language java
> specific applib_std_char_to_time
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.StdConvertDateUdf.char_to_time';
> 
> create or replace function applib.char_to_timestamp(
>     format varchar(50), timestampString varchar(128))
> returns timestamp
> language java
> specific applib_std_char_to_timestamp
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.StdConvertDateUdf.char_to_timestamp';
> 
> -- formats a string as a date, according to the specified format string
> create or replace function applib.date_to_char(format varchar(50), d date)
> returns varchar(128)
> language java
> specific applib_std_date_to_char
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.StdConvertDateUdf.date_to_char';
> 
> create or replace function applib.time_to_char(format varchar(50), t time)
> returns varchar(128)
> language java
> specific applib_std_time_to_char
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.StdConvertDateUdf.time_to_char';
> 
> create or replace function applib.timestamp_to_char(format varchar(50), ts timestamp)
> returns varchar(128)
> language java
> specific applib_std_timestamp_to_char
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.StdConvertDateUdf.timestamp_to_char';
> 
> -- adds n number of days to a date
> create or replace function applib.add_days(d date, n int)
> returns date
> specific add_days_date
> deterministic
> contains sql
> return (
>   d + cast(cast(n as bigint)*24*60*60*1000 as interval day)
> );
> 
> -- adds n number of days to a timestamp
> create or replace function applib.add_days(ts timestamp, n int)
> returns timestamp
> specific add_days_timestamp
> deterministic
> contains sql
> return (
>   ts + cast(cast(n as bigint)*24*60*60*1000 as interval day)
> );
> 
> -- adds n number of hours to a timestamp
> create or replace function applib.add_hours(ts timestamp, n int)
> returns timestamp
> specific add_hours_timestamp
> deterministic
> contains sql
> return (
>   ts + cast(cast(n as bigint)*60*60*1000 as interval day to hour));
> 
> -- returns the difference in units of days between two dates
> create or replace function applib.days_diff(d1 date, d2 date)
> returns bigint
> specific days_diff_dates
> deterministic
> contains sql
> return (
>   extract( day from ((d1 - d2) day) )
> );
> 
> -- returns the difference in units of days between two timestamps. Note that
> -- partial days that are less than 24 hours will not count as a day.
> create or replace function applib.days_diff(ts1 timestamp, ts2 timestamp)
> returns bigint
> specific days_diff_timestamps
> deterministic
> contains sql
> return (
>   extract( day from ((ts1 - ts2) day) )
> );
> 
> -- returns the difference in units of hours between two timestamps. Note that 
> -- partial hours that are less than 60 minutes will not count as an hour.
> create or replace function applib.hours_diff(ts1 timestamp, ts2 timestamp)
> returns bigint
> specific hours_diff_timestamps
> deterministic
> contains sql
> return (
>   extract( day from ((ts1 - ts2) day)) * 24  +
>   extract( hour from ((ts1 - ts2) hour))
> );
> 
> -- define dayFromJulianStart
> -- 2440588 is the number of days from the Julian Calendar start date to 
> -- the epoch Jan 1, 1970 
> create or replace function applib.day_from_julian_start(dt Date)
> returns integer
> language sql
> deterministic
> contains sql
> return (
>   applib.day_number_overall(dt) + 2440588
> );
> 
> -- define current_date_in_julian
> -- 2440588 is the number of days from the Julian Calendar start date to 
> -- the epoch Jan 1, 1970 
> create or replace function applib.current_date_in_julian()
> returns integer
> deterministic
> dynamic_function
> contains sql
> return (
>   applib.day_number_overall(CURRENT_DATE) + 2440588
> );
> 
> -- define padweeknumber
> create or replace function applib.padweeknumber(wk_num_as_yr integer)
> returns varchar(16)
> language sql
> deterministic
> contains sql
> return (
>   case 
>     WHEN (wk_num_as_yr < 10) THEN ('0' || cast (wk_num_as_yr as varchar(1)))
>     ELSE cast (wk_num_as_yr as varchar(2))  
>   end
> );
> 
> -- define INSTR
> create or replace function applib.instr(str varchar(65535), subStr varchar(65535), startPos int, nthAppearance int)
> returns int
> language java
> specific instr_with_optional_vars
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.InStrUdf.execute';
> 
> create or replace function applib.instr(str varchar(65535), subStr varchar(65535))
> returns int
> language java
> specific instr_without_optional_vars
> deterministic
> no sql
> returns null on null input
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.InStrUdf.execute';
> 
> 
> ----
> -- Application variables (a.k.a. "appvars")
> -- 
> -- Appvars are defined within a named context, allowing sets of
> -- variables to be manipulated as a unit.
> ----
> 
> -- Creates a variable (or a context if var_id is null).
> -- The initial value for a new variable is null.  It is an error
> -- to attempt to create a context or variable which already exists.
> create or replace procedure applib.create_var(
>     context_id varchar(128), 
>     var_id varchar(128),
>     description varchar(65535))
> language java
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.variable.AppVarApi.executeCreate';
> 
> -- Deletes a variable (or a context if var_id is null), which must
> -- currently exist.
> create or replace procedure applib.delete_var(
>     context_id varchar(128), 
>     var_id varchar(128))
> language java
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.variable.AppVarApi.executeDelete';
> 
> -- Sets the value for a variable.  var_id must not be null, and must
> -- reference a previously created variable.
> create or replace procedure applib.set_var(
>     context_id varchar(128), 
>     var_id varchar(128), 
>     new_value varchar(65535))
> language java
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.variable.AppVarApi.executeSet';
> 
> -- Flushes modifications to a variable (or a context if var_id is null).
> -- Before flush, there is no guarantee that modifications have
> -- been made permanent.
> create or replace procedure applib.flush_var(
>     context_id varchar(128), 
>     var_id varchar(128))
> language java
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.variable.AppVarApi.executeFlush';
> 
> -- Retrieves the current value of a variable.  var_id must not be null,
> -- and must reference a previously created variable.
> -- Declared as deterministic to let the optimizer know that it should
> -- be evaluated once per statement (rather than once per row) when
> -- the arguments are constant literals.
> create or replace function applib.get_var(
>     context_id varchar(128), 
>     var_id varchar(128)) 
> returns varchar(65535)
> language java
> deterministic
> dynamic_function
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.variable.AppVarApi.executeGet';
> 
> ----
> -- UDXs
> ----
> 
> -- define TIMEDIMENSION
> create or replace function APPLIB.TIME_DIMENSION(startYr int, startMth int, startDay int, endYr int, endMth int, endDay int, fiscalYrStartMth int)
> returns table(
>   TIME_KEY_SEQ int,
>   TIME_KEY date,
>   DAY_OF_WEEK varchar(10),
>   WEEKEND varchar(1),
>   DAY_NUMBER_IN_WEEK int,
>   DAY_NUMBER_IN_MONTH int,
>   DAY_NUMBER_IN_YEAR int,
>   DAY_NUMBER_OVERALL int,
>   DAY_FROM_JULIAN int,
>   WEEK_NUMBER_IN_MONTH int,
>   WEEK_NUMBER_IN_QUARTER int,
>   WEEK_NUMBER_IN_YEAR int,
>   WEEK_NUMBER_OVERALL int,
>   MONTH_NAME varchar(10),
>   MONTH_NUMBER_IN_QUARTER int,
>   MONTH_NUMBER_IN_YEAR int,
>   MONTH_NUMBER_OVERALL int,
>   QUARTER int,
>   YR int,
>   CALENDAR_QUARTER varchar(6),
>   WEEK_START_DATE date,
>   WEEK_END_DATE date,
>   MONTH_START_DATE date,
>   MONTH_END_DATE date,
>   QUARTER_START_DATE date,
>   QUARTER_END_DATE date,
>   YEAR_START_DATE date,
>   YEAR_END_DATE date,
>   FISCAL_WEEK_START_DATE date,
>   FISCAL_WEEK_END_DATE date,
>   FISCAL_WEEK_NUMBER_IN_MONTH int,
>   FISCAL_WEEK_NUMBER_IN_QUARTER int,
>   FISCAL_WEEK_NUMBER_IN_YEAR int,
>   FISCAL_MONTH_START_DATE date,
>   FISCAL_MONTH_END_DATE date,
>   FISCAL_MONTH_NUMBER_IN_QUARTER int,
>   FISCAL_MONTH_NUMBER_IN_YEAR int,
>   FISCAL_QUARTER_START_DATE date,
>   FISCAL_QUARTER_END_DATE date,
>   FISCAL_QUARTER_NUMBER_IN_YEAR int,
>   FISCAL_YEAR_START_DATE date,
>   FISCAL_YEAR_END_DATE date)
> language java
> parameter style system defined java
> specific time_dimension_fm
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.TimeDimensionUdx.execute';
> 
> -- time dimension without fiscal information
> create or replace function APPLIB.TIME_DIMENSION(startYr int, startMth int, startDay int, endYr int, endMth int, endDay int)
> returns table(
>   TIME_KEY_SEQ int,
>   TIME_KEY date,
>   DAY_OF_WEEK varchar(10),
>   WEEKEND varchar(1),
>   DAY_NUMBER_IN_WEEK int,
>   DAY_NUMBER_IN_MONTH int,
>   DAY_NUMBER_IN_YEAR int,
>   DAY_NUMBER_OVERALL int,
>   WEEK_NUMBER_IN_YEAR int,
>   WEEK_NUMBER_OVERALL int,
>   MONTH_NAME varchar(10),
>   MONTH_NUMBER_IN_YEAR int,
>   MONTH_NUMBER_OVERALL int,
>   QUARTER int,
>   YR int,
>   CALENDAR_QUARTER varchar(6),
>   FIRST_DAY_OF_WEEK date)
> language java
> parameter style system defined java
> specific time_dimension
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.TimeDimensionUdx.execute';
> 
> -- Fiscal time dimension 
> create or replace function APPLIB.FISCAL_TIME_DIMENSION(startYr int, startMth int, startDay int, endYr int, endMth int, endDay int, fiscalYrStartMth int)
> returns table(
>   TIME_KEY_SEQ int,
>   TIME_KEY date,
>   DAY_OF_WEEK varchar(10),
>   WEEKEND varchar(1),
>   DAY_NUMBER_IN_WEEK int,
>   DAY_NUMBER_IN_MONTH int,
>   DAY_NUMBER_IN_QUARTER int,
>   DAY_NUMBER_IN_YEAR int,
>   DAY_NUMBER_OVERALL int,
>   DAY_FROM_JULIAN int,
>   WEEK_NUMBER_IN_MONTH int,
>   WEEK_NUMBER_IN_QUARTER int,
>   WEEK_NUMBER_IN_YEAR int,
>   WEEK_NUMBER_OVERALL int,
>   MONTH_NAME varchar(10),
>   MONTH_NUMBER_IN_QUARTER int,
>   MONTH_NUMBER_IN_YEAR int,
>   MONTH_NUMBER_OVERALL int,
>   QUARTER int,
>   YR int,
>   CALENDAR_QUARTER varchar(6),
>   WEEK_START_DATE date,
>   WEEK_END_DATE date,
>   MONTH_START_DATE date,
>   MONTH_END_DATE date,
>   QUARTER_START_DATE date,
>   QUARTER_END_DATE date,
>   YEAR_START_DATE date,
>   YEAR_END_DATE date,
>   FISCAL_YEAR int,
>   FISCAL_DAY_NUMBER_IN_QUARTER int,
>   FISCAL_DAY_NUMBER_IN_YEAR int,
>   FISCAL_WEEK_START_DATE date,
>   FISCAL_WEEK_END_DATE date,
>   FISCAL_WEEK_NUMBER_IN_MONTH int,
>   FISCAL_WEEK_NUMBER_IN_QUARTER int,
>   FISCAL_WEEK_NUMBER_IN_YEAR int,
>   FISCAL_MONTH_START_DATE date,
>   FISCAL_MONTH_END_DATE date,
>   FISCAL_MONTH_NUMBER_IN_QUARTER int,
>   FISCAL_MONTH_NUMBER_IN_YEAR int,
>   FISCAL_QUARTER_START_DATE date,
>   FISCAL_QUARTER_END_DATE date,
>   FISCAL_QUARTER_NUMBER_IN_YEAR int,
>   FISCAL_YEAR_START_DATE date,
>   FISCAL_YEAR_END_DATE date)
> language java
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.FiscalTimeDimensionUdx.execute';
> 
> -- Calculate Effective To Timestamps
> create or replace function applib.derive_effective_to_timestamp(
>         c cursor, 
>         units_to_subtract integer, 
>         unit_type_to_subtract varchar(32))
> returns table(
>         id varchar(255), 
>         effective_from_timestamp timestamp, 
>         effective_to_timestamp timestamp)
> language java
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.datetime.DeriveEffectiveToTimestampUdx.execute';
> 
> -- Flatten hierarchical data, producing rows corresponding to leaf nodes only
> create or replace function applib.flatten_recursive_hierarchy(c cursor)
> returns table(
>     vertices integer,
>     multipath boolean,
>     level1 varchar(65535),
>     level2 varchar(65535),
>     level3 varchar(65535),
>     level4 varchar(65535),
>     level5 varchar(65535),
>     level6 varchar(65535),
>     level7 varchar(65535),
>     level8 varchar(65535),
>     level9 varchar(65535),
>     level10 varchar(65535),
>     level11 varchar(65535),
>     level12 varchar(65535),
>     level13 varchar(65535),
>     level14 varchar(65535),
>     level15 varchar(65535))
> language java
> parameter style system defined java
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.cursor.FlattenRecursiveHierarchyUdx.execute';
> 
> -- Flatten hierarchical data, producing rows for both leaf and non-leaf nodes
> create or replace function applib.flatten_recursive_hierarchy_all_levels(
>     c cursor)
> returns table(
>     vertices integer,
>     multipath boolean,
>     non_leaf boolean,
>     level1 varchar(65535),
>     level2 varchar(65535),
>     level3 varchar(65535),
>     level4 varchar(65535),
>     level5 varchar(65535),
>     level6 varchar(65535),
>     level7 varchar(65535),
>     level8 varchar(65535),
>     level9 varchar(65535),
>     level10 varchar(65535),
>     level11 varchar(65535),
>     level12 varchar(65535),
>     level13 varchar(65535),
>     level14 varchar(65535),
>     level15 varchar(65535))
> language java
> parameter style system defined java
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.cursor.FlattenRecursiveHierarchyUdx.executeAllLevels';
> 
> -- Generate CRC udx
> create or replace function generate_crc(c cursor)
> returns table(c.*, crc_value bigint)
> language java
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.cursor.GenerateCrcUdx.execute';
> 
> -- Generate CRC UDX with specified column set used to calculate CRC
> create or replace function generate_crc(
>   c cursor,
>   r select from c,
>   exclude boolean)
> returns table(c.*, crc_value bigint)
> language java
> parameter style system defined java
> deterministic
> no sql
> specific generate_crc_for_column_subset
> external name 'applib.applibJar:com.lucidera.luciddb.applib.cursor.GenerateCrcUdx.execute';
> 
> -- Pivot columns to rows
> create or replace function pivot_columns_to_rows(c cursor)
> returns table(col_name varchar(65535), col_value varchar(65535))
> language java
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.cursor.PivotColumnsToRowsUdx.execute';
> 
> -- collapse rows
> create or replace function collapse_rows(c cursor, delimiter varchar(1))
> returns table(
>   parent_value varchar(65535), 
>   concatenated_child_values varchar(65535),
>   collapsed_row_count integer)
> language java
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.cursor.CollapseRowsUdx.execute';
> 
> -- split strings
> create or replace function applib.split_string_to_rows(
>        IN_STRING varchar(65535), 
>        SEPARATOR_CHAR char(1), 
>        ESCAPE_CHAR char(1),
>        TRIM_TOKENS boolean)
> returns table(OUT_STRINGS varchar(65535))
> language java
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.SplitStringUdx.execute';
> 
> create or replace function applib.split_rows(
>        IN_CURSOR cursor, 
>        SEPARATOR_CHAR char(1), 
>        ESCAPE_CHAR char(1), 
>        TRIM_TOKENS boolean)
> returns table(IN_CURSOR.*)
> language java
> specific split_strings_singlecol
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.SplitStringUdx.execute';
> 
> create or replace function applib.split_rows(
>        IN_CURSOR cursor, 
>        COL_NAME select from IN_CURSOR, 
>        SEPARATOR_CHAR char(1), 
>        ESCAPE_CHAR char(1), 
>        TRIM_TOKENS boolean)
> returns table(IN_CURSOR.*)
> language java
> specific split_strings_multicol
> parameter style system defined java
> deterministic
> no sql
> external name 'applib.applibJar:com.lucidera.luciddb.applib.string.SplitStringUdx.execute';
> 
> -- enforce row constraints, default message catalog
> create or replace function enforce_row_constraints(c cursor, r select from c)
> returns table(c.*)
> language java
> parameter style system defined java
> not deterministic
> no sql
> specific enforce_row_constraints_default_msg_jar
> external name 'applib.applibJar:com.lucidera.luciddb.applib.util.EnforceRowConstraintsUdx.execute';
> 
> -- enforce row constraints with msg jar
> create or replace function enforce_row_constraints(
>   c cursor,
>   r select from c,
>   msgJarName varchar(128))
> returns table(c.*)
> language java
> parameter style system defined java
> not deterministic
> no sql
> specific enforce_row_constraints_with_msg_jar
> external name 'applib.applibJar:com.lucidera.luciddb.applib.util.EnforceRowConstraintsUdx.execute';
> 
> -- enforce row constraints with tag for logging
> create or replace function enforce_row_constraints(
>   c cursor,
>   r select from c,
>   msgJarName varchar(128),
>   tag varchar(128))
> returns table(c.*)
> language java
> parameter style system defined java
> not deterministic
> no sql
> specific enforce_row_constraints_with_tag
> external name 'applib.applibJar:com.lucidera.luciddb.applib.util.EnforceRowConstraintsUdx.execute';
> 
> ----
> -- System procedures
> ----
> 
> -- UDP for granting a user select privileges for all tables and views in a schema
> create or replace procedure grant_select_for_schema(
> in schemaname varchar(255), 
> in username varchar(255))
> language java
> parameter style java
> reads sql data
> external name 'applib.applibJar:com.lucidera.luciddb.applib.security.GrantSelectForSchemaUdp.execute';
> 
> -- UDP for executing a sql statement for each table and view in an entire schema
> create or replace procedure do_for_entire_schema(
> in sqlString varchar(65535),
> in schemaName varchar(255),
> in objTypeStr varchar(128))
> language java
> parameter style java
> reads sql data
> external name 'applib.applibJar:com.lucidera.luciddb.applib.util.DoForEntireSchemaUdp.execute';
> 
> -- UDP for computing statistics for all tables in a schema
> create or replace procedure compute_statistics_for_schema(
> in schemaName varchar(255))
> language java
> parameter style java
> reads sql data
> external name 'applib.applibJar:com.lucidera.luciddb.applib.analysis.ComputeStatisticsForSchemaUdp.execute';
> 
> -- UDP for dropping a schema if it exists
> create or replace procedure drop_schema_if_exists(
> in schemaname varchar(255),
> in restrict_or_cascade varchar(255))
> language java
> parameter style java
> reads sql data
> external name  'applib.applibJar:com.lucidera.luciddb.applib.util.DropSchemaIfExistsUdp.execute';
> 
> !quit
